
./bin/bootloader.adx:     file format elf32-nds32le
./bin/bootloader.adx
architecture: n1h_v3, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000100dc

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00002248 memsz 0x000026d4 flags rwx
private flags = 30800a52: n1 instructions

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .nds32_init   00000024  00010000  00010000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         000020e8  00010024  00010024  00001024  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000080  0001210c  0001210c  0000310c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         000000a8  000121a0  000121a0  000031a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          0000048c  00012248  00012248  00003248  2**2
                  ALLOC
  5 .comment      0000002f  00000000  00000000  00003248  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000001c8  00000000  00000000  00003278  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000056d2  00000000  00000000  00003440  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000013a4  00000000  00000000  00008b12  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000042f2  00000000  00000000  00009eb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000007f0  00000000  00000000  0000e1a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000100b0  00000000  00000000  0000e998  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000258f  00000000  00000000  0001ea48  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000d0  00000000  00000000  00020fd8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  00003844  00000000  00000000  000210a8  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .nds32_init	00000000 .nds32_init
00010024 l    d  .text	00000000 .text
0001210c l    d  .rodata	00000000 .rodata
000121a0 l    d  .data	00000000 .data
00012248 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    df *ABS*	00000000 ./src/crt0.o
00010000 l       .nds32_init	00000000 exception_vector
00010024 l       .text	00000000 OS_Trap_TLB_Fill
00010024 l       .text	00000000 OS_Trap_PTE_Not_Present
00010024 l       .text	00000000 OS_Trap_TLB_Misc
00010024 l       .text	00000000 OS_Trap_TLB_VLPT_Miss
00010024 l       .text	00000000 OS_Trap_Machine_Error
00010024 l       .text	00000000 OS_Trap_Debug_Related
00010024 l       .text	00000000 OS_Trap_General_Exception
00010026 l       .text	00000000 OS_Trap_Syscall
00010024 l       .nds32_init	00000000 exception_vector_end
00000000 l    df *ABS*	00000000 init-default.c
00010128 l     F .text	00000002 Default_Handler
00000000 l    df *ABS*	00000000 cache.c
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 bootloader.c
00000000 l    df *ABS*	00000000 spi.c
0001215c l     O .rodata	00000010 gpSPI
0001210c l     O .rodata	00000020 gCS_GPIO
0001212c l     O .rodata	00000030 gCS_PinMux
00000000 l    df *ABS*	00000000 ddr_calibration.c
00010746 l     F .text	00000052 find_center
00010798 l     F .text	000000bc Write_Read_compare
00010854 l     F .text	000004de do_calibration_DQ_DQS_READ
00010d32 l     F .text	00000238 do_calibration_DQ_DQS_WRITE
00010f6a l     F .text	000001ae do_calibration_Leveling
00000000 l    df *ABS*	00000000 clock_init.c
00000000 l    df *ABS*	00000000 clock_powerdown.c
00000000 l    df *ABS*	00000000 flash_boot.c
00000000 l    df *ABS*	00000000 spi_nand_flash.c
000117f0 l     F .text	0000002c snand_flash_wait
00012254 l     O .bss	00000004 gTxBuf
00012250 l     O .bss	00000004 gRxBuf
0001224c l     O .bss	00000004 gPageCachedFlag
000121a8 l     O .data	00000004 gPAGE_SIZE
000121a0 l     O .data	00000004 gBLOCK_SIZE
000121a4 l     O .data	00000004 gPAGES_BLOCK
00012258 l     O .bss	00000058 gstBATL
00012248 l     O .bss	00000004 gCachedAddr
000121fc l     O .data	00000008 gs8BATLMarker
00000000 l    df *ABS*	00000000 spi_memctrl.c
000122b0 l     O .bss	00000001 g_qdma_buf_idx
00000000 l    df *ABS*	00000000 spi_flash.c
00000000 l    df *ABS*	00000000 ddr3.c
00000000 l    df *ABS*	00000000 lib_a-memcmp.o
00000000 l    df *ABS*	00000000 lib_a-memcpy.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 
00011e40 g     F .text	00000002 fail
00011846 g     F .text	00000042 snand_find_id
00010312 g     F .text	00000018 uart_inbyte
0001032a g     F .text	00000046 pattern_test
00010512 g     F .text	000000a8 spi_xfer
00011752 g     F .text	0000009e spi_nand_flash_boot
00011d10 g     F .text	0000006c flash_find_id
00010734 g     F .text	00000012 spi_wait
000102fc g     F .text	00000016 uart_outbyte
000122b4 g     O .bss	00000400 gGlobalBuf
00011d96 g     F .text	0000001a flash_write_status
00010000 g       *ABS*	00000000 LOAD_BEGIN
00010370 g     F .text	0000007e bootloader_main
000118c8 g     F .text	00000084 snand_flash_init
000101b4 g     F .text	00000050 cache_enable
000120b0 g     F .text	0000002c memcpy
00011db0 g     F .text	0000001e flash_write_enable
00012204 g     O .data	00000040 gstFlashIDTable
00011e42 g     F .text	00000232 ddr3_set
00011118 g     F .text	0000003e ddr_calibration
00010150 g     F .text	00000046 __cpu_init
000105e4 g     F .text	0000001a spi_slave_tx_byte
00011dce g     F .text	00000072 flash_init
00011bf0 g     F .text	00000048 spi_memctrl_mode_set
000106c6 g     F .text	00000038 spi_cs_activate
00011bbe g     F .text	0000001a spi_memctrl_set
00010204 g     F .text	0000005e cache_disable
0001028c g     F .text	0000002a cache_inv_range
00011b80 g     F .text	0000003e snand_batl_init
00010196 g     F .text	0000001e __init
00011d7c g     F .text	0000001a flash_read_status
000105ba g     F .text	0000002a spi_slave_tx
000126b4 g     O .bss	00000010 gstFlashNandID
00011be4 g     F .text	0000000c spi_memctrl_crc_get
00011bd8 g     F .text	0000000c spi_memctrl_crc_en
00012438  w      .data	00000000 _FP_BASE_
00002248 g       *ABS*	00000000 LOAD_SIZE
000102b6 g     F .text	00000046 uart_init
000100dc g     F .text	0000004a _start
000118ac g     F .text	0000001c snand_flash_set_feature
000126c4 g     O .bss	00000010 gstFlashID
00012438  w      .data	00000000 _SDA_BASE_
000103ee g     F .text	00000060 spi_initialize
00012074 g     F .text	0000003a memcmp
000105fe g     F .text	00000026 spi_slave_rx
00010000  w      .nds32_init	00000000 _RELAX_END_
000104b0 g     F .text	00000062 spi_rx
00012248 g       .bss	00000000 __bss_start
000120dc g     F .text	0000002e memset
0001194c g     F .text	0000012c snand_flash_read
00011a78 g     F .text	00000108 snand_flash_read_memc
000115e8 g     F .text	00000014 SetClockPD
0001181c g     F .text	0000002a snand_flash_read_id
00011888 g     F .text	00000024 snand_flash_get_feature
0001044e g     F .text	00000062 spi_tx
000115fc g     F .text	00000156 spi_nor_flash_boot
00000000  w      *ABS*	00000000 _ITB_BASE_
000121a0 g       *ABS*	00000000 __data_lmastart
00012248 g       .bss	00000000 _edata
000126d4 g       .bss	00000000 _end
0001063e g     F .text	00000088 spi_direct_cs_enable
00010262 g     F .text	0000002a cache_wb_range
0001012a g     F .text	00000026 __c_init
00011c8e g     F .text	00000058 spi_memctrl_read_qdma
00011c38 g     F .text	00000056 spi_memctrl_qdma_fill_buff
00010128  w    F .text	00000002 syscall_handler
00011156 g     F .text	00000098 asic_init
00013ff0 g       *ABS*	00000000 _stack
000121a0 g       .data	00000000 __data_start
00011ce6 g     F .text	0000002a flash_read_id
000121ac g     O .data	00000050 gstNandFlashIDTable
00010624 g     F .text	0000001a spi_slave_rx_byte
000111ee g     F .text	000003fa clock_powerdown
000106fe g     F .text	00000036 spi_cs_deactivate
00010000 g       *ABS*	00000000 NDS_SAG_LMA_LOAD



Disassembly of section .nds32_init:

00010000 <_RELAX_END_>:
!========================================================================
! Vector table
!========================================================================
	.align 2
exception_vector:
	j _start                    !  (0) Trap Reset
   10000:	48 00 00 6e 	j 100dc <_start>
	vector TLB_Fill             !  (1) Trap TLB fill
   10004:	48 00 00 10 	j 10024 <exception_vector_end>
	vector PTE_Not_Present      !  (2) Trap PTE not present
   10008:	48 00 00 0e 	j 10024 <exception_vector_end>
	vector TLB_Misc             !  (3) Trap TLB misc
   1000c:	48 00 00 0c 	j 10024 <exception_vector_end>
	vector TLB_VLPT_Miss        !  (4) Trap TLB VLPT miss
   10010:	48 00 00 0a 	j 10024 <exception_vector_end>
	vector Machine_Error        !  (5) Trap Machine error
   10014:	48 00 00 08 	j 10024 <exception_vector_end>
	vector Debug_Related        !  (6) Trap Debug related
   10018:	48 00 00 06 	j 10024 <exception_vector_end>
	vector General_Exception    !  (7) Trap General exception
   1001c:	48 00 00 04 	j 10024 <exception_vector_end>
	vector Syscall              !  (8) Syscall
   10020:	48 00 00 03 	j 10026 <OS_Trap_Syscall>

Disassembly of section .text:

00010024 <OS_Trap_Debug_Related>:
OS_Trap_TLB_VLPT_Miss:
OS_Trap_Machine_Error:
OS_Trap_Debug_Related:
OS_Trap_General_Exception:

1:  b   1b
   10024:	d5 00       	j8 10024 <OS_Trap_Debug_Related>

00010026 <OS_Trap_Syscall>:
OS_Trap_Syscall:
	SYSCALL_SAVE_ALL
   10026:	3a 1f a4 3c 	smw.adm $r1,[$sp],$r9,#0x0    ! {$r1~$r9}
   1002a:	3a ff ef bc 	smw.adm $r15,[$sp],$p1,#0xe    ! {$r15~$p1, $fp, $gp, $lp}
   1002e:	42 6e 80 20 	mfusr $r6,$ifc_lp
   10032:	42 7c 80 20 	mfusr $r7,$lb
   10036:	42 8d 00 20 	mfusr $r8,$le
   1003a:	42 9d 80 20 	mfusr $r9,$lc
   1003e:	3a 6f a4 3c 	smw.adm $r6,[$sp],$r9,#0x0    ! {$r6~$r9}
   10042:	3a 6f 98 3c 	smw.adm $r6,[$sp],$r6,#0x0    ! {$r6}
   10046:	64 62 a4 02 	mfsr $r6,$ipc
   1004a:	9d b4       	addi333 $r6,$r6,#0x4
   1004c:	64 72 04 02 	mfsr $r7,$ipsw
   10050:	3a 6f 9c 3c 	smw.adm $r6,[$sp],$r7,#0x0    ! {$r6~$r7}
   10054:	64 62 00 02 	mfsr $r6,$psw
   10058:	56 63 20 02 	xori $r6,$r6,#0x2002
   1005c:	64 62 00 03 	mtsr $r6,$psw
   10060:	64 00 00 08 	dsb
   10064:	51 ff ff f8 	addi $sp,$sp,#-8
   10068:	36 ff 9f fe 	fsdi.bi $fd15,[$sp],#-8
   1006c:	36 ef 9f fe 	fsdi.bi $fd14,[$sp],#-8
   10070:	36 df 9f fe 	fsdi.bi $fd13,[$sp],#-8
   10074:	36 cf 9f fe 	fsdi.bi $fd12,[$sp],#-8
   10078:	36 bf 9f fe 	fsdi.bi $fd11,[$sp],#-8
   1007c:	36 2f 9f fe 	fsdi.bi $fd2,[$sp],#-8
   10080:	36 1f 9f fe 	fsdi.bi $fd1,[$sp],#-8
   10084:	36 0f 80 00 	fsdi $fd0,[$sp+#0x0]
	bal syscall_handler
   10088:	49 00 00 50 	jal 10128 <syscall_handler>
	SYSCALL_RESTORE_ALL
   1008c:	34 0f 90 02 	fldi.bi $fd0,[$sp],#0x8
   10090:	34 1f 90 02 	fldi.bi $fd1,[$sp],#0x8
   10094:	34 2f 90 02 	fldi.bi $fd2,[$sp],#0x8
   10098:	34 bf 90 02 	fldi.bi $fd11,[$sp],#0x8
   1009c:	34 cf 90 02 	fldi.bi $fd12,[$sp],#0x8
   100a0:	34 df 90 02 	fldi.bi $fd13,[$sp],#0x8
   100a4:	34 ef 90 02 	fldi.bi $fd14,[$sp],#0x8
   100a8:	34 ff 90 02 	fldi.bi $fd15,[$sp],#0x8
   100ac:	3a 6f 9c 04 	lmw.bim $r6,[$sp],$r7,#0x0    ! {$r6~$r7}
   100b0:	64 62 a4 03 	mtsr $r6,$ipc
   100b4:	64 72 04 03 	mtsr $r7,$ipsw
   100b8:	3a 6f 98 04 	lmw.bim $r6,[$sp],$r6,#0x0    ! {$r6}
   100bc:	3a 6f a4 04 	lmw.bim $r6,[$sp],$r9,#0x0    ! {$r6~$r9}
   100c0:	42 6e 80 21 	mtusr $r6,$ifc_lp
   100c4:	42 7c 80 21 	mtusr $r7,$lb
   100c8:	42 8d 00 21 	mtusr $r8,$le
   100cc:	42 9d 80 21 	mtusr $r9,$lc
   100d0:	3a ff ef 84 	lmw.bim $r15,[$sp],$p1,#0xe    ! {$r15~$p1, $fp, $gp, $lp}
   100d4:	3a 1f a4 04 	lmw.bim $r1,[$sp],$r9,#0x0    ! {$r1~$r9}
	iret
   100d8:	64 00 00 04 	iret

000100dc <_start>:
_start:
	!************************** Begin of do-not-modify **************************
	! Please don't modify this code
	! Initialize the registers used by the compiler

	nds32_init		! NDS32 startup initial macro in <nds32_init.inc>
   100dc:	45 d1 24 38 	movi $gp,#0x12438
   100e0:	64 00 80 02 	mfsr $r0,$msc_cfg
   100e4:	46 10 10 00 	sethi $r1,#0x1000
   100e8:	40 20 04 02 	and $r2,$r0,$r1
   100ec:	c2 04       	beqz38 $r2,100f4 <_start+0x18>
   100ee:	84 00       	movi55 $r0,#0x0
   100f0:	42 0e 00 21 	mtusr $r0,$itb
   100f4:	64 08 a0 02 	mfsr $r0,$fucpr
   100f8:	58 00 00 01 	ori $r0,$r0,#0x1
   100fc:	64 08 a0 03 	mtsr $r0,$fucpr
   10100:	64 00 00 08 	dsb
   10104:	6a 00 07 01 	fmfcsr $r0
   10108:	58 00 10 00 	ori $r0,$r0,#0x1000
   1010c:	6a 00 07 09 	fmtcsr $r0
   10110:	64 00 00 08 	dsb
   10114:	45 f1 3f f0 	movi $sp,#0x13ff0

#endif //#ifdef CFG_DEBUG

	!*************************** End of do-not-modify ***************************

	bal __init
   10118:	49 00 00 3f 	jal 10196 <__init>
	bal bootloader_main
   1011c:	49 00 01 2a 	jal 10370 <bootloader_main>
	
	beqz $r0, 1f
   10120:	c0 02       	beqz38 $r0,10124 <_start+0x48>

	jr	$r0
   10122:	dd 00       	jr5 $r0

1:  b   1b
   10124:	d5 00       	j8 10124 <_start+0x48>
   10126:	92 00       	nop16

00010128 <syscall_handler>:
#pragma weak syscall_handler         = Default_Handler

__attribute__((unused))
static void Default_Handler()
{
	while (1) ;
   10128:	d5 00       	j8 10128 <syscall_handler>

0001012a <__c_init>:
}

void __c_init()
{
   1012a:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	extern char _end;
	int size;

	/* Copy data section from ROM to RAM*/
	size = &_edata - &__data_start;
	MEMCPY(&__data_start, &__data_lmastart, size);
   1012c:	44 01 21 a0 	movi $r0,#0x121a0
   10130:	44 21 22 48 	movi $r2,#0x12248
   10134:	44 11 21 a0 	movi $r1,#0x121a0
   10138:	8a 40       	sub45 $r2,$r0
   1013a:	49 00 0f bb 	jal 120b0 <memcpy>

	/* Clear bss section */
	size = &_end - &__bss_start;
	MEMSET(&__bss_start, 0, size);
   1013e:	44 01 22 48 	movi $r0,#0x12248
   10142:	44 21 26 d4 	movi $r2,#0x126d4
   10146:	84 20       	movi55 $r1,#0x0
   10148:	8a 40       	sub45 $r2,$r0
   1014a:	49 00 0f c9 	jal 120dc <memset>
   1014e:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

00010150 <__cpu_init>:
{
	unsigned int tmp;

	/* turn on BTB */
	tmp = 0x0;
	__nds32__mtsr(tmp, NDS32_SR_MISC_CTL);
   10150:	84 00       	movi55 $r0,#0x0
   10152:	64 05 e4 03 	mtsr $r0,$misc_ctl

	/* disable all hardware interrupts */
	__nds32__mtsr(0x0, NDS32_SR_INT_MASK);
   10156:	64 03 00 03 	mtsr $r0,$int_mask
	/* INT_MASK2 only exists when IVB.IVIC_VER=1 */
	if (__nds32__mfsr(NDS32_SR_IVB) & (0x1 << 11))
   1015a:	64 12 24 02 	mfsr $r1,$ivb
   1015e:	54 10 88 00 	andi $r1,$r1,#0x800
   10162:	c1 03       	beqz38 $r1,10168 <__cpu_init+0x18>
		__nds32__mtsr(0x0, NDS32_SR_INT_MASK2);
   10164:	64 03 04 03 	mtsr $r0,$int_mask2
	tmp |= (1 << 14);	// set vector size: 16 bytes
#endif
#ifdef CFG_EVIC
	tmp |= (1 << 13);	// set EVIC
#endif
	__nds32__mtsr(tmp, NDS32_SR_IVB);
   10168:	44 01 00 00 	movi $r0,#0x10000
   1016c:	64 02 24 03 	mtsr $r0,$ivb


	/* Set PSW */
	/* set PSW.INTL to 0 and PSW.CPL to 7 to allow any priority */
	tmp = __nds32__mfsr(NDS32_SR_PSW);
   10170:	64 02 00 02 	mfsr $r0,$psw
	tmp &= 0xfffffff9;
   10174:	66 00 00 06 	bitci $r0,$r0,#0x6
	tmp |= 0x70008;
#ifdef CFG_HWZOL
	/* Enable PSW AEN */
	tmp = tmp | 0x2000;
   10178:	44 17 20 08 	movi $r1,#0x72008
   1017c:	fe 0f       	or33 $r0,$r1
#endif
	__nds32__mtsr_dsb(tmp, NDS32_SR_PSW);
   1017e:	64 02 00 03 	mtsr $r0,$psw
   10182:	64 00 00 08 	dsb
	/* Check interrupt priority programmable*
	* IVB.PROG_PRI_LVL
	*      0: Fixed priority       -- no exist ir18 1r19
	*      1: Programmable priority
	*/
	if (__nds32__mfsr(NDS32_SR_IVB) & 0x01) {
   10186:	64 02 24 02 	mfsr $r0,$ivb
   1018a:	96 04       	xlsb33 $r0,$r0
   1018c:	c0 04       	beqz38 $r0,10194 <__cpu_init+0x44>
		/* Set PPL2FIX_EN to 0 to enable Programmable
	 	* Priority Level */
		__nds32__mtsr(0x0, NDS32_SR_INT_CTRL);
   1018e:	84 00       	movi55 $r0,#0x0
   10190:	64 02 28 03 	mtsr $r0,$int_ctrl
   10194:	dd 9e       	ret5 $lp

00010196 <__init>:
	return;
}


void __init()
{
   10196:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
/*----------------------------------------------------------
   !!  Users should NOT add any code before this comment  !!
------------------------------------------------------------*/
	__cpu_init();
   10198:	49 ff ff dc 	jal 10150 <__cpu_init>
	__c_init();     //copy data section, clean bss
   1019c:	49 ff ff c7 	jal 1012a <__c_init>
	 * Check whether the CPU configured with ZOL supported.
	 * The MSC_CFG.MSC_EXT($cr4) indicates MSC_CFG2 register exist
	 * and MSC_CFG2($cr7) bit 5 indicates ZOL supporting.
	 */
#ifdef CFG_HWZOL
	if (!((__nds32__mfsr(NDS32_SR_MSC_CFG) & (3 << 30))
   101a0:	64 00 80 02 	mfsr $r0,$msc_cfg
   101a4:	92 1e       	srli45 $r0,#0x1e
   101a6:	c0 05       	beqz38 $r0,101b0 <__init+0x1a>
	    && (__nds32__mfsr(NDS32_SR_MSC_CFG2) & (1 << 5)))) {
   101a8:	64 00 84 02 	mfsr $r0,$msc_cfg2
   101ac:	96 2e       	bmski33 $r0,#0x5
	 * Check whether the CPU configured with ZOL supported.
	 * The MSC_CFG.MSC_EXT($cr4) indicates MSC_CFG2 register exist
	 * and MSC_CFG2($cr7) bit 5 indicates ZOL supporting.
	 */
#ifdef CFG_HWZOL
	if (!((__nds32__mfsr(NDS32_SR_MSC_CFG) & (3 << 30))
   101ae:	c8 02       	bnez38 $r0,101b2 <__init+0x1c>
	    && (__nds32__mfsr(NDS32_SR_MSC_CFG2) & (1 << 5)))) {
		/* CPU doesn't support ZOL, but build with ZOL supporting. */
		//uart_puts("CPU doesn't support ZOL, but build with ZOL supporting !!\n");
		while(1);
   101b0:	d5 00       	j8 101b0 <__init+0x1a>
   101b2:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000101b4 <cache_enable>:
{

	unsigned int cache_ctl=0, mmu_ctl, icm_cfg, dcm_cfg;

	/* Get ICache ways, sets, line size  */
	icm_cfg = __nds32__mfsr(NDS32_SR_ICM_CFG);
   101b4:	64 00 20 02 	mfsr $r0,$icm_cfg

	if (((icm_cfg & NDS32_ISIZE) >> 6) && ((icm_cfg & NDS32_ISIZE) >> 6) <= 5){
   101b8:	54 00 01 c0 	andi $r0,$r0,#0x1c0
   101bc:	92 06       	srli45 $r0,#0x6
   101be:	8e 01       	subi45 $r0,#0x1
   101c0:	e6 05       	slti45 $r0,#0x5
   101c2:	e8 07       	beqzs8 101d0 <cache_enable+0x1c>
		cache_ctl = __nds32__mfsr(NDS32_SR_CACHE_CTL);
   101c4:	64 05 00 02 	mfsr $r0,$cache_ctl
		cache_ctl |= 0x1;
   101c8:	58 00 00 01 	ori $r0,$r0,#0x1

		/* Enable I Cache */
		__nds32__mtsr(cache_ctl, NDS32_SR_CACHE_CTL);
   101cc:	64 05 00 03 	mtsr $r0,$cache_ctl

	}

	/* Get DCache ways, sets, line size  */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
   101d0:	64 00 40 02 	mfsr $r0,$dcm_cfg

	if (((dcm_cfg & NDS32_DSIZE) >> 6) && ((dcm_cfg & NDS32_DSIZE) >> 6) <= 5){
   101d4:	54 00 01 c0 	andi $r0,$r0,#0x1c0
   101d8:	92 06       	srli45 $r0,#0x6
   101da:	8e 01       	subi45 $r0,#0x1
   101dc:	e6 05       	slti45 $r0,#0x5
   101de:	e8 07       	beqzs8 101ec <cache_enable+0x38>
		cache_ctl = __nds32__mfsr(NDS32_SR_CACHE_CTL);
   101e0:	64 05 00 02 	mfsr $r0,$cache_ctl
		cache_ctl |= 0x2;
   101e4:	58 00 00 02 	ori $r0,$r0,#0x2
		/* Enable D Cache */
		__nds32__mtsr(cache_ctl, NDS32_SR_CACHE_CTL);
   101e8:	64 05 00 03 	mtsr $r0,$cache_ctl
	}

	/* Cacheable/Write-Back for NTC0 */
	mmu_ctl = __nds32__mfsr(NDS32_SR_MMU_CTL);
   101ec:	64 14 00 02 	mfsr $r1,$mmu_ctl
	mmu_ctl &= (~(0x3<<1));
	mmu_ctl |= (0x2 << 1);

	/* Set NTC2(Non-cacheable/Non-coalesable) to PA partition 0*/
	mmu_ctl &= (~(0x3<<5));
	mmu_ctl &= (~(0x3<<15));
   101f0:	44 0e 7f 99 	movi $r0,#-98407
   101f4:	fe 0e       	and33 $r0,$r1
   101f6:	58 00 00 04 	ori $r0,$r0,#0x4

	
	__nds32__mtsr_isb(mmu_ctl, NDS32_SR_MMU_CTL);
   101fa:	64 04 00 03 	mtsr $r0,$mmu_ctl
   101fe:	64 00 00 09 	isb
   10202:	dd 9e       	ret5 $lp

00010204 <cache_disable>:
{
#ifndef __NDS32_ISA_V3M__
	unsigned int dcm_cfg, cache_line, end;

	/* Check if cache available */
	if (!(__nds32__mfsr(NDS32_SR_ICM_CFG) & NDS32_ISIZE) ||
   10204:	64 00 20 02 	mfsr $r0,$icm_cfg
   10208:	54 00 01 c0 	andi $r0,$r0,#0x1c0
   1020c:	c0 2a       	beqz38 $r0,10260 <cache_disable+0x5c>
	    !(__nds32__mfsr(NDS32_SR_CACHE_CTL) & 0x3))
   1020e:	64 05 00 02 	mfsr $r0,$cache_ctl
   10212:	96 0f       	fexti33 $r0,#0x1
{
#ifndef __NDS32_ISA_V3M__
	unsigned int dcm_cfg, cache_line, end;

	/* Check if cache available */
	if (!(__nds32__mfsr(NDS32_SR_ICM_CFG) & NDS32_ISIZE) ||
   10214:	c0 26       	beqz38 $r0,10260 <cache_disable+0x5c>
	    !(__nds32__mfsr(NDS32_SR_CACHE_CTL) & 0x3))
		return;

	/* DCache end = cache line size * cache set * cache way. */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
   10216:	64 10 40 02 	mfsr $r1,$dcm_cfg
	end = cache_line = 1 << (((dcm_cfg & NDS32_DSIZE) >> 6) + 2);
   1021a:	54 00 81 c0 	andi $r0,$r1,#0x1c0
   1021e:	92 06       	srli45 $r0,#0x6
   10220:	8c 02       	addi45 $r0,#0x2
   10222:	84 41       	movi55 $r2,#0x1
   10224:	40 21 00 0c 	sll $r2,$r2,$r0
	end *= (1 << ((dcm_cfg & NDS32_DSET) + 6));
   10228:	54 00 80 07 	andi $r0,$r1,#0x7
	end *= (((dcm_cfg & NDS32_DWAY) >> 3) + 1);
   1022c:	54 10 80 38 	andi $r1,$r1,#0x38
		return;

	/* DCache end = cache line size * cache set * cache way. */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
	end = cache_line = 1 << (((dcm_cfg & NDS32_DSIZE) >> 6) + 2);
	end *= (1 << ((dcm_cfg & NDS32_DSET) + 6));
   10230:	8c 06       	addi45 $r0,#0x6
	end *= (((dcm_cfg & NDS32_DWAY) >> 3) + 1);
   10232:	92 23       	srli45 $r1,#0x3
		return;

	/* DCache end = cache line size * cache set * cache way. */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
	end = cache_line = 1 << (((dcm_cfg & NDS32_DSIZE) >> 6) + 2);
	end *= (1 << ((dcm_cfg & NDS32_DSET) + 6));
   10234:	40 01 00 0c 	sll $r0,$r2,$r0
	end *= (((dcm_cfg & NDS32_DWAY) >> 3) + 1);
   10238:	8c 21       	addi45 $r1,#0x1
   1023a:	fe 0c       	mul33 $r0,$r1

	/* Flush DCache */
	do {
		end -= cache_line;
   1023c:	8a 02       	sub45 $r0,$r2
		__nds32__cctlidx_wbinval(NDS32_CCTL_L1D_IX_WB, end);
   1023e:	64 00 00 21 	cctl $r0,l1d_ix_wb
		__nds32__dsb();
   10242:	64 00 00 08 	dsb
	} while (end > 0);
   10246:	c8 fb       	bnez38 $r0,1023c <cache_disable+0x38>

	/* Invalid DCache */
	__nds32__cctl_l1d_invalall();
   10248:	64 00 00 e1 	cctl l1d_invalall
	__nds32__dsb();
   1024c:	64 00 00 08 	dsb

	/* Disable I/D Cache */
	__nds32__mtsr_dsb(__nds32__mfsr(NDS32_SR_CACHE_CTL) & ~0x3, NDS32_SR_CACHE_CTL);
   10250:	64 05 00 02 	mfsr $r0,$cache_ctl
   10254:	66 00 00 03 	bitci $r0,$r0,#0x3
   10258:	64 05 00 03 	mtsr $r0,$cache_ctl
   1025c:	64 00 00 08 	dsb
   10260:	dd 9e       	ret5 $lp

00010262 <cache_wb_range>:

void cache_wb_range(unsigned int *addr, int size)
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);
   10262:	64 20 40 02 	mfsr $r2,$dcm_cfg
   10266:	54 21 01 c0 	andi $r2,$r2,#0x1c0
   1026a:	92 46       	srli45 $r2,#0x6
   1026c:	84 61       	movi55 $r3,#0x1
   1026e:	8c 42       	addi45 $r2,#0x2
   10270:	40 21 88 0c 	sll $r2,$r3,$r2
	while(size > 0){
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_WB, addr);
		__nds32__dsb();
		addr += (dsize>>2);
   10274:	66 31 00 03 	bitci $r3,$r2,#0x3
void cache_wb_range(unsigned int *addr, int size)
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);
	while(size > 0){
   10278:	4e 17 00 09 	blez $r1,1028a <cache_wb_range+0x28>
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_WB, addr);
   1027c:	64 00 01 21 	cctl $r0,l1d_va_wb,1level
		__nds32__dsb();
   10280:	64 00 00 08 	dsb
		addr += (dsize>>2);
   10284:	88 03       	add45 $r0,$r3
   10286:	8a 22       	sub45 $r1,$r2
   10288:	d5 f8       	j8 10278 <cache_wb_range+0x16>
		size -= dsize;
	}
	
}
   1028a:	dd 9e       	ret5 $lp

0001028c <cache_inv_range>:

void cache_inv_range(unsigned int *addr, int size)
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);
   1028c:	64 20 40 02 	mfsr $r2,$dcm_cfg
   10290:	54 21 01 c0 	andi $r2,$r2,#0x1c0
   10294:	92 46       	srli45 $r2,#0x6
   10296:	84 61       	movi55 $r3,#0x1
   10298:	8c 42       	addi45 $r2,#0x2
   1029a:	40 21 88 0c 	sll $r2,$r3,$r2

	while(size > 0){
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_INVAL, addr);
		__nds32__dsb();
		addr += (dsize>>2);
   1029e:	66 31 00 03 	bitci $r3,$r2,#0x3
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);

	while(size > 0){
   102a2:	4e 17 00 09 	blez $r1,102b4 <cache_inv_range+0x28>
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_INVAL, addr);
   102a6:	64 00 01 01 	cctl $r0,l1d_va_inval,1level
		__nds32__dsb();
   102aa:	64 00 00 08 	dsb
		addr += (dsize>>2);
   102ae:	88 03       	add45 $r0,$r3
   102b0:	8a 22       	sub45 $r1,$r2
   102b2:	d5 f8       	j8 102a2 <cache_inv_range+0x16>
		size -= dsize;
	}
	
}
   102b4:	dd 9e       	ret5 $lp

000102b6 <uart_init>:
void uart_init(uint32 baudrate, uint32 databit, uint32 stopbit, uint32 parity)
{
	uint16 	div = 0;

	//div = UART_CLK / (18 * baudrate);
	div = UART_CLK / (16 * baudrate);
   102b6:	46 40 19 bf 	sethi $r4,#0x19bf
   102ba:	50 42 0c c0 	addi $r4,$r4,#0xcc0
   102be:	94 04       	slli333 $r0,$r0,#0x4
   102c0:	40 02 00 17 	divr $r0,$r0,$r4,$r0

	// Set DLAB to 1
	gpUart->lcr |= (1<<7);
   102c4:	46 4f 0d 00 	sethi $r4,#0xf0d00
   102c8:	04 52 00 0b 	lwi $r5,[$r4+#0x2c]
   102cc:	fe 9f       	or33 $r2,$r3
   102ce:	58 52 80 80 	ori $r5,$r5,#0x80
   102d2:	14 52 00 0b 	swi $r5,[$r4+#0x2c]

	// Set OSCR (default value)
	gpUart->oscr  = 16; 
   102d6:	fa a0       	movpi45 $r5,#0x10
   102d8:	a9 65       	swi333 $r5,[$r4+#0x14]
	//gpUart->oscr  = 18; // minimize error ratio at 27MHz, 115200baud
	
	// Set DLL for baudrate
	gpUart->dll = ((div >> 0) & 0xff);
   102da:	97 40       	zeb33 $r5,$r0
	gpUart->dlm = ((div >> 8) & 0xff);
   102dc:	96 01       	zeh33 $r0,$r0
   102de:	92 08       	srli45 $r0,#0x8
	// Set OSCR (default value)
	gpUart->oscr  = 16; 
	//gpUart->oscr  = 18; // minimize error ratio at 27MHz, 115200baud
	
	// Set DLL for baudrate
	gpUart->dll = ((div >> 0) & 0xff);
   102e0:	14 52 00 08 	swi $r5,[$r4+#0x20]
	gpUart->dlm = ((div >> 8) & 0xff);
   102e4:	14 02 00 09 	swi $r0,[$r4+#0x24]

	// Set DLAB to 0
	gpUart->lcr &= ~(1<<7);
   102e8:	04 02 00 0b 	lwi $r0,[$r4+#0x2c]

	// LCR: data bit, stop bit, parity
	gpUart->lcr = (databit | stopbit | parity);
   102ec:	fe 57       	or33 $r1,$r2
	// Set DLL for baudrate
	gpUart->dll = ((div >> 0) & 0xff);
	gpUart->dlm = ((div >> 8) & 0xff);

	// Set DLAB to 0
	gpUart->lcr &= ~(1<<7);
   102ee:	66 00 00 80 	bitci $r0,$r0,#0x80
   102f2:	14 02 00 0b 	swi $r0,[$r4+#0x2c]

	// LCR: data bit, stop bit, parity
	gpUart->lcr = (databit | stopbit | parity);
   102f6:	14 12 00 0b 	swi $r1,[$r4+#0x2c]
   102fa:	dd 9e       	ret5 $lp

000102fc <uart_outbyte>:
	return (gpUart->rbr & 0xff);
}

static uint8 uart_get_txEmpty (void)
{
	return ((gpUart->lsr>>5)&1);
   102fc:	46 2f 0d 00 	sethi $r2,#0xf0d00
   10300:	04 11 00 0d 	lwi $r1,[$r2+#0x34]
   10304:	96 6e       	bmski33 $r1,#0x5
{
	uint32 reg = 0;

	do {
		reg = uart_get_txEmpty();
	} while(!reg);
   10306:	c1 fd       	beqz38 $r1,10300 <uart_outbyte+0x4>
	return ((gpUart->lsr>>5)&1);
}

static void uart_set_txData (uint8 data)
{
	gpUart->thr = data;
   10308:	46 1f 0d 00 	sethi $r1,#0xf0d00
   1030c:	14 00 80 08 	swi $r0,[$r1+#0x20]
   10310:	dd 9e       	ret5 $lp

00010312 <uart_inbyte>:
/*---------------------------------------------------------------------------*/
static UART_REG_T *gpUart = UART0_CTRL_REG;

static uint8 uart_get_rxReady (void)
{
	return (gpUart->lsr & 1);
   10312:	46 1f 0d 00 	sethi $r1,#0xf0d00
   10316:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
	uart_set_txData(c);
}

uint8 uart_inbyte(void)
{
	while(!uart_get_rxReady());
   1031a:	96 04       	xlsb33 $r0,$r0
   1031c:	c0 fd       	beqz38 $r0,10316 <uart_inbyte+0x4>
	return (gpUart->lsr & 1);
}

static uint8 uart_get_rxData (void)
{
	return (gpUart->rbr & 0xff);
   1031e:	46 0f 0d 00 	sethi $r0,#0xf0d00
   10322:	04 00 00 08 	lwi $r0,[$r0+#0x20]
	while(!uart_get_rxReady());

	//if(gpUart->lsr & 2)dbg("rx buffer overrun\n");

	return uart_get_rxData();
}
   10326:	96 00       	zeb33 $r0,$r0
   10328:	dd 9e       	ret5 $lp

0001032a <pattern_test>:
{
	uint32 ret = 0;
	int i;

	dbg("pattern test. addr: 0x%x, size: 0x%x\n", (uint32)dram_addr, size);
	size /= 4;
   1032a:	92 22       	srli45 $r1,#0x2

	for(i=0;i<size;i++){
   1032c:	84 a0       	movi55 $r5,#0x0
   1032e:	44 20 1c 8f 	movi $r2,#0x1c8f
   10332:	d1 07       	beqs38 $r1,10340 <pattern_test+0x16>
   10334:	42 32 88 24 	mul $r3,$r5,$r2
		*(dram_addr + i) = (i*0x55aa)/3 + i;
   10338:	38 30 16 0a 	sw $r3,[$r0+($r5<<#0x2)]
	int i;

	dbg("pattern test. addr: 0x%x, size: 0x%x\n", (uint32)dram_addr, size);
	size /= 4;

	for(i=0;i<size;i++){
   1033c:	8c a1       	addi45 $r5,#0x1
   1033e:	d5 fa       	j8 10332 <pattern_test+0x8>
}
#endif

//int pattern_test(void)
int pattern_test(uint32 *dram_addr, uint32 size)
{
   10340:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}

	for(i=0;i<size;i++){
		*(dram_addr + i) = (i*0x55aa)/3 + i;
	}

	*((uint32 *)0xf010006c) = 0xffffffff;
   10342:	46 2f 01 00 	sethi $r2,#0xf0100
   10346:	84 7f       	movi55 $r3,#-1
   10348:	14 31 00 1b 	swi $r3,[$r2+#0x6c]
	for(i=0;i<size;i++){
   1034c:	84 a0       	movi55 $r5,#0x0
   1034e:	44 40 1c 8f 	movi $r4,#0x1c8f
   10352:	d1 0d       	beqs38 $r1,1036c <pattern_test+0x42>
   10354:	42 32 90 24 	mul $r3,$r5,$r4
		if(*(dram_addr + i) != ((i*0x55aa)/3 + i)){
   10358:	38 60 16 02 	lw $r6,[$r0+($r5<<#0x2)]
   1035c:	4c 61 80 06 	beq $r6,$r3,10368 <pattern_test+0x3e>
			*((uint32 *)0xf010006c) = i;
   10360:	14 51 00 1b 	swi $r5,[$r2+#0x6c]
			ret = 1;
   10364:	84 01       	movi55 $r0,#0x1
			dbg("ERROR! pattern test. addr: 0x%x, W: 0x%x, R: 0x%x\n", (uint32)dram_addr+i, (i*0x55aa)/3 + i, *(dram_addr + i));
			break;
   10366:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	for(i=0;i<size;i++){
		*(dram_addr + i) = (i*0x55aa)/3 + i;
	}

	*((uint32 *)0xf010006c) = 0xffffffff;
	for(i=0;i<size;i++){
   10368:	8c a1       	addi45 $r5,#0x1
   1036a:	d5 f4       	j8 10352 <pattern_test+0x28>
#endif

//int pattern_test(void)
int pattern_test(uint32 *dram_addr, uint32 size)
{
	uint32 ret = 0;
   1036c:	84 00       	movi55 $r0,#0x0
			break;
		}
	}

	return ret;
}
   1036e:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

00010370 <bootloader_main>:
}

#endif

unsigned int bootloader_main(void)
{
   10370:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	unsigned int jump_addr = 0xffffffff;
	uint32 bootmode = 0;

	cache_disable();
   10372:	49 ff ff 49 	jal 10204 <cache_disable>

	bootmode = *(vuint32 *)(BOOT_MODE_ADDR);
   10376:	46 0f 00 00 	sethi $r0,#0xf0000
	bootmode = (bootmode >> 12)&0x7;

	*(vuint32 *)(MISC_BASE_ADDR + 0x10) = 0x01020302; 	//SDCARD sck in/out
   1037a:	46 10 10 20 	sethi $r1,#0x1020
	unsigned int jump_addr = 0xffffffff;
	uint32 bootmode = 0;

	cache_disable();

	bootmode = *(vuint32 *)(BOOT_MODE_ADDR);
   1037e:	04 60 00 17 	lwi $r6,[$r0+#0x5c]
	bootmode = (bootmode >> 12)&0x7;

	*(vuint32 *)(MISC_BASE_ADDR + 0x10) = 0x01020302; 	//SDCARD sck in/out
   10382:	50 10 83 02 	addi $r1,$r1,#0x302
   10386:	46 0f 01 00 	sethi $r0,#0xf0100
   1038a:	a8 44       	swi333 $r1,[$r0+#0x10]
	*(vuint32 *)(MISC_BASE_ADDR + 0x18) = 0x03030302; 	//QSPI sck in/out
   1038c:	46 10 30 30 	sethi $r1,#0x3030
   10390:	50 10 83 02 	addi $r1,$r1,#0x302
   10394:	a8 46       	swi333 $r1,[$r0+#0x18]
	*(vuint32 *)(MISC_BASE_ADDR + 0x60) = 0;			// set to default ( bootrom use this register bit8~15 )
   10396:	84 20       	movi55 $r1,#0x0
   10398:	14 10 00 18 	swi $r1,[$r0+#0x60]

	//====================================
	// set pll
	//====================================
#ifdef CLOCK_INIT
	asic_init();
   1039c:	49 00 06 dd 	jal 11156 <asic_init>
    SetClockPD();
   103a0:	49 00 09 24 	jal 115e8 <SetClockPD>
#if defined(DDR2_INIT)
	extern void ddr2_set(void);
	ddr2_set();
#elif defined(DDR3_INIT)
	extern void ddr3_set(void);
	ddr3_set();
   103a4:	49 00 0d 4f 	jal 11e42 <ddr3_set>
#if defined(DDR2_INIT)
    ddr_calibration(DDR_CAL_WLEVEL | DDR_CAL_RLEVEL); // ddr calibration
#elif defined(DDR3_INIT)
    // ihkong - 0914
#ifndef DDR_AUTO_LEVELING
	ddr_calibration(DDR_CAL_WLEVEL | DDR_CAL_RLEVEL); // ddr calibration
   103a8:	84 03       	movi55 $r0,#0x3
   103aa:	49 00 06 b7 	jal 11118 <ddr_calibration>

#endif // CLOCK_INIT

/////////////////////////////////////////////////////////////////////////////
	    
	cache_enable(); //must do this position.
   103ae:	49 ff ff 03 	jal 101b4 <cache_enable>
			while(1);
		}
	}
#else

	if(pattern_test((uint32 *)DDR_MEM_BASE, 0x10000)){
   103b2:	46 02 00 00 	sethi $r0,#0x20000
   103b6:	44 11 00 00 	movi $r1,#0x10000
   103ba:	49 ff ff b8 	jal 1032a <pattern_test>
   103be:	c0 02       	beqz38 $r0,103c2 <bootloader_main+0x52>
		dbg("Error!!! ddr test fail\n");
		while(1);
   103c0:	d5 00       	j8 103c0 <bootloader_main+0x50>
	uint32 bootmode = 0;

	cache_disable();

	bootmode = *(vuint32 *)(BOOT_MODE_ADDR);
	bootmode = (bootmode >> 12)&0x7;
   103c2:	40 03 30 09 	srli $r0,$r6,#0xc
   103c6:	96 17       	fexti33 $r0,#0x2
	while(!(*(vuint32 *)(BOOT_INFO_ADDR) & 0x8));
	dbg("waiting ddr init done\n");
#endif

#if defined(SUPPORT_FLASH_BOOT)
	if(bootmode == eBOOT_MODE_NOR_FLASH){
   103c8:	c8 04       	bnez38 $r0,103d0 <bootloader_main+0x60>
		dbg("nor flash boot\n");
		jump_addr = spi_nor_flash_boot();
   103ca:	49 00 09 19 	jal 115fc <spi_nor_flash_boot>
   103ce:	d5 05       	j8 103d8 <bootloader_main+0x68>
	}

	if(bootmode == eBOOT_MODE_NAND_FLASH){
   103d0:	5a 08 04 06 	bnec $r0,#0x4,103dc <bootloader_main+0x6c>
		dbg("nand flash boot\n");
		jump_addr = spi_nand_flash_boot();
   103d4:	49 00 09 bf 	jal 11752 <spi_nand_flash_boot>
		//dbg("external uart boot\n");
		jump_addr = external_boot(eBOOT_MODE_UART);
	}
#endif

	if(jump_addr == 0xffffffff){	// Boot fail
   103d8:	5a 0f ff 06 	bnec $r0,#-1,103e4 <bootloader_main+0x74>
		cache_disable();
   103dc:	49 ff ff 14 	jal 10204 <cache_disable>
		dbg("bootloader boot fail\n");
		//while(1);
		return 0;
   103e0:	84 00       	movi55 $r0,#0x0
   103e2:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}
   103e4:	f0 81       	swi37.sp $r0,[+#0x4]
	uart_outbyte('\r');
	uart_outbyte('\n');
// ===============================================================================
#endif	

	cache_disable();
   103e6:	49 ff ff 0f 	jal 10204 <cache_disable>

	return jump_addr;
   103ea:	f0 01       	lwi37.sp $r0,[+#0x4]
   103ec:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

000103ee <spi_initialize>:
sint32 spi_initialize(sint32 ch, uint32 slave, uint32 freq, uint32 clk_mode, uint32 wordlen, SPI_CALLBACK callback)
{
	sint32 ret = 0;
	uint32 div;

	gpSPI[ch]->ctrl = 7;	// Tx/Rx FIFO reset, SPI reset
   103ee:	44 51 21 5c 	movi $r5,#0x1215c
   103f2:	38 02 82 02 	lw $r0,[$r5+($r0<<#0x2)]
   103f6:	84 a7       	movi55 $r5,#0x7
   103f8:	14 50 00 0c 	swi $r5,[$r0+#0x30]
	while(gpSPI[ch]->ctrl & 7);
   103fc:	04 50 00 0c 	lwi $r5,[$r0+#0x30]
   10400:	97 57       	fexti33 $r5,#0x2
   10402:	cd fd       	bnez38 $r5,103fc <spi_initialize+0xe>
};



sint32 spi_initialize(sint32 ch, uint32 slave, uint32 freq, uint32 clk_mode, uint32 wordlen, SPI_CALLBACK callback)
{
   10404:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	uint32 div;

	gpSPI[ch]->ctrl = 7;	// Tx/Rx FIFO reset, SPI reset
	while(gpSPI[ch]->ctrl & 7);
	
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );
   10406:	97 8c       	xlsb33 $r6,$r1
   10408:	96 cf       	fexti33 $r3,#0x1
   1040a:	8e 81       	subi45 $r4,#0x1
   1040c:	40 31 98 44 	or_slli $r3,$r3,$r6,#0x2
   10410:	97 27       	fexti33 $r4,#0x4
   10412:	40 41 91 04 	or_slli $r4,$r3,$r4,#0x8

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold
   10416:	44 32 02 00 	movi $r3,#0x20200
	uint32 div;

	gpSPI[ch]->ctrl = 7;	// Tx/Rx FIFO reset, SPI reset
	while(gpSPI[ch]->ctrl & 7);
	
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );
   1041a:	a9 04       	swi333 $r4,[$r0+#0x10]

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold
   1041c:	14 30 00 0c 	swi $r3,[$r0+#0x30]

	if(!slave){
   10420:	c9 13       	bnez38 $r1,10446 <spi_initialize+0x58>
		div = (PCLK / (freq * 2)) - 1;
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
   10422:	83 80       	mov55 $fp,$r0
   10424:	b9 10       	lwi37 $r1,[$fp+#0x40]
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold

	if(!slave){
		div = (PCLK / (freq * 2)) - 1;
   10426:	94 91       	slli333 $r2,$r2,#0x1
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
   10428:	66 10 80 ff 	bitci $r1,$r1,#0xff
   1042c:	b9 90       	swi37 $r1,[$fp+#0x40]
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold

	if(!slave){
		div = (PCLK / (freq * 2)) - 1;
   1042e:	46 10 3b 8b 	sethi $r1,#0x3b8b
   10432:	50 10 88 7c 	addi $r1,$r1,#0x87c
   10436:	40 20 88 57 	divr $r2,$r2,$r1,$r2
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
		gpSPI[ch]->timing |= (div & 0xff);
   1043a:	bb 10       	lwi37 $r3,[$fp+#0x40]
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold

	if(!slave){
		div = (PCLK / (freq * 2)) - 1;
   1043c:	8e 41       	subi45 $r2,#0x1
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
		gpSPI[ch]->timing |= (div & 0xff);
   1043e:	96 90       	zeb33 $r2,$r2
   10440:	fe 9f       	or33 $r2,$r3
   10442:	ba 90       	swi37 $r2,[$fp+#0x40]
   10444:	d5 03       	j8 1044a <spi_initialize+0x5c>
	}else{
		gpSPI[ch]->trans_ctrl = SPI_TCR_WR;
   10446:	14 50 00 08 	swi $r5,[$r0+#0x20]
	}
	
	return ret;
}
   1044a:	84 00       	movi55 $r0,#0x0
   1044c:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

0001044e <spi_tx>:


sint32 spi_tx(sint32 ch, const uint8 *dout, uint32 size)
{
   1044e:	fc 61       	push25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}
   10450:	81 41       	mov55 $r10,$r1

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10452:	44 11 21 5c 	movi $r1,#0x1215c
   10456:	38 70 82 02 	lw $r7,[$r1+($r0<<#0x2)]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   1045a:	9e 11       	subi333 $r0,$r2,#0x1

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1045c:	a1 bc       	lwi333 $r6,[$r7+#0x10]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   1045e:	54 00 01 ff 	andi $r0,$r0,#0x1ff

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10462:	92 c8       	srli45 $r6,#0x8
   10464:	97 a7       	fexti33 $r6,#0x4
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   10466:	40 00 30 08 	slli $r0,$r0,#0xc

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1046a:	8c c8       	addi45 $r6,#0x8
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   1046c:	42 00 60 08 	bset $r0,$r0,#0x18
	gpSPI[ch]->cmd = 0;	// start transfer
   10470:	85 20       	movi55 $r9,#0x0
	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   10472:	14 03 80 08 	swi $r0,[$r7+#0x20]
	return ret;
}


sint32 spi_tx(sint32 ch, const uint8 *dout, uint32 size)
{
   10476:	81 62       	mov55 $r11,$r2

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10478:	92 c3       	srli45 $r6,#0x3
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
	gpSPI[ch]->cmd = 0;	// start transfer
   1047a:	14 93 80 09 	swi $r9,[$r7+#0x24]
   1047e:	46 c0 08 00 	sethi $r12,#0x800
	
	for(len_tx=0; len_tx < size;){
   10482:	4c 95 80 12 	beq $r9,$r11,104a6 <spi_tx+0x58>
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1) ){	// Tx not full
   10486:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   1048a:	40 00 30 02 	and $r0,$r0,$r12
   1048e:	c8 fa       	bnez38 $r0,10482 <spi_tx+0x34>
			memcpy(&data, dout, n_bytes);
   10490:	80 2a       	mov55 $r1,$r10
   10492:	b0 01       	addri36.sp $r0,#0x4
   10494:	80 46       	mov55 $r2,$r6
   10496:	49 00 0e 0d 	jal 120b0 <memcpy>
			gpSPI[ch]->data = data;
   1049a:	f0 01       	lwi37.sp $r0,[+#0x4]
   1049c:	14 03 80 0b 	swi $r0,[$r7+#0x2c]
			dout += n_bytes;
   104a0:	89 46       	add45 $r10,$r6
			len_tx++;
   104a2:	8d 21       	addi45 $r9,#0x1
   104a4:	d5 ef       	j8 10482 <spi_tx+0x34>
		}
	}

	while(gpSPI[ch]->status & 1);
   104a6:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   104aa:	96 04       	xlsb33 $r0,$r0
   104ac:	c8 fd       	bnez38 $r0,104a6 <spi_tx+0x58>

	return ret;

}
   104ae:	fc e1       	pop25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}

000104b0 <spi_rx>:

sint32 spi_rx(sint32 ch, uint8 *din, uint32 size)
{
   104b0:	fc 41       	push25 $r10,#8    ! {$r6~$r10, $fp, $gp, $lp}
   104b2:	80 81       	mov55 $r4,$r1
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   104b4:	44 11 21 5c 	movi $r1,#0x1215c
   104b8:	38 70 82 02 	lw $r7,[$r1+($r0<<#0x2)]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   104bc:	9e d1       	subi333 $r3,$r2,#0x1
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   104be:	a1 bc       	lwi333 $r6,[$r7+#0x10]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   104c0:	54 31 81 ff 	andi $r3,$r3,#0x1ff
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   104c4:	92 c8       	srli45 $r6,#0x8
   104c6:	97 a7       	fexti33 $r6,#0x4
   104c8:	8c c8       	addi45 $r6,#0x8
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   104ca:	42 31 e4 08 	bset $r3,$r3,#0x19

	gpSPI[ch]->cmd = 0;	// start transfer
   104ce:	85 20       	movi55 $r9,#0x0
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   104d0:	14 33 80 08 	swi $r3,[$r7+#0x20]
	return ret;

}

sint32 spi_rx(sint32 ch, uint8 *din, uint32 size)
{
   104d4:	81 42       	mov55 $r10,$r2
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   104d6:	92 c3       	srli45 $r6,#0x3
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));

	gpSPI[ch]->cmd = 0;	// start transfer
   104d8:	14 93 80 09 	swi $r9,[$r7+#0x24]

	for(len_rx=0; len_rx < size;){
   104dc:	4c 95 00 16 	beq $r9,$r10,10508 <spi_rx+0x58>
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   104e0:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   104e4:	54 00 40 00 	andi $r0,$r0,#0x4000
   104e8:	c8 fa       	bnez38 $r0,104dc <spi_rx+0x2c>
			val = gpSPI[ch]->data;
   104ea:	04 03 80 0b 	lwi $r0,[$r7+#0x2c]
   104ee:	b6 1f       	swi450 $r0,[$sp]
			data = (uint8)val;
   104f0:	b4 1f       	lwi450 $r0,[$sp]
			memcpy(din, &data, n_bytes);
   104f2:	b0 41       	addri36.sp $r1,#0x4
	gpSPI[ch]->cmd = 0;	// start transfer

	for(len_rx=0; len_rx < size;){
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
			val = gpSPI[ch]->data;
			data = (uint8)val;
   104f4:	96 00       	zeb33 $r0,$r0
   104f6:	f0 81       	swi37.sp $r0,[+#0x4]
			memcpy(din, &data, n_bytes);
   104f8:	80 46       	mov55 $r2,$r6
   104fa:	80 04       	mov55 $r0,$r4
   104fc:	49 00 0d da 	jal 120b0 <memcpy>
   10500:	80 80       	mov55 $r4,$r0
			din += n_bytes;
   10502:	88 86       	add45 $r4,$r6
			len_rx++;
   10504:	8d 21       	addi45 $r9,#0x1
   10506:	d5 eb       	j8 104dc <spi_rx+0x2c>
		}

	}

	while(gpSPI[ch]->status & 1);
   10508:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   1050c:	96 04       	xlsb33 $r0,$r0
   1050e:	c8 fd       	bnez38 $r0,10508 <spi_rx+0x58>

	return ret;
}
   10510:	fc c1       	pop25 $r10,#8    ! {$r6~$r10, $fp, $gp, $lp}

00010512 <spi_xfer>:


sint32 spi_xfer(sint32 ch, const uint8 *dout, uint8 *din, uint32 size)
{
   10512:	fc 61       	push25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10514:	44 91 21 5c 	movi $r9,#0x1215c
	return ret;
}


sint32 spi_xfer(sint32 ch, const uint8 *dout, uint8 *din, uint32 size)
{
   10518:	81 60       	mov55 $r11,$r0
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1051a:	38 04 82 02 	lw $r0,[$r9+($r0<<#0x2)]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));
   1051e:	9f 19       	subi333 $r4,$r3,#0x1
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10520:	a1 84       	lwi333 $r6,[$r0+#0x10]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));
   10522:	54 42 01 ff 	andi $r4,$r4,#0x1ff
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10526:	92 c8       	srli45 $r6,#0x8
   10528:	97 a7       	fexti33 $r6,#0x4
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));

	gpSPI[ch]->cmd = 0;	// start transfer
   1052a:	84 e0       	movi55 $r7,#0x0
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1052c:	8c c8       	addi45 $r6,#0x8
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));
   1052e:	40 42 11 84 	or_slli $r4,$r4,$r4,#0xc
   10532:	83 80       	mov55 $fp,$r0
   10534:	bc 88       	swi37 $r4,[$fp+#0x20]
	return ret;
}


sint32 spi_xfer(sint32 ch, const uint8 *dout, uint8 *din, uint32 size)
{
   10536:	81 41       	mov55 $r10,$r1
   10538:	81 02       	mov55 $r8,$r2
   1053a:	81 83       	mov55 $r12,$r3
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1053c:	92 c3       	srli45 $r6,#0x3
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));

	gpSPI[ch]->cmd = 0;	// start transfer
   1053e:	bf 89       	swi37 $r7,[$fp+#0x24]
	
	for(len_tx=0, len_rx=0; len_rx < size;){
   10540:	81 a7       	mov55 $r13,$r7
   10542:	47 c0 08 00 	sethi $fp,#0x800
   10546:	e2 ec       	slt45 $r7,$r12
   10548:	e8 32       	beqzs8 105ac <spi_xfer+0x9a>
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1)){	// Tx not full
   1054a:	40 f6 b0 06 	slt $r15,$r13,$r12
   1054e:	e8 18       	beqzs8 1057e <spi_xfer+0x6c>
   10550:	38 e4 ae 02 	lw $r14,[$r9+($r11<<#0x2)]
   10554:	04 07 00 0d 	lwi $r0,[$r14+#0x34]
   10558:	40 00 70 02 	and $r0,$r0,$fp
   1055c:	c8 11       	bnez38 $r0,1057e <spi_xfer+0x6c>
			if(dout){
   1055e:	4e a2 00 0c 	beqz $r10,10576 <spi_xfer+0x64>
				memcpy(&data, dout, n_bytes);
   10562:	80 2a       	mov55 $r1,$r10
   10564:	b0 01       	addri36.sp $r0,#0x4
   10566:	80 46       	mov55 $r2,$r6
   10568:	49 00 0d a4 	jal 120b0 <memcpy>
				gpSPI[ch]->data = data;
   1056c:	f0 01       	lwi37.sp $r0,[+#0x4]
   1056e:	14 07 00 0b 	swi $r0,[$r14+#0x2c]
				dout += n_bytes;
   10572:	89 46       	add45 $r10,$r6
   10574:	d5 03       	j8 1057a <spi_xfer+0x68>
			}else{
				gpSPI[ch]->data = 0;
   10576:	14 a7 00 0b 	swi $r10,[$r14+#0x2c]
			}
			len_tx++;
   1057a:	50 d6 80 01 	addi $r13,$r13,#0x1
		}

		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   1057e:	38 14 ae 02 	lw $r1,[$r9+($r11<<#0x2)]
   10582:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   10586:	54 00 40 00 	andi $r0,$r0,#0x4000
   1058a:	c8 de       	bnez38 $r0,10546 <spi_xfer+0x34>
			val = gpSPI[ch]->data;
   1058c:	04 00 80 0b 	lwi $r0,[$r1+#0x2c]
   10590:	b6 1f       	swi450 $r0,[$sp]
			if (din){
   10592:	4e 82 00 0b 	beqz $r8,105a8 <spi_xfer+0x96>
				data = (uint8)val;
   10596:	b4 1f       	lwi450 $r0,[$sp]
				memcpy(din, &data, n_bytes);
   10598:	b0 41       	addri36.sp $r1,#0x4
		}

		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
			val = gpSPI[ch]->data;
			if (din){
				data = (uint8)val;
   1059a:	96 00       	zeb33 $r0,$r0
   1059c:	f0 81       	swi37.sp $r0,[+#0x4]
				memcpy(din, &data, n_bytes);
   1059e:	80 46       	mov55 $r2,$r6
   105a0:	80 08       	mov55 $r0,$r8
   105a2:	49 00 0d 87 	jal 120b0 <memcpy>
				din += n_bytes;
   105a6:	89 06       	add45 $r8,$r6
			}
			len_rx++;
   105a8:	8c e1       	addi45 $r7,#0x1
   105aa:	d5 ce       	j8 10546 <spi_xfer+0x34>
		}

	}

	while(gpSPI[ch]->status & 1);
   105ac:	38 14 ae 02 	lw $r1,[$r9+($r11<<#0x2)]
   105b0:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   105b4:	96 04       	xlsb33 $r0,$r0
   105b6:	c8 fd       	bnez38 $r0,105b0 <spi_xfer+0x9e>

	return ret;
}
   105b8:	fc e1       	pop25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}

000105ba <spi_slave_tx>:


// support only 8 bit
sint32 spi_slave_tx(sint32 ch, const uint8 *dout, uint32 size)
{
   105ba:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	sint32 ret = 0;

	sint32 len_tx;
	
	for(len_tx=0; len_tx < size;){
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1) ){	// Tx not full
   105bc:	44 51 21 5c 	movi $r5,#0x1215c
   105c0:	88 41       	add45 $r2,$r1
   105c2:	46 60 08 00 	sethi $r6,#0x800
{
	sint32 ret = 0;

	sint32 len_tx;
	
	for(len_tx=0; len_tx < size;){
   105c6:	4c 11 00 0d 	beq $r1,$r2,105e0 <spi_slave_tx+0x26>
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1) ){	// Tx not full
   105ca:	38 42 82 02 	lw $r4,[$r5+($r0<<#0x2)]
   105ce:	04 32 00 0d 	lwi $r3,[$r4+#0x34]
   105d2:	fe f6       	and33 $r3,$r6
   105d4:	cb f9       	bnez38 $r3,105c6 <spi_slave_tx+0xc>
			gpSPI[ch]->data = *dout;
   105d6:	08 30 80 01 	lbi.bi $r3,[$r1],#0x1
   105da:	14 32 00 0b 	swi $r3,[$r4+#0x2c]
   105de:	d5 f4       	j8 105c6 <spi_slave_tx+0xc>
		}
	}

	return ret;

}
   105e0:	84 00       	movi55 $r0,#0x0
   105e2:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000105e4 <spi_slave_tx_byte>:
void spi_slave_tx_byte(sint32 ch, const uint8 dout)
{
	while((gpSPI[ch]->status>>23)&1);	// tx full
   105e4:	44 21 21 5c 	movi $r2,#0x1215c
   105e8:	38 21 02 02 	lw $r2,[$r2+($r0<<#0x2)]
   105ec:	46 30 08 00 	sethi $r3,#0x800
   105f0:	04 01 00 0d 	lwi $r0,[$r2+#0x34]
   105f4:	fe 1e       	and33 $r0,$r3
   105f6:	c8 fd       	bnez38 $r0,105f0 <spi_slave_tx_byte+0xc>
	gpSPI[ch]->data = dout;
   105f8:	14 11 00 0b 	swi $r1,[$r2+#0x2c]
   105fc:	dd 9e       	ret5 $lp

000105fe <spi_slave_rx>:

}

sint32 spi_slave_rx(sint32 ch, uint8 *din, uint32 size)
{
   105fe:	88 41       	add45 $r2,$r1
	sint32 ret = 0;
	sint32 len_rx;

	for(len_rx=0; len_rx < size;){
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   10600:	44 51 21 5c 	movi $r5,#0x1215c
sint32 spi_slave_rx(sint32 ch, uint8 *din, uint32 size)
{
	sint32 ret = 0;
	sint32 len_rx;

	for(len_rx=0; len_rx < size;){
   10604:	4c 11 00 0e 	beq $r1,$r2,10620 <spi_slave_rx+0x22>
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   10608:	38 42 82 02 	lw $r4,[$r5+($r0<<#0x2)]
   1060c:	04 32 00 0d 	lwi $r3,[$r4+#0x34]
   10610:	54 31 c0 00 	andi $r3,$r3,#0x4000
   10614:	cb f8       	bnez38 $r3,10604 <spi_slave_rx+0x6>
			*din = gpSPI[ch]->data;
   10616:	04 32 00 0b 	lwi $r3,[$r4+#0x2c]
   1061a:	18 30 80 01 	sbi.bi $r3,[$r1],#0x1
   1061e:	d5 f3       	j8 10604 <spi_slave_rx+0x6>
		}

	}

	return ret;
}
   10620:	84 00       	movi55 $r0,#0x0
   10622:	dd 9e       	ret5 $lp

00010624 <spi_slave_rx_byte>:

uint8 spi_slave_rx_byte(sint32 ch)
{
	uint8 ret;
	
	while((gpSPI[ch]->status>>14)&1);	// rx empty
   10624:	44 11 21 5c 	movi $r1,#0x1215c
   10628:	38 10 82 02 	lw $r1,[$r1+($r0<<#0x2)]
   1062c:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   10630:	54 00 40 00 	andi $r0,$r0,#0x4000
   10634:	c8 fc       	bnez38 $r0,1062c <spi_slave_rx_byte+0x8>

	ret = gpSPI[ch]->data;
   10636:	04 00 80 0b 	lwi $r0,[$r1+#0x2c]
	
	return ret;
}
   1063a:	96 00       	zeb33 $r0,$r0
   1063c:	dd 9e       	ret5 $lp

0001063e <spi_direct_cs_enable>:


sint32 spi_direct_cs_enable(sint32 ch, uint8 en)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   1063e:	44 41 21 0c 	movi $r4,#0x1210c
   10642:	40 22 00 60 	add_slli $r2,$r4,$r0,#0x3
   10646:	a0 91       	lwi333 $r2,[$r2+#0x4]
   10648:	5a 27 ff 3d 	beqc $r2,#-1,106c2 <spi_direct_cs_enable+0x84>
   1064c:	44 31 21 2c 	movi $r3,#0x1212c
	
	if(en){
   10650:	c1 2b       	beqz38 $r1,106a6 <spi_direct_cs_enable+0x68>
		*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) |= (1<<gCS_GPIO[ch].ch);	// gpio output value  set
   10652:	38 42 03 02 	lw $r4,[$r4+($r0<<#0x3)]
   10656:	46 10 00 f0 	sethi $r1,#0xf0
   1065a:	58 10 82 00 	ori $r1,$r1,#0x200
   1065e:	88 24       	add45 $r1,$r4
   10660:	40 10 b0 08 	slli $r1,$r1,#0xc
   10664:	04 40 80 09 	lwi $r4,[$r1+#0x24]
   10668:	84 a1       	movi55 $r5,#0x1
   1066a:	40 22 88 0c 	sll $r2,$r5,$r2
   1066e:	ff 17       	or33 $r4,$r2
   10670:	14 40 80 09 	swi $r4,[$r1+#0x24]
		*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x28) |= (1<<gCS_GPIO[ch].ch);	// gpio dir out 
   10674:	04 40 80 0a 	lwi $r4,[$r1+#0x28]
   10678:	fe a7       	or33 $r2,$r4
   1067a:	14 20 80 0a 	swi $r2,[$r1+#0x28]
		
		//*(vuint32 *)gCS_PinMux[ch].reg &= ~(0xff << gCS_PinMux[ch].offset);
		//*(vuint32 *)gCS_PinMux[ch].reg |= (1 << gCS_PinMux[ch].offset);
		*(vuint32 *)gCS_PinMux[ch].reg &= ~(0x3 << gCS_PinMux[ch].offset);
   1067e:	84 2c       	movi55 $r1,#0xc
   10680:	42 30 04 73 	maddr32 $r3,$r0,$r1
   10684:	84 43       	movi55 $r2,#0x3
   10686:	80 23       	mov55 $r1,$r3
   10688:	b4 63       	lwi450 $r3,[$r3]
   1068a:	a0 09       	lwi333 $r0,[$r1+#0x4]
   1068c:	b4 83       	lwi450 $r4,[$r3]
   1068e:	40 21 00 0c 	sll $r2,$r2,$r0
   10692:	40 22 08 12 	bitc $r2,$r4,$r2
   10696:	b6 43       	swi450 $r2,[$r3]
		*(vuint32 *)gCS_PinMux[ch].reg |= (gCS_PinMux[ch].val << gCS_PinMux[ch].offset);
   10698:	a0 4a       	lwi333 $r1,[$r1+#0x8]
   1069a:	b4 43       	lwi450 $r2,[$r3]
   1069c:	40 10 80 0c 	sll $r1,$r1,$r0
   106a0:	fe 57       	or33 $r1,$r2
   106a2:	b6 23       	swi450 $r1,[$r3]
   106a4:	d5 0d       	j8 106be <spi_direct_cs_enable+0x80>

	}else{
		//*(vuint32 *)gCS_PinMux[ch].reg &= ~(0xff << gCS_PinMux[ch].offset);
		*(vuint32 *)gCS_PinMux[ch].reg &= ~(0x3 << gCS_PinMux[ch].offset);
   106a6:	84 2c       	movi55 $r1,#0xc
   106a8:	42 30 04 73 	maddr32 $r3,$r0,$r1
   106ac:	b4 43       	lwi450 $r2,[$r3]
   106ae:	a0 19       	lwi333 $r0,[$r3+#0x4]
   106b0:	b4 62       	lwi450 $r3,[$r2]
   106b2:	84 23       	movi55 $r1,#0x3
   106b4:	40 00 80 0c 	sll $r0,$r1,$r0
   106b8:	40 01 80 12 	bitc $r0,$r3,$r0
   106bc:	b6 02       	swi450 $r0,[$r2]
		
	}

	return 1;
   106be:	84 01       	movi55 $r0,#0x1
   106c0:	dd 9e       	ret5 $lp
}


sint32 spi_direct_cs_enable(sint32 ch, uint8 en)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   106c2:	80 02       	mov55 $r0,$r2
		
	}

	return 1;

}
   106c4:	dd 9e       	ret5 $lp

000106c6 <spi_cs_activate>:

sint32 spi_cs_activate(sint32 ch)
{

	if(gCS_GPIO[ch].ch == -1)return -1;
   106c6:	44 21 21 0c 	movi $r2,#0x1210c
   106ca:	40 11 00 60 	add_slli $r1,$r2,$r0,#0x3
   106ce:	a0 49       	lwi333 $r1,[$r1+#0x4]
   106d0:	5a 17 ff 15 	beqc $r1,#-1,106fa <spi_cs_activate+0x34>

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) &= (~(1<<gCS_GPIO[ch].ch));	// gpio output value  set 0
   106d4:	38 01 03 02 	lw $r0,[$r2+($r0<<#0x3)]
   106d8:	46 30 00 f0 	sethi $r3,#0xf0
   106dc:	58 31 82 00 	ori $r3,$r3,#0x200
   106e0:	88 60       	add45 $r3,$r0
   106e2:	40 31 b0 08 	slli $r3,$r3,#0xc
   106e6:	04 41 80 09 	lwi $r4,[$r3+#0x24]
   106ea:	84 01       	movi55 $r0,#0x1
   106ec:	40 20 04 0c 	sll $r2,$r0,$r1
   106f0:	40 22 08 12 	bitc $r2,$r4,$r2
   106f4:	14 21 80 09 	swi $r2,[$r3+#0x24]

	return 1;
   106f8:	dd 9e       	ret5 $lp
}

sint32 spi_cs_activate(sint32 ch)
{

	if(gCS_GPIO[ch].ch == -1)return -1;
   106fa:	80 01       	mov55 $r0,$r1

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) &= (~(1<<gCS_GPIO[ch].ch));	// gpio output value  set 0

	return 1;
}
   106fc:	dd 9e       	ret5 $lp

000106fe <spi_cs_deactivate>:

sint32 spi_cs_deactivate(sint32 ch)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   106fe:	44 21 21 0c 	movi $r2,#0x1210c
   10702:	40 11 00 60 	add_slli $r1,$r2,$r0,#0x3
   10706:	a0 49       	lwi333 $r1,[$r1+#0x4]
   10708:	5a 17 ff 14 	beqc $r1,#-1,10730 <spi_cs_deactivate+0x32>

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) |= (1<<gCS_GPIO[ch].ch);	// gpio output value  set 1
   1070c:	38 01 03 02 	lw $r0,[$r2+($r0<<#0x3)]
   10710:	46 30 00 f0 	sethi $r3,#0xf0
   10714:	58 31 82 00 	ori $r3,$r3,#0x200
   10718:	88 60       	add45 $r3,$r0
   1071a:	40 31 b0 08 	slli $r3,$r3,#0xc
   1071e:	04 41 80 09 	lwi $r4,[$r3+#0x24]
   10722:	84 01       	movi55 $r0,#0x1
   10724:	40 20 04 0c 	sll $r2,$r0,$r1
   10728:	fe a7       	or33 $r2,$r4
   1072a:	14 21 80 09 	swi $r2,[$r3+#0x24]

	return 1;
   1072e:	dd 9e       	ret5 $lp
	return 1;
}

sint32 spi_cs_deactivate(sint32 ch)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   10730:	80 01       	mov55 $r0,$r1

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) |= (1<<gCS_GPIO[ch].ch);	// gpio output value  set 1

	return 1;
}
   10732:	dd 9e       	ret5 $lp

00010734 <spi_wait>:

void spi_wait(sint32 ch)
{
	while(gpSPI[ch]->status & 1);
   10734:	44 11 21 5c 	movi $r1,#0x1215c
   10738:	38 10 82 02 	lw $r1,[$r1+($r0<<#0x2)]
   1073c:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   10740:	96 04       	xlsb33 $r0,$r0
   10742:	c8 fd       	bnez38 $r0,1073c <spi_wait+0x8>
}
   10744:	dd 9e       	ret5 $lp

00010746 <find_center>:
    //(*(volatile unsigned int *) 0x80000080 = 0xdeaddead);
}


static int find_center(unsigned int table_array[], int number)
{
   10746:	fc 20       	push25 $r8,#0    ! {$r6~$r8, $fp, $gp, $lp}
    int i;

    int wmax_start = 0;
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;
   10748:	84 40       	movi55 $r2,#0x0
    int cont_pass = 1;
    int i;

    int wmax_start = 0;
    int wmax_num = 0;
    int w_start = 0;
   1074a:	80 c2       	mov55 $r6,$r2
    int final_center = -1;
    int cont_pass = 1;
    int i;

    int wmax_start = 0;
    int wmax_num = 0;
   1074c:	80 82       	mov55 $r4,$r2
{
    int final_center = -1;
    int cont_pass = 1;
    int i;

    int wmax_start = 0;
   1074e:	80 e2       	mov55 $r7,$r2
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;

    cont_pass = 0;
    for(i=0;i<number;i++){
   10750:	80 a2       	mov55 $r5,$r2
    int wmax_start = 0;
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;

    cont_pass = 0;
   10752:	80 62       	mov55 $r3,$r2
    for(i=0;i<number;i++){
   10754:	e0 a1       	slts45 $r5,$r1
   10756:	e8 14       	beqzs8 1077e <find_center+0x38>
    	if(table_array[i] == NUM_PATTERN){
   10758:	39 00 16 02 	lw $r16,[$r0+($r5<<#0x2)]
   1075c:	5b 08 08 09 	bnec $r16,#0x8,1076e <find_center+0x28>
    		if(cont_pass == 0){
   10760:	40 21 8c 1a 	cmovz $r2,$r3,$r3
   10764:	40 62 8c 1a 	cmovz $r6,$r5,$r3
    			w_start = i;
    			w_num = 0;
    		}

    		w_num++;
   10768:	8c 41       	addi45 $r2,#0x1
    		cont_pass = 1;
   1076a:	84 61       	movi55 $r3,#0x1
   1076c:	d5 07       	j8 1077a <find_center+0x34>
    	}else{
    		if(w_num > wmax_num){
   1076e:	e0 82       	slts45 $r4,$r2
   10770:	e8 03       	beqzs8 10776 <find_center+0x30>
   10772:	80 82       	mov55 $r4,$r2
   10774:	80 e6       	mov55 $r7,$r6
    			wmax_start = w_start;
    			wmax_num = w_num;
    		}
    		w_num = 0;
   10776:	84 40       	movi55 $r2,#0x0
    		cont_pass = 0;
   10778:	80 62       	mov55 $r3,$r2
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;

    cont_pass = 0;
    for(i=0;i<number;i++){
   1077a:	8c a1       	addi45 $r5,#0x1
   1077c:	d5 ec       	j8 10754 <find_center+0xe>
    		w_num = 0;
    		cont_pass = 0;
    	}

    }
    if(cont_pass){
   1077e:	c3 03       	beqz38 $r3,10784 <find_center+0x3e>
		if(w_num > wmax_num){
   10780:	e0 82       	slts45 $r4,$r2
   10782:	e9 04       	bnezs8 1078a <find_center+0x44>
			wmax_start = w_start;
			wmax_num = w_num;
		}
    }

    if(wmax_num > 0){
   10784:	c4 08       	beqz38 $r4,10794 <find_center+0x4e>
   10786:	80 44       	mov55 $r2,$r4
   10788:	d5 02       	j8 1078c <find_center+0x46>
   1078a:	80 e6       	mov55 $r7,$r6
    	final_center = wmax_start + (wmax_num-1)/2;
   1078c:	8e 41       	subi45 $r2,#0x1
   1078e:	90 41       	srai45 $r2,#0x1
   10790:	98 3a       	add333 $r0,$r7,$r2
   10792:	fc a0       	pop25 $r8,#0    ! {$r6~$r8, $fp, $gp, $lp}
    }else{
    	final_center = -1;
   10794:	84 1f       	movi55 $r0,#-1
    {
        fail();
    }

    return final_center;
}
   10796:	fc a0       	pop25 $r8,#0    ! {$r6~$r8, $fp, $gp, $lp}

00010798 <Write_Read_compare>:

static int Write_Read_compare(int byte_mode, int bit_mode)
{
   10798:	fc 04       	push25 $r6,#32    ! {$r6, $fp, $gp, $lp}
	unsigned int pattern[NUM_PATTERN] = {0x55555555, 0xAAAAAAAA, 0x44444444, 0xDDDDDDDD, 0x11111111, 0xEEEEEEEE, 0x0F0F0F0F, 0xF0F0F0F0};
   1079a:	44 31 21 6c 	movi $r3,#0x1216c
   1079e:	3b 01 dc 00 	lmw.bi $r16,[$r3],$r23,#0x0    ! {$r16~$r23}
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
   107a2:	e4 04       	sltsi45 $r0,#0x4
    return final_center;
}

static int Write_Read_compare(int byte_mode, int bit_mode)
{
	unsigned int pattern[NUM_PATTERN] = {0x55555555, 0xAAAAAAAA, 0x44444444, 0xDDDDDDDD, 0x11111111, 0xEEEEEEEE, 0x0F0F0F0F, 0xF0F0F0F0};
   107a4:	80 5f       	mov55 $r2,$sp
   107a6:	3b 0f dc 20 	smw.bi $r16,[$sp],$r23,#0x0    ! {$r16~$r23}
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
   107aa:	e8 1b       	beqzs8 107e0 <Write_Read_compare+0x48>
   107ac:	46 32 00 00 	sethi $r3,#0x20000
   107b0:	88 03       	add45 $r0,$r3
		// Write
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
   107b2:	90 23       	srai45 $r1,#0x3
   107b4:	80 80       	mov55 $r4,$r0
   107b6:	84 60       	movi55 $r3,#0x0
   107b8:	38 51 0e 00 	lb $r5,[$r2+($r3<<#0x2)]
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107bc:	8c 61       	addi45 $r3,#0x1
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
   107be:	38 52 04 0c 	sb.bi $r5,[$r4],$r1<<#0x0
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107c2:	5a 38 08 fb 	bnec $r3,#0x8,107b8 <Write_Read_compare+0x20>
   107c6:	84 80       	movi55 $r4,#0x0
   107c8:	80 64       	mov55 $r3,$r4
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
   107ca:	a7 80       	lbi333 $r6,[$r0+#0x0]
   107cc:	38 51 12 00 	lb $r5,[$r2+($r4<<#0x2)]
   107d0:	4c 62 c0 03 	bne $r6,$r5,107d6 <Write_Read_compare+0x3e>
   107d4:	8c 61       	addi45 $r3,#0x1
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
   107d6:	8c 81       	addi45 $r4,#0x1
   107d8:	88 01       	add45 $r0,$r1
   107da:	5a 48 08 f8 	bnec $r4,#0x8,107ca <Write_Read_compare+0x32>
   107de:	d5 39       	j8 10850 <Write_Read_compare+0xb8>
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
   107e0:	5a 08 04 1c 	bnec $r0,#0x4,10818 <Write_Read_compare+0x80>
		// Write
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
   107e4:	90 23       	srai45 $r1,#0x3
   107e6:	46 32 00 00 	sethi $r3,#0x20000
   107ea:	84 00       	movi55 $r0,#0x0
   107ec:	38 41 02 01 	lh $r4,[$r2+($r0<<#0x2)]
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107f0:	8c 01       	addi45 $r0,#0x1
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
   107f2:	38 41 84 0d 	sh.bi $r4,[$r3],$r1<<#0x0
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107f6:	5a 08 08 fb 	bnec $r0,#0x8,107ec <Write_Read_compare+0x54>
   107fa:	84 00       	movi55 $r0,#0x0
   107fc:	46 42 00 00 	sethi $r4,#0x20000
   10800:	80 60       	mov55 $r3,$r0
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) == (volatile unsigned short)(pattern[i]&0xffff) )pass++;
   10802:	a5 a0       	lhi333 $r6,[$r4+#0x0]
   10804:	38 51 02 01 	lh $r5,[$r2+($r0<<#0x2)]
   10808:	4c 62 c0 03 	bne $r6,$r5,1080e <Write_Read_compare+0x76>
   1080c:	8c 61       	addi45 $r3,#0x1
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
   1080e:	8c 01       	addi45 $r0,#0x1
   10810:	88 81       	add45 $r4,$r1
   10812:	5a 08 08 f8 	bnec $r0,#0x8,10802 <Write_Read_compare+0x6a>
   10816:	d5 1d       	j8 10850 <Write_Read_compare+0xb8>
   10818:	46 11 ff ff 	sethi $r1,#0x1ffff
   1081c:	50 10 8f fa 	addi $r1,$r1,#0xffa
   10820:	88 20       	add45 $r1,$r0

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
   10822:	84 60       	movi55 $r3,#0x0
		}

	}else{										// word 0
		// Write
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
   10824:	38 41 0e 01 	lh $r4,[$r2+($r3<<#0x2)]
			if(*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) == (volatile unsigned short)(pattern[i]&0xffff) )pass++;
		}

	}else{										// word 0
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   10828:	8c 61       	addi45 $r3,#0x1
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
   1082a:	ab 09       	swi333.bi $r4,[$r1],#0x4
			if(*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) == (volatile unsigned short)(pattern[i]&0xffff) )pass++;
		}

	}else{										// word 0
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   1082c:	5a 38 08 fc 	bnec $r3,#0x8,10824 <Write_Read_compare+0x8c>
   10830:	46 41 ff ff 	sethi $r4,#0x1ffff
   10834:	84 20       	movi55 $r1,#0x0
   10836:	50 42 0f fa 	addi $r4,$r4,#0xffa
   1083a:	80 61       	mov55 $r3,$r1
   1083c:	88 04       	add45 $r0,$r4
   1083e:	99 01       	add333 $r4,$r0,$r1
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) == (volatile unsigned int)(pattern[i]&0xffff) )pass++;
   10840:	b4 a4       	lwi450 $r5,[$r4]
   10842:	38 41 04 01 	lh $r4,[$r2+($r1<<#0x0)]
   10846:	dc 02       	bnes38 $r4,1084a <Write_Read_compare+0xb2>
   10848:	8c 61       	addi45 $r3,#0x1
   1084a:	8c 24       	addi45 $r1,#0x4
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
   1084c:	5a 18 20 f9 	bnec $r1,#0x20,1083e <Write_Read_compare+0xa6>
		}

	}

	return pass;
}
   10850:	80 03       	mov55 $r0,$r3
   10852:	fc 84       	pop25 $r6,#32    ! {$r6, $fp, $gp, $lp}

00010854 <do_calibration_DQ_DQS_READ>:
#endif

}

static void do_calibration_DQ_DQS_READ()
{
   10854:	fc 65       	push25 $r14,#40    ! {$r6~$r14, $fp, $gp, $lp}
   10856:	36 3f 80 00 	fsdi $fd3,[$sp+#0x0]
   1085a:	36 4f 80 02 	fsdi $fd4,[$sp+#0x8]
   1085e:	36 5f 80 04 	fsdi $fd5,[$sp+#0x10]
   10862:	36 6f 80 06 	fsdi $fd6,[$sp+#0x18]
   10866:	36 7f 80 08 	fsdi $fd7,[$sp+#0x20]
   1086a:	51 ff fd b0 	addi $sp,$sp,#-592
    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   1086e:	46 cf 05 00 	sethi $r12,#0xf0500
    unsigned int DQS_RD_FALL_B3_result;


    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10872:	85 20       	movi55 $r9,#0x0

        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   10874:	50 b6 00 24 	addi $r11,$r12,#0x24
                LOOPDELAY_10USEC(1); // wait 10us
   10878:	46 6f 00 00 	sethi $r6,#0xf0000

    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
   1087c:	f0 02       	lwi37.sp $r0,[+#0x8]
   1087e:	44 00 11 11 	movi $r0,#0x1111
   10882:	42 04 80 24 	mul $r0,$r9,$r0
   10886:	f0 82       	swi37.sp $r0,[+#0x8]
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10888:	f0 02       	lwi37.sp $r0,[+#0x8]
   1088a:	14 06 00 1b 	swi $r0,[$r12+#0x6c]
        if (DQSDLSEL_count == 0) {
   1088e:	4e 93 00 64 	bnez $r9,10956 <do_calibration_DQ_DQS_READ+0x102>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   10892:	50 af 80 50 	addi $r10,$sp,#0x50
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
   10896:	f0 01       	lwi37.sp $r0,[+#0x4]
   10898:	14 9f 80 01 	swi $r9,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   1089c:	f0 01       	lwi37.sp $r0,[+#0x4]
   1089e:	b6 0b       	swi450 $r0,[$r11]
   108a0:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   108a2:	b4 06       	lwi450 $r0,[$r6]
   108a4:	f0 84       	swi37.sp $r0,[+#0x10]
   108a6:	f0 04       	lwi37.sp $r0,[+#0x10]
   108a8:	8e e1       	subi45 $r7,#0x1
   108aa:	b6 06       	swi450 $r0,[$r6]
   108ac:	cf fb       	bnez38 $r7,108a2 <do_calibration_DQ_DQS_READ+0x4e>

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   108ae:	80 07       	mov55 $r0,$r7
   108b0:	fa 30       	movpi45 $r1,#0x20
   108b2:	49 ff ff 73 	jal 10798 <Write_Read_compare>
   108b6:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   108ba:	8d 21       	addi45 $r9,#0x1
   108bc:	5a 98 08 ed 	bnec $r9,#0x8,10896 <do_calibration_DQ_DQS_READ+0x42>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   108c0:	50 af 80 70 	addi $r10,$sp,#0x70

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
   108c4:	f0 01       	lwi37.sp $r0,[+#0x4]
   108c6:	40 03 a0 08 	slli $r0,$r7,#0x8
   108ca:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   108cc:	f0 01       	lwi37.sp $r0,[+#0x4]
   108ce:	b6 0b       	swi450 $r0,[$r11]
   108d0:	85 2f       	movi55 $r9,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   108d2:	b4 06       	lwi450 $r0,[$r6]
   108d4:	f0 85       	swi37.sp $r0,[+#0x14]
   108d6:	f0 05       	lwi37.sp $r0,[+#0x14]
   108d8:	8f 21       	subi45 $r9,#0x1
   108da:	b6 06       	swi450 $r0,[$r6]
   108dc:	4e 93 ff fb 	bnez $r9,108d2 <do_calibration_DQ_DQS_READ+0x7e>

                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   108e0:	84 01       	movi55 $r0,#0x1
   108e2:	fa 30       	movpi45 $r1,#0x20
   108e4:	49 ff ff 5a 	jal 10798 <Write_Read_compare>
   108e8:	38 05 1e 0a 	sw $r0,[$r10+($r7<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   108ec:	8c e1       	addi45 $r7,#0x1
   108ee:	5a 78 08 eb 	bnec $r7,#0x8,108c4 <do_calibration_DQ_DQS_READ+0x70>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   108f2:	50 af 80 90 	addi $r10,$sp,#0x90
                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
   108f6:	f0 01       	lwi37.sp $r0,[+#0x4]
   108f8:	40 04 c0 08 	slli $r0,$r9,#0x10
   108fc:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   108fe:	f0 01       	lwi37.sp $r0,[+#0x4]
   10900:	b6 0b       	swi450 $r0,[$r11]
   10902:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10904:	b4 06       	lwi450 $r0,[$r6]
   10906:	f0 86       	swi37.sp $r0,[+#0x18]
   10908:	f0 06       	lwi37.sp $r0,[+#0x18]
   1090a:	8e e1       	subi45 $r7,#0x1
   1090c:	b6 06       	swi450 $r0,[$r6]
   1090e:	cf fb       	bnez38 $r7,10904 <do_calibration_DQ_DQS_READ+0xb0>

                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   10910:	84 02       	movi55 $r0,#0x2
   10912:	fa 30       	movpi45 $r1,#0x20
   10914:	49 ff ff 42 	jal 10798 <Write_Read_compare>
   10918:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]

                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   1091c:	8d 21       	addi45 $r9,#0x1
   1091e:	5a 98 08 ec 	bnec $r9,#0x8,108f6 <do_calibration_DQ_DQS_READ+0xa2>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   10922:	50 9f 80 b0 	addi $r9,$sp,#0xb0
                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
   10926:	f0 01       	lwi37.sp $r0,[+#0x4]
   10928:	40 03 e0 08 	slli $r0,$r7,#0x18
   1092c:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   1092e:	f0 01       	lwi37.sp $r0,[+#0x4]
   10930:	b6 0b       	swi450 $r0,[$r11]
   10932:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10934:	b4 26       	lwi450 $r1,[$r6]
   10936:	f1 87       	swi37.sp $r1,[+#0x1c]
   10938:	f1 07       	lwi37.sp $r1,[+#0x1c]
   1093a:	8e 01       	subi45 $r0,#0x1
   1093c:	b6 26       	swi450 $r1,[$r6]
   1093e:	c8 fb       	bnez38 $r0,10934 <do_calibration_DQ_DQS_READ+0xe0>

                DQ_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   10940:	84 03       	movi55 $r0,#0x3
   10942:	fa 30       	movpi45 $r1,#0x20
   10944:	49 ff ff 2a 	jal 10798 <Write_Read_compare>
   10948:	38 04 9e 0a 	sw $r0,[$r9+($r7<<#0x2)]

                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   1094c:	8c e1       	addi45 $r7,#0x1
   1094e:	5a 78 08 ec 	bnec $r7,#0x8,10926 <do_calibration_DQ_DQS_READ+0xd2>
   10952:	85 21       	movi55 $r9,#0x1
   10954:	d5 94       	j8 1087c <do_calibration_DQ_DQS_READ+0x28>
   10956:	85 40       	movi55 $r10,#0x0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   10958:	50 df 80 d0 	addi $r13,$sp,#0xd0
        }

        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
   1095c:	f0 01       	lwi37.sp $r0,[+#0x4]
   1095e:	14 af 80 01 	swi $r10,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   10962:	f0 01       	lwi37.sp $r0,[+#0x4]
   10964:	b6 0b       	swi450 $r0,[$r11]
   10966:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10968:	b4 06       	lwi450 $r0,[$r6]
   1096a:	f0 88       	swi37.sp $r0,[+#0x20]
   1096c:	f0 08       	lwi37.sp $r0,[+#0x20]
   1096e:	8e e1       	subi45 $r7,#0x1
   10970:	b6 06       	swi450 $r0,[$r6]
   10972:	cf fb       	bnez38 $r7,10968 <do_calibration_DQ_DQS_READ+0x114>

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   10974:	80 07       	mov55 $r0,$r7
   10976:	fa 30       	movpi45 $r1,#0x20
   10978:	49 ff ff 10 	jal 10798 <Write_Read_compare>
   1097c:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]
            }
        }

        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   10980:	8d 41       	addi45 $r10,#0x1
   10982:	5a a8 08 ed 	bnec $r10,#0x8,1095c <do_calibration_DQ_DQS_READ+0x108>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   10986:	50 df 80 f0 	addi $r13,$sp,#0xf0

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
   1098a:	f0 01       	lwi37.sp $r0,[+#0x4]
   1098c:	40 03 a0 08 	slli $r0,$r7,#0x8
   10990:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   10992:	f0 01       	lwi37.sp $r0,[+#0x4]
   10994:	b6 0b       	swi450 $r0,[$r11]
   10996:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10998:	b4 06       	lwi450 $r0,[$r6]
   1099a:	f0 89       	swi37.sp $r0,[+#0x24]
   1099c:	f0 09       	lwi37.sp $r0,[+#0x24]
   1099e:	8f 41       	subi45 $r10,#0x1
   109a0:	b6 06       	swi450 $r0,[$r6]
   109a2:	4e a3 ff fb 	bnez $r10,10998 <do_calibration_DQ_DQS_READ+0x144>

                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   109a6:	84 01       	movi55 $r0,#0x1
   109a8:	fa 30       	movpi45 $r1,#0x20
   109aa:	49 ff fe f7 	jal 10798 <Write_Read_compare>
   109ae:	38 06 9e 0a 	sw $r0,[$r13+($r7<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   109b2:	8c e1       	addi45 $r7,#0x1
   109b4:	5a 78 08 eb 	bnec $r7,#0x8,1098a <do_calibration_DQ_DQS_READ+0x136>
   109b8:	80 ea       	mov55 $r7,$r10
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   109ba:	50 df 81 10 	addi $r13,$sp,#0x110
                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
   109be:	f0 01       	lwi37.sp $r0,[+#0x4]
   109c0:	40 03 c0 08 	slli $r0,$r7,#0x10
   109c4:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   109c6:	f0 01       	lwi37.sp $r0,[+#0x4]
   109c8:	b6 0b       	swi450 $r0,[$r11]
   109ca:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   109cc:	b4 06       	lwi450 $r0,[$r6]
   109ce:	f0 8a       	swi37.sp $r0,[+#0x28]
   109d0:	f0 0a       	lwi37.sp $r0,[+#0x28]
   109d2:	8f 41       	subi45 $r10,#0x1
   109d4:	b6 06       	swi450 $r0,[$r6]
   109d6:	4e a3 ff fb 	bnez $r10,109cc <do_calibration_DQ_DQS_READ+0x178>

                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   109da:	84 02       	movi55 $r0,#0x2
   109dc:	fa 30       	movpi45 $r1,#0x20
   109de:	49 ff fe dd 	jal 10798 <Write_Read_compare>
   109e2:	38 06 9e 0a 	sw $r0,[$r13+($r7<<#0x2)]

                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   109e6:	8c e1       	addi45 $r7,#0x1
   109e8:	5a 78 08 eb 	bnec $r7,#0x8,109be <do_calibration_DQ_DQS_READ+0x16a>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   109ec:	50 df 81 30 	addi $r13,$sp,#0x130
                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
   109f0:	f0 01       	lwi37.sp $r0,[+#0x4]
   109f2:	40 05 60 08 	slli $r0,$r10,#0x18
   109f6:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   109f8:	f0 01       	lwi37.sp $r0,[+#0x4]
   109fa:	b6 0b       	swi450 $r0,[$r11]
   109fc:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   109fe:	b4 06       	lwi450 $r0,[$r6]
   10a00:	f0 8b       	swi37.sp $r0,[+#0x2c]
   10a02:	f0 0b       	lwi37.sp $r0,[+#0x2c]
   10a04:	8e e1       	subi45 $r7,#0x1
   10a06:	b6 06       	swi450 $r0,[$r6]
   10a08:	cf fb       	bnez38 $r7,109fe <do_calibration_DQ_DQS_READ+0x1aa>

                DQS_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   10a0a:	84 03       	movi55 $r0,#0x3
   10a0c:	fa 30       	movpi45 $r1,#0x20
   10a0e:	49 ff fe c5 	jal 10798 <Write_Read_compare>
   10a12:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]

                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   10a16:	8d 41       	addi45 $r10,#0x1
   10a18:	5a a8 08 ec 	bnec $r10,#0x8,109f0 <do_calibration_DQ_DQS_READ+0x19c>
    unsigned int DQS_RD_FALL_B3_result;


    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10a1c:	5a 98 01 9b 	bnec $r9,#0x1,10952 <do_calibration_DQ_DQS_READ+0xfe>

    // RD FALL
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10a20:	46 cf 05 00 	sethi $r12,#0xf0500
        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a24:	50 b6 01 30 	addi $r11,$r12,#0x130
                LOOPDELAY_10USEC(1); // wait 10us
   10a28:	46 9f 00 00 	sethi $r9,#0xf0000
    }

    // RD FALL
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
   10a2c:	f0 02       	lwi37.sp $r0,[+#0x8]
   10a2e:	44 00 11 11 	movi $r0,#0x1111
   10a32:	fe 3c       	mul33 $r0,$r7
   10a34:	f0 82       	swi37.sp $r0,[+#0x8]
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10a36:	f0 02       	lwi37.sp $r0,[+#0x8]
   10a38:	14 06 00 1b 	swi $r0,[$r12+#0x6c]
        if (DQSDLSEL_count == 0) {
   10a3c:	cf 61       	bnez38 $r7,10afe <do_calibration_DQ_DQS_READ+0x2aa>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10a3e:	50 af 81 50 	addi $r10,$sp,#0x150
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
   10a42:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a44:	f7 83       	swi37.sp $r7,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a46:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a48:	b6 0b       	swi450 $r0,[$r11]
   10a4a:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10a4c:	b4 09       	lwi450 $r0,[$r9]
   10a4e:	f0 8c       	swi37.sp $r0,[+#0x30]
   10a50:	f0 0c       	lwi37.sp $r0,[+#0x30]
   10a52:	8e c1       	subi45 $r6,#0x1
   10a54:	b6 09       	swi450 $r0,[$r9]
   10a56:	ce fb       	bnez38 $r6,10a4c <do_calibration_DQ_DQS_READ+0x1f8>

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10a58:	80 06       	mov55 $r0,$r6
   10a5a:	fa 30       	movpi45 $r1,#0x20
   10a5c:	49 ff fe 9e 	jal 10798 <Write_Read_compare>
   10a60:	38 05 1e 0a 	sw $r0,[$r10+($r7<<#0x2)]
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10a64:	8c e1       	addi45 $r7,#0x1
   10a66:	5a 78 08 ee 	bnec $r7,#0x8,10a42 <do_calibration_DQ_DQS_READ+0x1ee>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10a6a:	50 af 81 70 	addi $r10,$sp,#0x170

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
   10a6e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a70:	40 03 20 08 	slli $r0,$r6,#0x8
   10a74:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a76:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a78:	b6 0b       	swi450 $r0,[$r11]
   10a7a:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10a7c:	b4 09       	lwi450 $r0,[$r9]
   10a7e:	f0 8d       	swi37.sp $r0,[+#0x34]
   10a80:	f0 0d       	lwi37.sp $r0,[+#0x34]
   10a82:	8e e1       	subi45 $r7,#0x1
   10a84:	b6 09       	swi450 $r0,[$r9]
   10a86:	cf fb       	bnez38 $r7,10a7c <do_calibration_DQ_DQS_READ+0x228>

                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10a88:	84 01       	movi55 $r0,#0x1
   10a8a:	fa 30       	movpi45 $r1,#0x20
   10a8c:	49 ff fe 86 	jal 10798 <Write_Read_compare>
   10a90:	38 05 1a 0a 	sw $r0,[$r10+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10a94:	8c c1       	addi45 $r6,#0x1
   10a96:	5a 68 08 ec 	bnec $r6,#0x8,10a6e <do_calibration_DQ_DQS_READ+0x21a>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10a9a:	50 af 81 90 	addi $r10,$sp,#0x190
                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
   10a9e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10aa0:	40 03 c0 08 	slli $r0,$r7,#0x10
   10aa4:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10aa6:	f0 03       	lwi37.sp $r0,[+#0xc]
   10aa8:	b6 0b       	swi450 $r0,[$r11]
   10aaa:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10aac:	b4 09       	lwi450 $r0,[$r9]
   10aae:	f0 8e       	swi37.sp $r0,[+#0x38]
   10ab0:	f0 0e       	lwi37.sp $r0,[+#0x38]
   10ab2:	8e c1       	subi45 $r6,#0x1
   10ab4:	b6 09       	swi450 $r0,[$r9]
   10ab6:	ce fb       	bnez38 $r6,10aac <do_calibration_DQ_DQS_READ+0x258>

                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10ab8:	84 02       	movi55 $r0,#0x2
   10aba:	fa 30       	movpi45 $r1,#0x20
   10abc:	49 ff fe 6e 	jal 10798 <Write_Read_compare>
   10ac0:	38 05 1e 0a 	sw $r0,[$r10+($r7<<#0x2)]

                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10ac4:	8c e1       	addi45 $r7,#0x1
   10ac6:	5a 78 08 ec 	bnec $r7,#0x8,10a9e <do_calibration_DQ_DQS_READ+0x24a>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10aca:	50 7f 81 b0 	addi $r7,$sp,#0x1b0
                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
   10ace:	f0 03       	lwi37.sp $r0,[+#0xc]
   10ad0:	40 03 60 08 	slli $r0,$r6,#0x18
   10ad4:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10ad6:	f0 03       	lwi37.sp $r0,[+#0xc]
   10ad8:	b6 0b       	swi450 $r0,[$r11]
   10ada:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10adc:	b4 29       	lwi450 $r1,[$r9]
   10ade:	f1 8f       	swi37.sp $r1,[+#0x3c]
   10ae0:	f1 0f       	lwi37.sp $r1,[+#0x3c]
   10ae2:	8e 01       	subi45 $r0,#0x1
   10ae4:	b6 29       	swi450 $r1,[$r9]
   10ae6:	c8 fb       	bnez38 $r0,10adc <do_calibration_DQ_DQS_READ+0x288>

                DQ_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10ae8:	84 03       	movi55 $r0,#0x3
   10aea:	fa 30       	movpi45 $r1,#0x20
   10aec:	49 ff fe 56 	jal 10798 <Write_Read_compare>
   10af0:	38 03 9a 0a 	sw $r0,[$r7+($r6<<#0x2)]

                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10af4:	8c c1       	addi45 $r6,#0x1
   10af6:	5a 68 08 ec 	bnec $r6,#0x8,10ace <do_calibration_DQ_DQS_READ+0x27a>
   10afa:	84 e1       	movi55 $r7,#0x1
   10afc:	d5 98       	j8 10a2c <do_calibration_DQ_DQS_READ+0x1d8>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10afe:	50 0f 81 d0 	addi $r0,$sp,#0x1d0
   10b02:	6a 07 00 09 	fmtsr $r0,$fs14
   10b06:	85 40       	movi55 $r10,#0x0

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
   10b08:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b0a:	14 af 80 03 	swi $r10,[$sp+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10b0e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b10:	b6 0b       	swi450 $r0,[$r11]
   10b12:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10b14:	b4 09       	lwi450 $r0,[$r9]
   10b16:	f0 90       	swi37.sp $r0,[+#0x40]
   10b18:	f0 10       	lwi37.sp $r0,[+#0x40]
   10b1a:	8e c1       	subi45 $r6,#0x1
   10b1c:	b6 09       	swi450 $r0,[$r9]
   10b1e:	ce fb       	bnez38 $r6,10b14 <do_calibration_DQ_DQS_READ+0x2c0>

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10b20:	fa 30       	movpi45 $r1,#0x20
   10b22:	80 06       	mov55 $r0,$r6
   10b24:	49 ff fe 3a 	jal 10798 <Write_Read_compare>
   10b28:	6a 17 00 01 	fmfsr $r1,$fs14
   10b2c:	38 00 aa 0a 	sw $r0,[$r1+($r10<<#0x2)]
            }

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10b30:	8d 41       	addi45 $r10,#0x1
   10b32:	5a a8 08 eb 	bnec $r10,#0x8,10b08 <do_calibration_DQ_DQS_READ+0x2b4>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10b36:	50 0f 81 f0 	addi $r0,$sp,#0x1f0
   10b3a:	6a 07 80 09 	fmtsr $r0,$fs15

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
   10b3e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b40:	40 03 20 08 	slli $r0,$r6,#0x8
   10b44:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10b46:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b48:	b6 0b       	swi450 $r0,[$r11]
   10b4a:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10b4c:	b4 09       	lwi450 $r0,[$r9]
   10b4e:	f0 91       	swi37.sp $r0,[+#0x44]
   10b50:	f0 11       	lwi37.sp $r0,[+#0x44]
   10b52:	8f 41       	subi45 $r10,#0x1
   10b54:	b6 09       	swi450 $r0,[$r9]
   10b56:	4e a3 ff fb 	bnez $r10,10b4c <do_calibration_DQ_DQS_READ+0x2f8>

                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10b5a:	fa 30       	movpi45 $r1,#0x20
   10b5c:	84 01       	movi55 $r0,#0x1
   10b5e:	49 ff fe 1d 	jal 10798 <Write_Read_compare>
   10b62:	6a 17 80 01 	fmfsr $r1,$fs15
   10b66:	38 00 9a 0a 	sw $r0,[$r1+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10b6a:	8c c1       	addi45 $r6,#0x1
   10b6c:	5a 68 08 e9 	bnec $r6,#0x8,10b3e <do_calibration_DQ_DQS_READ+0x2ea>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10b70:	50 0f 82 10 	addi $r0,$sp,#0x210
   10b74:	6a 06 80 09 	fmtsr $r0,$fs13
                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
   10b78:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b7a:	40 05 40 08 	slli $r0,$r10,#0x10
   10b7e:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10b80:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b82:	b6 0b       	swi450 $r0,[$r11]
   10b84:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10b86:	b4 09       	lwi450 $r0,[$r9]
   10b88:	f0 92       	swi37.sp $r0,[+#0x48]
   10b8a:	f0 12       	lwi37.sp $r0,[+#0x48]
   10b8c:	8e c1       	subi45 $r6,#0x1
   10b8e:	b6 09       	swi450 $r0,[$r9]
   10b90:	ce fb       	bnez38 $r6,10b86 <do_calibration_DQ_DQS_READ+0x332>

                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10b92:	fa 30       	movpi45 $r1,#0x20
   10b94:	84 02       	movi55 $r0,#0x2
   10b96:	49 ff fe 01 	jal 10798 <Write_Read_compare>
   10b9a:	6a 16 80 01 	fmfsr $r1,$fs13
   10b9e:	38 00 aa 0a 	sw $r0,[$r1+($r10<<#0x2)]

                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10ba2:	8d 41       	addi45 $r10,#0x1
   10ba4:	5a a8 08 ea 	bnec $r10,#0x8,10b78 <do_calibration_DQ_DQS_READ+0x324>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10ba8:	50 0f 82 30 	addi $r0,$sp,#0x230
   10bac:	6a 06 00 09 	fmtsr $r0,$fs12
                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
   10bb0:	f0 03       	lwi37.sp $r0,[+#0xc]
   10bb2:	40 03 60 08 	slli $r0,$r6,#0x18
   10bb6:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10bb8:	f0 03       	lwi37.sp $r0,[+#0xc]
   10bba:	b6 0b       	swi450 $r0,[$r11]
   10bbc:	84 2f       	movi55 $r1,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10bbe:	b4 09       	lwi450 $r0,[$r9]
   10bc0:	f0 93       	swi37.sp $r0,[+#0x4c]
   10bc2:	f0 13       	lwi37.sp $r0,[+#0x4c]
   10bc4:	8e 21       	subi45 $r1,#0x1
   10bc6:	b6 09       	swi450 $r0,[$r9]
   10bc8:	c9 fb       	bnez38 $r1,10bbe <do_calibration_DQ_DQS_READ+0x36a>

                DQS_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10bca:	fa 30       	movpi45 $r1,#0x20
   10bcc:	84 03       	movi55 $r0,#0x3
   10bce:	49 ff fd e5 	jal 10798 <Write_Read_compare>
   10bd2:	6a 16 00 01 	fmfsr $r1,$fs12
   10bd6:	38 00 9a 0a 	sw $r0,[$r1+($r6<<#0x2)]

                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10bda:	8c c1       	addi45 $r6,#0x1
   10bdc:	5a 68 08 ea 	bnec $r6,#0x8,10bb0 <do_calibration_DQ_DQS_READ+0x35c>
            }
        }
    }

    // RD FALL
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10be0:	5a 78 01 8d 	bnec $r7,#0x1,10afa <do_calibration_DQ_DQS_READ+0x2a6>
        }

    }

    // select middle value of passed read DQ/DQS value
    DQ_RD_B0_result = find_center(DQ_RD_B0_table, 8);
   10be4:	80 26       	mov55 $r1,$r6
   10be6:	b0 14       	addri36.sp $r0,#0x50
   10be8:	49 ff fd af 	jal 10746 <find_center>
   10bec:	6a 04 80 09 	fmtsr $r0,$fs9
    DQ_RD_B1_result = find_center(DQ_RD_B1_table, 8);
   10bf0:	80 26       	mov55 $r1,$r6
   10bf2:	b0 1c       	addri36.sp $r0,#0x70
   10bf4:	49 ff fd a9 	jal 10746 <find_center>
   10bf8:	6a 04 00 09 	fmtsr $r0,$fs8
    DQ_RD_B2_result = find_center(DQ_RD_B2_table, 8);
   10bfc:	80 26       	mov55 $r1,$r6
   10bfe:	b0 24       	addri36.sp $r0,#0x90
   10c00:	49 ff fd a3 	jal 10746 <find_center>
   10c04:	6a 05 80 09 	fmtsr $r0,$fs11
    DQ_RD_B3_result = find_center(DQ_RD_B3_table, 8);
   10c08:	80 26       	mov55 $r1,$r6
   10c0a:	b0 2c       	addri36.sp $r0,#0xb0
   10c0c:	49 ff fd 9d 	jal 10746 <find_center>
   10c10:	6a 05 00 09 	fmtsr $r0,$fs10
    DQ_RD_FALL_B0_result = find_center(DQ_RD_FALL_B0_table, 8);
   10c14:	80 26       	mov55 $r1,$r6
   10c16:	50 0f 81 50 	addi $r0,$sp,#0x150
   10c1a:	49 ff fd 96 	jal 10746 <find_center>
   10c1e:	83 80       	mov55 $fp,$r0
    DQ_RD_FALL_B1_result = find_center(DQ_RD_FALL_B1_table, 8);
   10c20:	80 26       	mov55 $r1,$r6
   10c22:	50 0f 81 70 	addi $r0,$sp,#0x170
   10c26:	49 ff fd 90 	jal 10746 <find_center>
   10c2a:	81 00       	mov55 $r8,$r0
    DQ_RD_FALL_B2_result = find_center(DQ_RD_FALL_B2_table, 8);
   10c2c:	80 26       	mov55 $r1,$r6
   10c2e:	50 0f 81 90 	addi $r0,$sp,#0x190
   10c32:	49 ff fd 8a 	jal 10746 <find_center>
   10c36:	6a 03 80 09 	fmtsr $r0,$fs7
    DQ_RD_FALL_B3_result = find_center(DQ_RD_FALL_B3_table, 8);
   10c3a:	80 26       	mov55 $r1,$r6
   10c3c:	50 0f 81 b0 	addi $r0,$sp,#0x1b0
   10c40:	49 ff fd 83 	jal 10746 <find_center>
   10c44:	6a 03 00 09 	fmtsr $r0,$fs6

    DQS_RD_B0_result = find_center(DQS_RD_B0_table, 8);
   10c48:	80 26       	mov55 $r1,$r6
   10c4a:	b0 34       	addri36.sp $r0,#0xd0
   10c4c:	49 ff fd 7d 	jal 10746 <find_center>
   10c50:	81 80       	mov55 $r12,$r0
    DQS_RD_B1_result = find_center(DQS_RD_B1_table, 8);
   10c52:	80 26       	mov55 $r1,$r6
   10c54:	b0 3c       	addri36.sp $r0,#0xf0
   10c56:	49 ff fd 78 	jal 10746 <find_center>
   10c5a:	81 60       	mov55 $r11,$r0
    DQS_RD_B2_result = find_center(DQS_RD_B2_table, 8);
   10c5c:	80 26       	mov55 $r1,$r6
   10c5e:	50 0f 81 10 	addi $r0,$sp,#0x110
   10c62:	49 ff fd 72 	jal 10746 <find_center>
   10c66:	81 c0       	mov55 $r14,$r0
    DQS_RD_B3_result = find_center(DQS_RD_B3_table, 8);
   10c68:	80 26       	mov55 $r1,$r6
   10c6a:	50 0f 81 30 	addi $r0,$sp,#0x130
   10c6e:	49 ff fd 6c 	jal 10746 <find_center>
   10c72:	81 a0       	mov55 $r13,$r0
    DQS_RD_FALL_B0_result = find_center(DQS_RD_FALL_B0_table, 8);
   10c74:	6a 07 00 01 	fmfsr $r0,$fs14
   10c78:	80 26       	mov55 $r1,$r6
   10c7a:	49 ff fd 66 	jal 10746 <find_center>
   10c7e:	81 40       	mov55 $r10,$r0
    DQS_RD_FALL_B1_result = find_center(DQS_RD_FALL_B1_table, 8);
   10c80:	6a 07 80 01 	fmfsr $r0,$fs15
   10c84:	80 26       	mov55 $r1,$r6
   10c86:	49 ff fd 60 	jal 10746 <find_center>
   10c8a:	81 20       	mov55 $r9,$r0
    DQS_RD_FALL_B2_result = find_center(DQS_RD_FALL_B2_table, 8);
   10c8c:	6a 06 80 01 	fmfsr $r0,$fs13
   10c90:	80 26       	mov55 $r1,$r6
   10c92:	49 ff fd 5a 	jal 10746 <find_center>
   10c96:	80 e0       	mov55 $r7,$r0
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);
   10c98:	6a 06 00 01 	fmfsr $r0,$fs12
   10c9c:	80 26       	mov55 $r1,$r6
   10c9e:	49 ff fd 54 	jal 10746 <find_center>


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
   10ca2:	6a 15 80 01 	fmfsr $r1,$fs11
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQ_RD_FALL_B3_result << 24)
        | (DQ_RD_FALL_B2_result << 16) 
   10ca6:	6a 33 00 01 	fmfsr $r3,$fs6
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
   10caa:	40 20 c0 08 	slli $r2,$r1,#0x10
   10cae:	6a 15 00 01 	fmfsr $r1,$fs10
        | (DQ_RD_FALL_B0_result);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
   10cb2:	40 e7 40 08 	slli $r14,$r14,#0x10
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
   10cb6:	40 21 07 04 	or_slli $r2,$r2,$r1,#0x18
   10cba:	6a 14 80 01 	fmfsr $r1,$fs9
        | (DQ_RD_FALL_B0_result);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
   10cbe:	40 d7 37 04 	or_slli $r13,$r14,$r13,#0x18
   10cc2:	fe 8f       	or33 $r2,$r1

    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
        | (DQ_RD_B1_result << 8) 
        | (DQ_RD_B0_result);
   10cc4:	6a 14 00 01 	fmfsr $r1,$fs8
   10cc8:	40 c6 b0 04 	or $r12,$r13,$r12
   10ccc:	40 21 05 04 	or_slli $r2,$r2,$r1,#0x8
    DQS_RD_FALL_B1_result = find_center(DQS_RD_FALL_B1_table, 8);
    DQS_RD_FALL_B2_result = find_center(DQS_RD_FALL_B2_table, 8);
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
   10cd0:	46 1f 05 00 	sethi $r1,#0xf0500
   10cd4:	14 20 80 09 	swi $r2,[$r1+#0x24]
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
        | (DQ_RD_B1_result << 8) 
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10cd8:	f2 02       	lwi37.sp $r2,[+#0x8]
   10cda:	14 20 80 1b 	swi $r2,[$r1+#0x6c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQ_RD_FALL_B3_result << 24)
        | (DQ_RD_FALL_B2_result << 16) 
   10cde:	6a 23 80 01 	fmfsr $r2,$fs7

    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
        | (DQS_RD_B1_result << 8)  
        | (DQS_RD_B0_result);
   10ce2:	40 b6 2d 04 	or_slli $r11,$r12,$r11,#0x8
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQ_RD_FALL_B3_result << 24)
        | (DQ_RD_FALL_B2_result << 16) 
   10ce6:	40 21 40 08 	slli $r2,$r2,#0x10
   10cea:	40 21 0f 04 	or_slli $r2,$r2,$r3,#0x18
   10cee:	41 c1 70 04 	or $fp,$r2,$fp
        | (DQ_RD_FALL_B1_result << 8)  
        | (DQ_RD_FALL_B0_result);
   10cf2:	40 8e 21 04 	or_slli $r8,$fp,$r8,#0x8
        | (DQ_RD_B2_result << 16)
        | (DQ_RD_B1_result << 8) 
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
   10cf6:	14 80 80 4c 	swi $r8,[$r1+#0x130]
        | (DQ_RD_FALL_B2_result << 16) 
        | (DQ_RD_FALL_B1_result << 8)  
        | (DQ_RD_FALL_B0_result);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
   10cfa:	14 b0 80 09 	swi $r11,[$r1+#0x24]
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
        | (DQS_RD_B1_result << 8)  
        | (DQS_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10cfe:	f2 02       	lwi37.sp $r2,[+#0x8]
   10d00:	14 20 80 1b 	swi $r2,[$r1+#0x6c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQS_RD_FALL_B3_result << 24)
        | (DQS_RD_FALL_B2_result << 16) 
   10d04:	40 23 c0 08 	slli $r2,$r7,#0x10
   10d08:	40 01 03 04 	or_slli $r0,$r2,$r0,#0x18
   10d0c:	40 20 28 04 	or $r2,$r0,$r10
        | (DQS_RD_FALL_B1_result << 8)  
        | (DQS_RD_FALL_B0_result);
   10d10:	40 91 25 04 	or_slli $r9,$r2,$r9,#0x8
        | (DQS_RD_B2_result << 16) 
        | (DQS_RD_B1_result << 8)  
        | (DQS_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
   10d14:	14 90 80 4c 	swi $r9,[$r1+#0x130]
    //    }
    //}
    //DQS_RD_FALL_B3_result = final_center;


}
   10d18:	51 ff 82 50 	addi $sp,$sp,#0x250
   10d1c:	34 3f 80 00 	fldi $fd3,[$sp+#0x0]
   10d20:	34 4f 80 02 	fldi $fd4,[$sp+#0x8]
   10d24:	34 5f 80 04 	fldi $fd5,[$sp+#0x10]
   10d28:	34 6f 80 06 	fldi $fd6,[$sp+#0x18]
   10d2c:	34 7f 80 08 	fldi $fd7,[$sp+#0x20]
   10d30:	fc e5       	pop25 $r14,#40    ! {$r6~$r14, $fp, $gp, $lp}

00010d32 <do_calibration_DQ_DQS_WRITE>:




static void do_calibration_DQ_DQS_WRITE()
{
   10d32:	fc 60       	push25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}
   10d34:	ee d8       	addi10.sp #-296

    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10d36:	46 cf 05 00 	sethi $r12,#0xf0500
    unsigned int DQS_WR_B2_result;
    unsigned int DQS_WR_B3_result;


    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10d3a:	85 20       	movi55 $r9,#0x0
        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10d3c:	50 b6 00 78 	addi $r11,$r12,#0x78
                LOOPDELAY_10USEC(1); // wait 10us
   10d40:	46 7f 00 00 	sethi $r7,#0xf0000


    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
   10d44:	b4 1f       	lwi450 $r0,[$sp]
   10d46:	44 00 22 22 	movi $r0,#0x2222
   10d4a:	42 04 80 24 	mul $r0,$r9,$r0
   10d4e:	b6 1f       	swi450 $r0,[$sp]
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10d50:	b4 1f       	lwi450 $r0,[$sp]
   10d52:	14 06 00 1b 	swi $r0,[$r12+#0x6c]
        if (DQSDLSEL_count == 0) {
   10d56:	4e 93 00 64 	bnez $r9,10e1e <do_calibration_DQ_DQS_WRITE+0xec>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10d5a:	50 af 80 28 	addi $r10,$sp,#0x28
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
   10d5e:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d60:	14 9f 80 01 	swi $r9,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10d64:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d66:	b6 0b       	swi450 $r0,[$r11]
   10d68:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10d6a:	b4 07       	lwi450 $r0,[$r7]
   10d6c:	f0 82       	swi37.sp $r0,[+#0x8]
   10d6e:	f0 02       	lwi37.sp $r0,[+#0x8]
   10d70:	8e c1       	subi45 $r6,#0x1
   10d72:	b6 07       	swi450 $r0,[$r7]
   10d74:	ce fb       	bnez38 $r6,10d6a <do_calibration_DQ_DQS_WRITE+0x38>

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10d76:	80 06       	mov55 $r0,$r6
   10d78:	fa 30       	movpi45 $r1,#0x20
   10d7a:	49 ff fd 0f 	jal 10798 <Write_Read_compare>
   10d7e:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10d82:	8d 21       	addi45 $r9,#0x1
   10d84:	5a 98 08 ed 	bnec $r9,#0x8,10d5e <do_calibration_DQ_DQS_WRITE+0x2c>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10d88:	50 af 80 48 	addi $r10,$sp,#0x48

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
   10d8c:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d8e:	40 03 20 08 	slli $r0,$r6,#0x8
   10d92:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10d94:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d96:	b6 0b       	swi450 $r0,[$r11]
   10d98:	85 2f       	movi55 $r9,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10d9a:	b4 07       	lwi450 $r0,[$r7]
   10d9c:	f0 83       	swi37.sp $r0,[+#0xc]
   10d9e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10da0:	8f 21       	subi45 $r9,#0x1
   10da2:	b6 07       	swi450 $r0,[$r7]
   10da4:	4e 93 ff fb 	bnez $r9,10d9a <do_calibration_DQ_DQS_WRITE+0x68>

                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10da8:	84 01       	movi55 $r0,#0x1
   10daa:	fa 30       	movpi45 $r1,#0x20
   10dac:	49 ff fc f6 	jal 10798 <Write_Read_compare>
   10db0:	38 05 1a 0a 	sw $r0,[$r10+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10db4:	8c c1       	addi45 $r6,#0x1
   10db6:	5a 68 08 eb 	bnec $r6,#0x8,10d8c <do_calibration_DQ_DQS_WRITE+0x5a>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10dba:	50 af 80 68 	addi $r10,$sp,#0x68
                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
   10dbe:	f0 01       	lwi37.sp $r0,[+#0x4]
   10dc0:	40 04 c0 08 	slli $r0,$r9,#0x10
   10dc4:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10dc6:	f0 01       	lwi37.sp $r0,[+#0x4]
   10dc8:	b6 0b       	swi450 $r0,[$r11]
   10dca:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10dcc:	b4 07       	lwi450 $r0,[$r7]
   10dce:	f0 84       	swi37.sp $r0,[+#0x10]
   10dd0:	f0 04       	lwi37.sp $r0,[+#0x10]
   10dd2:	8e c1       	subi45 $r6,#0x1
   10dd4:	b6 07       	swi450 $r0,[$r7]
   10dd6:	ce fb       	bnez38 $r6,10dcc <do_calibration_DQ_DQS_WRITE+0x9a>

                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10dd8:	84 02       	movi55 $r0,#0x2
   10dda:	fa 30       	movpi45 $r1,#0x20
   10ddc:	49 ff fc de 	jal 10798 <Write_Read_compare>
   10de0:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]

                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10de4:	8d 21       	addi45 $r9,#0x1
   10de6:	5a 98 08 ec 	bnec $r9,#0x8,10dbe <do_calibration_DQ_DQS_WRITE+0x8c>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10dea:	50 9f 80 88 	addi $r9,$sp,#0x88
                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
   10dee:	f0 01       	lwi37.sp $r0,[+#0x4]
   10df0:	40 03 60 08 	slli $r0,$r6,#0x18
   10df4:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10df6:	f0 01       	lwi37.sp $r0,[+#0x4]
   10df8:	b6 0b       	swi450 $r0,[$r11]
   10dfa:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10dfc:	b4 27       	lwi450 $r1,[$r7]
   10dfe:	f1 85       	swi37.sp $r1,[+#0x14]
   10e00:	f1 05       	lwi37.sp $r1,[+#0x14]
   10e02:	8e 01       	subi45 $r0,#0x1
   10e04:	b6 27       	swi450 $r1,[$r7]
   10e06:	c8 fb       	bnez38 $r0,10dfc <do_calibration_DQ_DQS_WRITE+0xca>

                DQ_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10e08:	84 03       	movi55 $r0,#0x3
   10e0a:	fa 30       	movpi45 $r1,#0x20
   10e0c:	49 ff fc c6 	jal 10798 <Write_Read_compare>
   10e10:	38 04 9a 0a 	sw $r0,[$r9+($r6<<#0x2)]

                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10e14:	8c c1       	addi45 $r6,#0x1
   10e16:	5a 68 08 ec 	bnec $r6,#0x8,10dee <do_calibration_DQ_DQS_WRITE+0xbc>
   10e1a:	85 21       	movi55 $r9,#0x1
   10e1c:	d5 94       	j8 10d44 <do_calibration_DQ_DQS_WRITE+0x12>
   10e1e:	85 40       	movi55 $r10,#0x0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10e20:	50 df 80 a8 	addi $r13,$sp,#0xa8

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
   10e24:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e26:	14 af 80 01 	swi $r10,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e2a:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e2c:	b6 0b       	swi450 $r0,[$r11]
   10e2e:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10e30:	b4 07       	lwi450 $r0,[$r7]
   10e32:	f0 86       	swi37.sp $r0,[+#0x18]
   10e34:	f0 06       	lwi37.sp $r0,[+#0x18]
   10e36:	8e c1       	subi45 $r6,#0x1
   10e38:	b6 07       	swi450 $r0,[$r7]
   10e3a:	ce fb       	bnez38 $r6,10e30 <do_calibration_DQ_DQS_WRITE+0xfe>

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10e3c:	80 06       	mov55 $r0,$r6
   10e3e:	fa 30       	movpi45 $r1,#0x20
   10e40:	49 ff fc ac 	jal 10798 <Write_Read_compare>
   10e44:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]
            }

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10e48:	8d 41       	addi45 $r10,#0x1
   10e4a:	5a a8 08 ed 	bnec $r10,#0x8,10e24 <do_calibration_DQ_DQS_WRITE+0xf2>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10e4e:	50 df 80 c8 	addi $r13,$sp,#0xc8

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
   10e52:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e54:	40 03 20 08 	slli $r0,$r6,#0x8
   10e58:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e5a:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e5c:	b6 0b       	swi450 $r0,[$r11]
   10e5e:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10e60:	b4 07       	lwi450 $r0,[$r7]
   10e62:	f0 87       	swi37.sp $r0,[+#0x1c]
   10e64:	f0 07       	lwi37.sp $r0,[+#0x1c]
   10e66:	8f 41       	subi45 $r10,#0x1
   10e68:	b6 07       	swi450 $r0,[$r7]
   10e6a:	4e a3 ff fb 	bnez $r10,10e60 <do_calibration_DQ_DQS_WRITE+0x12e>

                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10e6e:	84 01       	movi55 $r0,#0x1
   10e70:	fa 30       	movpi45 $r1,#0x20
   10e72:	49 ff fc 93 	jal 10798 <Write_Read_compare>
   10e76:	38 06 9a 0a 	sw $r0,[$r13+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10e7a:	8c c1       	addi45 $r6,#0x1
   10e7c:	5a 68 08 eb 	bnec $r6,#0x8,10e52 <do_calibration_DQ_DQS_WRITE+0x120>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10e80:	50 df 80 e8 	addi $r13,$sp,#0xe8
                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
   10e84:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e86:	40 05 40 08 	slli $r0,$r10,#0x10
   10e8a:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e8c:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e8e:	b6 0b       	swi450 $r0,[$r11]
   10e90:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10e92:	b4 07       	lwi450 $r0,[$r7]
   10e94:	f0 88       	swi37.sp $r0,[+#0x20]
   10e96:	f0 08       	lwi37.sp $r0,[+#0x20]
   10e98:	8e c1       	subi45 $r6,#0x1
   10e9a:	b6 07       	swi450 $r0,[$r7]
   10e9c:	ce fb       	bnez38 $r6,10e92 <do_calibration_DQ_DQS_WRITE+0x160>

                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10e9e:	84 02       	movi55 $r0,#0x2
   10ea0:	fa 30       	movpi45 $r1,#0x20
   10ea2:	49 ff fc 7b 	jal 10798 <Write_Read_compare>
   10ea6:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]

                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10eaa:	8d 41       	addi45 $r10,#0x1
   10eac:	5a a8 08 ec 	bnec $r10,#0x8,10e84 <do_calibration_DQ_DQS_WRITE+0x152>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10eb0:	50 af 81 08 	addi $r10,$sp,#0x108
                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
   10eb4:	f0 01       	lwi37.sp $r0,[+#0x4]
   10eb6:	40 03 60 08 	slli $r0,$r6,#0x18
   10eba:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10ebc:	f0 01       	lwi37.sp $r0,[+#0x4]
   10ebe:	b6 0b       	swi450 $r0,[$r11]
   10ec0:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10ec2:	b4 27       	lwi450 $r1,[$r7]
   10ec4:	f1 89       	swi37.sp $r1,[+#0x24]
   10ec6:	f1 09       	lwi37.sp $r1,[+#0x24]
   10ec8:	8e 01       	subi45 $r0,#0x1
   10eca:	b6 27       	swi450 $r1,[$r7]
   10ecc:	c8 fb       	bnez38 $r0,10ec2 <do_calibration_DQ_DQS_WRITE+0x190>

                DQS_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10ece:	84 03       	movi55 $r0,#0x3
   10ed0:	fa 30       	movpi45 $r1,#0x20
   10ed2:	49 ff fc 63 	jal 10798 <Write_Read_compare>
   10ed6:	38 05 1a 0a 	sw $r0,[$r10+($r6<<#0x2)]

                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10eda:	8c c1       	addi45 $r6,#0x1
   10edc:	5a 68 08 ec 	bnec $r6,#0x8,10eb4 <do_calibration_DQ_DQS_WRITE+0x182>
    unsigned int DQS_WR_B2_result;
    unsigned int DQS_WR_B3_result;


    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10ee0:	5a 98 01 9d 	bnec $r9,#0x1,10e1a <do_calibration_DQ_DQS_WRITE+0xe8>
        }

    }

    // select middle value of passed write DQ/DQS value
    DQ_WR_B0_result = find_center(DQ_WR_B0_table, 8);
   10ee4:	80 26       	mov55 $r1,$r6
   10ee6:	b0 0a       	addri36.sp $r0,#0x28
   10ee8:	49 ff fc 2f 	jal 10746 <find_center>
   10eec:	81 80       	mov55 $r12,$r0
    DQ_WR_B1_result = find_center(DQ_WR_B1_table, 8);
   10eee:	80 26       	mov55 $r1,$r6
   10ef0:	b0 12       	addri36.sp $r0,#0x48
   10ef2:	49 ff fc 2a 	jal 10746 <find_center>
   10ef6:	81 60       	mov55 $r11,$r0
    DQ_WR_B2_result = find_center(DQ_WR_B2_table, 8);
   10ef8:	80 26       	mov55 $r1,$r6
   10efa:	b0 1a       	addri36.sp $r0,#0x68
   10efc:	49 ff fc 25 	jal 10746 <find_center>
   10f00:	81 c0       	mov55 $r14,$r0
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);
   10f02:	80 26       	mov55 $r1,$r6
   10f04:	b0 22       	addri36.sp $r0,#0x88
   10f06:	49 ff fc 20 	jal 10746 <find_center>
   10f0a:	81 a0       	mov55 $r13,$r0

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
   10f0c:	80 26       	mov55 $r1,$r6
   10f0e:	b0 2a       	addri36.sp $r0,#0xa8
   10f10:	49 ff fc 1b 	jal 10746 <find_center>
   10f14:	81 40       	mov55 $r10,$r0
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
   10f16:	80 26       	mov55 $r1,$r6
   10f18:	b0 32       	addri36.sp $r0,#0xc8
   10f1a:	49 ff fc 16 	jal 10746 <find_center>
   10f1e:	81 20       	mov55 $r9,$r0
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
   10f20:	80 26       	mov55 $r1,$r6
   10f22:	b0 3a       	addri36.sp $r0,#0xe8
   10f24:	49 ff fc 11 	jal 10746 <find_center>
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
   10f28:	40 e7 40 08 	slli $r14,$r14,#0x10
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);
   10f2c:	80 26       	mov55 $r1,$r6
    DQ_WR_B2_result = find_center(DQ_WR_B2_table, 8);
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
   10f2e:	80 e0       	mov55 $r7,$r0
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
   10f30:	40 d7 37 04 	or_slli $r13,$r14,$r13,#0x18
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);
   10f34:	50 0f 81 08 	addi $r0,$sp,#0x108
   10f38:	49 ff fc 07 	jal 10746 <find_center>
   10f3c:	40 c6 b0 04 	or $r12,$r13,$r12

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQS_WR_B3_result << 24)
        | (DQS_WR_B2_result << 16) 
   10f40:	40 73 c0 08 	slli $r7,$r7,#0x10
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
   10f44:	46 1f 05 00 	sethi $r1,#0xf0500
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
        | (DQ_WR_B1_result << 8)  
        | (DQ_WR_B0_result);
   10f48:	40 b6 2d 04 	or_slli $r11,$r12,$r11,#0x8

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQS_WR_B3_result << 24)
        | (DQS_WR_B2_result << 16) 
   10f4c:	40 03 83 04 	or_slli $r0,$r7,$r0,#0x18
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
   10f50:	14 b0 80 1e 	swi $r11,[$r1+#0x78]
   10f54:	40 70 28 04 	or $r7,$r0,$r10
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
        | (DQ_WR_B1_result << 8)  
        | (DQ_WR_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10f58:	b4 5f       	lwi450 $r2,[$sp]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQS_WR_B3_result << 24)
        | (DQS_WR_B2_result << 16) 
        | (DQS_WR_B1_result << 8)  
        | (DQS_WR_B0_result);
   10f5a:	40 93 a5 04 	or_slli $r9,$r7,$r9,#0x8
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
        | (DQ_WR_B1_result << 8)  
        | (DQ_WR_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10f5e:	14 20 80 1b 	swi $r2,[$r1+#0x6c]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
   10f62:	14 90 80 1e 	swi $r9,[$r1+#0x78]
        | (DQS_WR_B2_result << 16) 
        | (DQS_WR_B1_result << 8)  
        | (DQS_WR_B0_result);


}
   10f66:	ed 28       	addi10.sp #0x128
   10f68:	fc e0       	pop25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}

00010f6a <do_calibration_Leveling>:



#else
static void do_calibration_Leveling(int mode)  // write / read leveling
{
   10f6a:	fc 60       	push25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}
   10f6c:	51 ff fd f0 	addi $sp,$sp,#-528
   10f70:	46 1f 05 00 	sethi $r1,#0xf0500
    u32LevelCnt = 2;
#else
    u32LevelCnt = 4;
#endif

    if(mode == 0){
   10f74:	c8 62       	bnez38 $r0,11038 <do_calibration_Leveling+0xce>
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
   10f76:	04 10 80 1a 	lwi $r1,[$r1+#0x68]
   10f7a:	f1 82       	swi37.sp $r1,[+#0x8]
		for(i=0;i<u32LevelCnt;i++){
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
			u8Reg[i] = 0;
   10f7c:	80 40       	mov55 $r2,$r0
    if(mode == 0){
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
		for(i=0;i<u32LevelCnt;i++){
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
   10f7e:	f1 02       	lwi37.sp $r1,[+#0x8]
   10f80:	94 c3       	slli333 $r3,$r0,#0x3
   10f82:	40 10 8c 0d 	srl $r1,$r1,$r3
   10f86:	b0 c3       	addri36.sp $r3,#0xc
   10f88:	38 11 80 08 	sb $r1,[$r3+($r0<<#0x0)]
			u8Reg[i] = 0;
   10f8c:	b0 41       	addri36.sp $r1,#0x4
   10f8e:	38 20 80 08 	sb $r2,[$r1+($r0<<#0x0)]

    if(mode == 0){
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
		for(i=0;i<u32LevelCnt;i++){
   10f92:	8c 01       	addi45 $r0,#0x1
   10f94:	5a 08 04 f5 	bnec $r0,#0x4,10f7e <do_calibration_Leveling+0x14>
		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   10f98:	46 af 05 00 	sethi $r10,#0xf0500
   10f9c:	80 c1       	mov55 $r6,$r1

    if(mode == 0){
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
		for(i=0;i<u32LevelCnt;i++){
   10f9e:	84 e0       	movi55 $r7,#0x0
		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   10fa0:	50 a5 00 68 	addi $r10,$r10,#0x68
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   10fa4:	50 bf 80 10 	addi $r11,$sp,#0x10
			u8Reg[i] = 0;
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
   10fa8:	84 00       	movi55 $r0,#0x0
   10faa:	18 03 00 01 	sbi.bi $r0,[$r6],#0x1
			for(j=0;j<u32LevelRange;j++){
   10fae:	85 20       	movi55 $r9,#0x0
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
   10fb0:	00 1f 80 06 	lbi $r1,[$sp+#0x6]
   10fb4:	00 2f 80 07 	lbi $r2,[$sp+#0x7]
   10fb8:	40 10 c0 08 	slli $r1,$r1,#0x10
   10fbc:	40 10 8b 04 	or_slli $r1,$r1,$r2,#0x18
   10fc0:	00 2f 80 04 	lbi $r2,[$sp+#0x4]
   10fc4:	fe 57       	or33 $r1,$r2
   10fc6:	00 2f 80 05 	lbi $r2,[$sp+#0x5]
   10fca:	40 10 89 04 	or_slli $r1,$r1,$r2,#0x8
   10fce:	f1 82       	swi37.sp $r1,[+#0x8]
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   10fd0:	f0 02       	lwi37.sp $r0,[+#0x8]
   10fd2:	b6 0a       	swi450 $r0,[$r10]
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   10fd4:	fa 30       	movpi45 $r1,#0x20
   10fd6:	80 07       	mov55 $r0,$r7
   10fd8:	49 ff fb e0 	jal 10798 <Write_Read_compare>
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
   10fdc:	00 13 7f ff 	lbi $r1,[$r6+#-1]
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   10fe0:	38 05 a6 0a 	sw $r0,[$r11+($r9<<#0x2)]
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
   10fe4:	8c 21       	addi45 $r1,#0x1
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   10fe6:	8d 21       	addi45 $r9,#0x1
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
   10fe8:	10 13 7f ff 	sbi $r1,[$r6+#-1]
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   10fec:	5a 98 80 e2 	bnec $r9,#0x80,10fb0 <do_calibration_Leveling+0x46>
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
			}

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
   10ff0:	80 0b       	mov55 $r0,$r11
   10ff2:	80 29       	mov55 $r1,$r9
   10ff4:	49 ff fb a9 	jal 10746 <find_center>
   10ff8:	5a 0f ff 05 	bnec $r0,#-1,11002 <do_calibration_Leveling+0x98>
				u8Reg[i] = u8RegDefault[i];	// set to default
   10ffc:	b0 03       	addri36.sp $r0,#0xc
   10ffe:	38 00 1c 00 	lb $r0,[$r0+($r7<<#0x0)]
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
			u8Reg[i] = 0;
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   11002:	8c e1       	addi45 $r7,#0x1

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
				u8Reg[i] = u8RegDefault[i];	// set to default
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
   11004:	10 03 7f ff 	sbi $r0,[$r6+#-1]
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
			u8Reg[i] = 0;
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   11008:	5a 78 04 d0 	bnec $r7,#0x4,10fa8 <do_calibration_Leveling+0x3e>
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
			//dbg("center: %d\n", s32Center);
		}
		reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
   1100c:	00 0f 80 06 	lbi $r0,[$sp+#0x6]
   11010:	00 1f 80 07 	lbi $r1,[$sp+#0x7]
   11014:	40 00 40 08 	slli $r0,$r0,#0x10
   11018:	40 00 07 04 	or_slli $r0,$r0,$r1,#0x18
   1101c:	00 1f 80 04 	lbi $r1,[$sp+#0x4]
   11020:	fe 0f       	or33 $r0,$r1
   11022:	00 1f 80 05 	lbi $r1,[$sp+#0x5]
   11026:	40 00 05 04 	or_slli $r0,$r0,$r1,#0x8
   1102a:	f0 82       	swi37.sp $r0,[+#0x8]
		*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   1102c:	f1 02       	lwi37.sp $r1,[+#0x8]
   1102e:	46 0f 05 00 	sethi $r0,#0xf0500
   11032:	14 10 00 1a 	swi $r1,[$r0+#0x68]
   11036:	d5 6e       	j8 11112 <do_calibration_Leveling+0x1a8>
    }else{
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
   11038:	04 00 80 1d 	lwi $r0,[$r1+#0x74]
   1103c:	f0 83       	swi37.sp $r0,[+#0xc]
		for(i=0;i<u32LevelCnt;i++){
   1103e:	84 00       	movi55 $r0,#0x0
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
			u8Reg[i] = 0;
   11040:	80 40       	mov55 $r2,$r0
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
		for(i=0;i<u32LevelCnt;i++){
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
   11042:	f1 03       	lwi37.sp $r1,[+#0xc]
   11044:	94 c2       	slli333 $r3,$r0,#0x2
   11046:	40 10 8c 0d 	srl $r1,$r1,$r3
   1104a:	96 5f       	fexti33 $r1,#0x3
   1104c:	b0 c2       	addri36.sp $r3,#0x8
   1104e:	38 11 80 08 	sb $r1,[$r3+($r0<<#0x0)]
			u8Reg[i] = 0;
   11052:	b0 41       	addri36.sp $r1,#0x4
   11054:	38 20 80 08 	sb $r2,[$r1+($r0<<#0x0)]
    }else{
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
		for(i=0;i<u32LevelCnt;i++){
   11058:	8c 01       	addi45 $r0,#0x1
   1105a:	5a 08 04 f4 	bnec $r0,#0x4,11042 <do_calibration_Leveling+0xd8>
		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   1105e:	46 bf 05 00 	sethi $r11,#0xf0500

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   11062:	46 af 00 00 	sethi $r10,#0xf0000
   11066:	80 c1       	mov55 $r6,$r1
    }else{
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
		for(i=0;i<u32LevelCnt;i++){
   11068:	84 e0       	movi55 $r7,#0x0
		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   1106a:	50 b5 80 74 	addi $r11,$r11,#0x74

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   1106e:	50 a5 00 48 	addi $r10,$r10,#0x48
   11072:	44 80 3f df 	movi $r8,#0x3fdf
			u8Reg[i] = 0;
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
   11076:	84 00       	movi55 $r0,#0x0
   11078:	18 03 00 01 	sbi.bi $r0,[$r6],#0x1
			for(j=0;j<u32LevelRange;j++){
   1107c:	85 20       	movi55 $r9,#0x0
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   1107e:	44 d0 3f ff 	movi $r13,#0x3fff


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   11082:	50 cf 80 10 	addi $r12,$sp,#0x10

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
   11086:	00 1f 80 06 	lbi $r1,[$sp+#0x6]
   1108a:	00 2f 80 07 	lbi $r2,[$sp+#0x7]
   1108e:	40 10 a0 08 	slli $r1,$r1,#0x8
   11092:	40 10 89 84 	or_slli $r1,$r1,$r2,#0xc
   11096:	00 2f 80 04 	lbi $r2,[$sp+#0x4]
   1109a:	fe 57       	or33 $r1,$r2
   1109c:	00 2f 80 05 	lbi $r2,[$sp+#0x5]
   110a0:	40 10 88 84 	or_slli $r1,$r1,$r2,#0x4
   110a4:	f1 83       	swi37.sp $r1,[+#0xc]
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   110a6:	f0 03       	lwi37.sp $r0,[+#0xc]
   110a8:	b6 0b       	swi450 $r0,[$r11]

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   110aa:	fa 30       	movpi45 $r1,#0x20
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   110ac:	b7 0a       	swi450 $r8,[$r10]
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   110ae:	80 07       	mov55 $r0,$r7
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   110b0:	14 d5 00 00 	swi $r13,[$r10+#0x0]


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   110b4:	49 ff fb 72 	jal 10798 <Write_Read_compare>
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
   110b8:	00 13 7f ff 	lbi $r1,[$r6+#-1]

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   110bc:	38 06 26 0a 	sw $r0,[$r12+($r9<<#0x2)]
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
   110c0:	8c 21       	addi45 $r1,#0x1
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   110c2:	8d 21       	addi45 $r9,#0x1


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
   110c4:	10 13 7f ff 	sbi $r1,[$r6+#-1]
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   110c8:	5a 98 10 df 	bnec $r9,#0x10,11086 <do_calibration_Leveling+0x11c>
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
			}

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
   110cc:	80 0c       	mov55 $r0,$r12
   110ce:	80 29       	mov55 $r1,$r9
   110d0:	49 ff fb 3b 	jal 10746 <find_center>
   110d4:	5a 0f ff 05 	bnec $r0,#-1,110de <do_calibration_Leveling+0x174>
				u8Reg[i] = u8RegDefault[i];	// set to default
   110d8:	b0 02       	addri36.sp $r0,#0x8
   110da:	38 00 1c 00 	lb $r0,[$r0+($r7<<#0x0)]
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
			u8Reg[i] = 0;
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   110de:	8c e1       	addi45 $r7,#0x1

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
				u8Reg[i] = u8RegDefault[i];	// set to default
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
   110e0:	10 03 7f ff 	sbi $r0,[$r6+#-1]
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
			u8Reg[i] = 0;
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   110e4:	5a 78 04 c9 	bnec $r7,#0x4,11076 <do_calibration_Leveling+0x10c>
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
			//dbg("center: %d\n", s32Center);
		}
		reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
   110e8:	00 0f 80 06 	lbi $r0,[$sp+#0x6]
   110ec:	00 1f 80 07 	lbi $r1,[$sp+#0x7]
   110f0:	40 00 20 08 	slli $r0,$r0,#0x8
   110f4:	40 00 05 84 	or_slli $r0,$r0,$r1,#0xc
   110f8:	00 1f 80 04 	lbi $r1,[$sp+#0x4]
   110fc:	fe 0f       	or33 $r0,$r1
   110fe:	00 1f 80 05 	lbi $r1,[$sp+#0x5]
   11102:	40 00 04 84 	or_slli $r0,$r0,$r1,#0x4
   11106:	f0 83       	swi37.sp $r0,[+#0xc]
		*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   11108:	f1 03       	lwi37.sp $r1,[+#0xc]
   1110a:	46 0f 05 00 	sethi $r0,#0xf0500
   1110e:	14 10 00 1d 	swi $r1,[$r0+#0x74]
    }

}
   11112:	51 ff 82 10 	addi $sp,$sp,#0x210
   11116:	fc e0       	pop25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}

00011118 <ddr_calibration>:

}
#endif	//DDR_CALIB_TESET

int ddr_calibration(int opt)
{
   11118:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}

    // memory initialize
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00000) = 0x0;
   1111a:	46 12 00 00 	sethi $r1,#0x20000

}
#endif	//DDR_CALIB_TESET

int ddr_calibration(int opt)
{
   1111e:	80 c0       	mov55 $r6,$r0

    // memory initialize
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00000) = 0x0;
   11120:	84 00       	movi55 $r0,#0x0
   11122:	b6 01       	swi450 $r0,[$r1]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00004) = 0x0;
   11124:	a8 09       	swi333 $r0,[$r1+#0x4]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00008) = 0x0;
   11126:	a8 0a       	swi333 $r0,[$r1+#0x8]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x0000C) = 0x0;
   11128:	a8 0b       	swi333 $r0,[$r1+#0xc]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00010) = 0x0;
   1112a:	a8 0c       	swi333 $r0,[$r1+#0x10]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00014) = 0x0;
   1112c:	a8 0d       	swi333 $r0,[$r1+#0x14]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00018) = 0x0;
   1112e:	a8 0e       	swi333 $r0,[$r1+#0x18]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x0001C) = 0x0;
   11130:	a8 0f       	swi333 $r0,[$r1+#0x1c]


#if DDR_CALIB_TESET
    do_calib_test();
#else
    if(opt & DDR_CAL_WLEVEL)
   11132:	96 74       	xlsb33 $r1,$r6
   11134:	c1 03       	beqz38 $r1,1113a <ddr_calibration+0x22>
    	do_calibration_Leveling(0); // write leveling
   11136:	49 ff ff 1a 	jal 10f6a <do_calibration_Leveling>
    if(opt & DDR_CAL_RLEVEL)
   1113a:	54 03 00 02 	andi $r0,$r6,#0x2
   1113e:	c0 04       	beqz38 $r0,11146 <ddr_calibration+0x2e>
    	do_calibration_Leveling(1); // read leveling
   11140:	84 01       	movi55 $r0,#0x1
   11142:	49 ff ff 14 	jal 10f6a <do_calibration_Leveling>
    if(opt & DDR_CAL_GDS)
    	do_calibration_GDS(); // GDS
    if(opt & DDR_CAL_RDQDQS)
   11146:	97 9e       	bmski33 $r6,#0x3
   11148:	c6 05       	beqz38 $r6,11152 <ddr_calibration+0x3a>
    	do_calibration_DQ_DQS_READ(); // DQ/DQS
   1114a:	49 ff fb 85 	jal 10854 <do_calibration_DQ_DQS_READ>
    if(opt & DDR_CAL_WDQDQS)
    	do_calibration_DQ_DQS_WRITE(); // DQ/DQS
   1114e:	49 ff fd f2 	jal 10d32 <do_calibration_DQ_DQS_WRITE>
#endif

    // finish condition
    finish();
    return 0;
}
   11152:	84 00       	movi55 $r0,#0x0
   11154:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

00011156 <asic_init>:
#include <stdio.h>
#include "system.h"

void asic_init(void)
{
   11156:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc

#else	// #if defined(CPU_OVER_CLOCK)

#if defined(DDR_SPEED_500M)
        *(volatile unsigned int *) 0xf0000050 = 0x000002CA; // FPLL 999MHz
   11158:	46 0f 00 00 	sethi $r0,#0xf0000
   1115c:	44 10 02 ca 	movi $r1,#0x2ca
   11160:	83 80       	mov55 $fp,$r0
   11162:	b9 94       	swi37 $r1,[$fp+#0x50]
        //*(volatile unsigned int *) 0xf0000050 = 0x000002B2; // FPLL 675MHz
        //*(volatile unsigned int *) 0xf0000050 = 0x000002AC; // FPLL 594MHz
#else
#error "unkonw ddr speed"
#endif
        *(volatile unsigned int *) 0xf0000054 = 0x2A1f3210; // MPLL0 297MHz
   11164:	46 12 a1 f3 	sethi $r1,#0x2a1f3
   11168:	50 10 82 10 	addi $r1,$r1,#0x210
   1116c:	b9 95       	swi37 $r1,[$fp+#0x54]
        *(volatile unsigned int *) 0xf0000058 = 0x298f3210; // MPLL1 216MHz
   1116e:	46 12 98 f3 	sethi $r1,#0x298f3
   11172:	50 10 82 10 	addi $r1,$r1,#0x210
   11176:	b9 96       	swi37 $r1,[$fp+#0x58]
   11178:	44 20 00 96 	movi $r2,#0x96
   1117c:	80 20       	mov55 $r1,$r0
        //*(volatile unsigned int *) 0xf0000058 = 0x2e5f3210; // MPLL1 249.75MHz
        //*(volatile unsigned int *) 0xf0000058 = 0x253f3210; // MPLL1 256.5MHz
        //*(volatile unsigned int *) 0xf0000058 = 0x29df3210; // MPLL1 261MHz
        //*(volatile unsigned int *) 0xf0000058 = 0x2e7f3210; // MPLL1 263.25MHz

        LOOPDELAY_10USEC(10);
   1117e:	b4 61       	lwi450 $r3,[$r1]
   11180:	f3 81       	swi37.sp $r3,[+#0x4]
   11182:	f3 01       	lwi37.sp $r3,[+#0x4]
   11184:	8e 41       	subi45 $r2,#0x1
   11186:	46 0f 00 00 	sethi $r0,#0xf0000
   1118a:	b6 61       	swi450 $r3,[$r1]
   1118c:	ca f9       	bnez38 $r2,1117e <asic_init+0x28>

        // IP-Block Clock Setting
#if defined(DDR_SPEED_500M)
	// APB : 62.4375M(FPLL/16), DDR_axi : 249.75M(FPLL/4), CPU_axi : 124.88M(FPLL/8), CPU : 249.75M(FPLL/4)
        *(volatile unsigned int *) 0xf0000000 = 0x0A08080A; // APB, DDR_axi, CPU_axi, CPU
   1118e:	46 10 a0 80 	sethi $r1,#0xa080
   11192:	50 10 88 0a 	addi $r1,$r1,#0x80a
   11196:	b6 20       	swi450 $r1,[$r0]
        //*(volatile unsigned int *) 0xf0000000 = 0x0A08080e; // APB, DDR_axi, CPU_axi, CPU --> MPLL1
	// UART : 27M(XIN), WDT : 6.75M(TIMER), TIMER : 6.75M(XIN/4), QSPI : 142.71M(FPLL/7)
	*(volatile unsigned int *) 0xf0000004 = 0x00000000 | 0x0008090B; // UART, WDT, Timer, QSPI
   11198:	46 10 00 80 	sethi $r1,#0x80
   1119c:	50 10 89 0b 	addi $r1,$r1,#0x90b
   111a0:	a8 41       	swi333 $r1,[$r0+#0x4]
	// SVM : 124.875M(FPLL/4), GADC : 49.95M(FPLL/20)
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc
   111a2:	46 10 08 50 	sethi $r1,#0x850
#endif

#endif 	// #if defined(CPU_OVER_CLOCK)

	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
   111a6:	46 28 08 08 	sethi $r2,#0x80808
        *(volatile unsigned int *) 0xf0000000 = 0x0A08080A; // APB, DDR_axi, CPU_axi, CPU
        //*(volatile unsigned int *) 0xf0000000 = 0x0A08080e; // APB, DDR_axi, CPU_axi, CPU --> MPLL1
	// UART : 27M(XIN), WDT : 6.75M(TIMER), TIMER : 6.75M(XIN/4), QSPI : 142.71M(FPLL/7)
	*(volatile unsigned int *) 0xf0000004 = 0x00000000 | 0x0008090B; // UART, WDT, Timer, QSPI
	// SVM : 124.875M(FPLL/4), GADC : 49.95M(FPLL/20)
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc
   111aa:	50 10 80 81 	addi $r1,$r1,#0x81
	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
	// VADC : 148.5M(PVI RX)
        *(volatile unsigned int *) 0xf0000010 = 0x80808080 | 0x00000000; // Vadc3, Vadc2, Vadc1, Vadc0
	// ISP : 37.125M(mpll0/8)
        *(volatile unsigned int *) 0xf0000014 = 0x80808080 | 0x18081808; // ISP3, ISP2, ISP1, ISP0
   111ae:	46 39 88 89 	sethi $r3,#0x98889
        *(volatile unsigned int *) 0xf0000000 = 0x0A08080A; // APB, DDR_axi, CPU_axi, CPU
        //*(volatile unsigned int *) 0xf0000000 = 0x0A08080e; // APB, DDR_axi, CPU_axi, CPU --> MPLL1
	// UART : 27M(XIN), WDT : 6.75M(TIMER), TIMER : 6.75M(XIN/4), QSPI : 142.71M(FPLL/7)
	*(volatile unsigned int *) 0xf0000004 = 0x00000000 | 0x0008090B; // UART, WDT, Timer, QSPI
	// SVM : 124.875M(FPLL/4), GADC : 49.95M(FPLL/20)
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc
   111b2:	a8 42       	swi333 $r1,[$r0+#0x8]
	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
	// VADC : 148.5M(PVI RX)
        *(volatile unsigned int *) 0xf0000010 = 0x80808080 | 0x00000000; // Vadc3, Vadc2, Vadc1, Vadc0
	// ISP : 37.125M(mpll0/8)
        *(volatile unsigned int *) 0xf0000014 = 0x80808080 | 0x18081808; // ISP3, ISP2, ISP1, ISP0
   111b4:	50 31 88 88 	addi $r3,$r3,#0x888
#endif

#endif 	// #if defined(CPU_OVER_CLOCK)

	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
   111b8:	50 11 00 80 	addi $r1,$r2,#0x80
   111bc:	a8 43       	swi333 $r1,[$r0+#0xc]
	// VADC : 148.5M(PVI RX)
        *(volatile unsigned int *) 0xf0000010 = 0x80808080 | 0x00000000; // Vadc3, Vadc2, Vadc1, Vadc0
   111be:	a8 44       	swi333 $r1,[$r0+#0x10]
	// ISP : 37.125M(mpll0/8)
        *(volatile unsigned int *) 0xf0000014 = 0x80808080 | 0x18081808; // ISP3, ISP2, ISP1, ISP0
   111c0:	a8 c5       	swi333 $r3,[$r0+#0x14]
	// PVI_TxRd : 148.5M(MPLL0/2), DU : 37.125M(mpll0/8), VPU : 37.125M(mpll0/8), VIN : 37.125M(mpll0/8) 
        *(volatile unsigned int *) 0xf0000018 = 0x80808080 | 0x00020404; // PVI_TxRd, DU, VPU, Vin
   111c2:	46 38 08 28 	sethi $r3,#0x80828
   111c6:	50 31 84 84 	addi $r3,$r3,#0x484
   111ca:	a8 c6       	swi333 $r3,[$r0+#0x18]
	// PVI_TxWr : 74.25M(MPLL0/4), RECfmt : 148.5M(mpll0/2), VDAC,PVI_TxFifo : 148.5M(PVI_TxRd)
        *(volatile unsigned int *) 0xf000001C = 0x80808080 | 0x02000000; // PVI_TxWr, Recfmt, Vdac, PVI_TxFifo
   111cc:	42 30 e4 08 	bset $r3,$r1,#0x19
   111d0:	a8 c7       	swi333 $r3,[$r0+#0x1c]

	// QUAD : 37.125M(mpll0/8), RECfmt_2x : 297M(mpll0)
        *(volatile unsigned int *) 0xf0000020 = 0x80808080 | 0x02000000; // Quad, Recfmt_2x_mph_1, 2x_mph_0, Recfmt_2x
   111d2:	83 80       	mov55 $fp,$r0
   111d4:	bb 88       	swi37 $r3,[$fp+#0x20]
	// DISfmt : 74.25M(mpll0/4), Quad_2x : 74.25M(mpll0/4)
        *(volatile unsigned int *) 0xf0000024 = 0x80808080 | 0x00000202; // Disfmt_2x_mph, Rev, Disfmt, Quad_2x
   111d6:	50 31 02 82 	addi $r3,$r2,#0x282
   111da:	bb 89       	swi37 $r3,[$fp+#0x24]

	// MIPI pixel : 37.125M(mpll0/8), lane : Rxbyteclkhs/2, Rxbyteclkhs : from phy
        *(volatile unsigned int *) 0xf0000028 = 0x80808000 | 0x04000000; // MIPI_pixel, MIPI_lane, Rxbyteclkhs, Rev
   111dc:	46 38 48 08 	sethi $r3,#0x84808
   111e0:	bb 8a       	swi37 $r3,[$fp+#0x28]
        *(volatile unsigned int *) 0xf000002C = 0x80808080 | 0x00000000; // DDR_postclk_2x, postclk, ctclk, mipi_cci
   111e2:	b9 8b       	swi37 $r1,[$fp+#0x2c]
        *(volatile unsigned int *) 0xf0000030 = 0x80808000 | 0x00000000; // Parallel Video input clk1, clk0, DMCLK, TCK
        *(volatile unsigned int *) 0xf0000034 = 0x00000000 | 0x000000CC; // clock poriarity isp3210,pvirx3210
   111e4:	44 10 00 cc 	movi $r1,#0xcc
        *(volatile unsigned int *) 0xf0000024 = 0x80808080 | 0x00000202; // Disfmt_2x_mph, Rev, Disfmt, Quad_2x

	// MIPI pixel : 37.125M(mpll0/8), lane : Rxbyteclkhs/2, Rxbyteclkhs : from phy
        *(volatile unsigned int *) 0xf0000028 = 0x80808000 | 0x04000000; // MIPI_pixel, MIPI_lane, Rxbyteclkhs, Rev
        *(volatile unsigned int *) 0xf000002C = 0x80808080 | 0x00000000; // DDR_postclk_2x, postclk, ctclk, mipi_cci
        *(volatile unsigned int *) 0xf0000030 = 0x80808000 | 0x00000000; // Parallel Video input clk1, clk0, DMCLK, TCK
   111e8:	ba 8c       	swi37 $r2,[$fp+#0x30]
        *(volatile unsigned int *) 0xf0000034 = 0x00000000 | 0x000000CC; // clock poriarity isp3210,pvirx3210
   111ea:	b9 8d       	swi37 $r1,[$fp+#0x34]
   111ec:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

000111ee <clock_powerdown>:
void clock_powerdown(const unsigned int u32PowerUpBit, const unsigned int u32PowerDownBit)
{

    /* power up bit */
    {/*{{{*/
        if(u32PowerUpBit & CLK_ENNUM_QSPI)
   111ee:	96 84       	xlsb33 $r2,$r0
   111f0:	c2 07       	beqz38 $r2,111fe <clock_powerdown+0x10>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x00000080;  //Qspi 0:en, 1:dis
   111f2:	46 3f 00 00 	sethi $r3,#0xf0000
   111f6:	a0 99       	lwi333 $r2,[$r3+#0x4]
   111f8:	66 21 00 80 	bitci $r2,$r2,#0x80
   111fc:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_TIMERS)
   111fe:	54 20 00 02 	andi $r2,$r0,#0x2
   11202:	c2 07       	beqz38 $r2,11210 <clock_powerdown+0x22>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x00008000;  //timers 0:en, 1:dis
   11204:	46 3f 00 00 	sethi $r3,#0xf0000
   11208:	a0 99       	lwi333 $r2,[$r3+#0x4]
   1120a:	42 21 3c 09 	bclr $r2,$r2,#0xf
   1120e:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_WDT)
   11210:	54 20 00 04 	andi $r2,$r0,#0x4
   11214:	c2 07       	beqz38 $r2,11222 <clock_powerdown+0x34>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x00800000;  //wdt 0:en, 1:dis
   11216:	46 3f 00 00 	sethi $r3,#0xf0000
   1121a:	a0 99       	lwi333 $r2,[$r3+#0x4]
   1121c:	42 21 5c 09 	bclr $r2,$r2,#0x17
   11220:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_UART)
   11222:	54 20 00 08 	andi $r2,$r0,#0x8
   11226:	c2 07       	beqz38 $r2,11234 <clock_powerdown+0x46>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x80000000;  //uart 0:en, 1:dis
   11228:	46 3f 00 00 	sethi $r3,#0xf0000
   1122c:	a0 99       	lwi333 $r2,[$r3+#0x4]
   1122e:	42 21 7c 09 	bclr $r2,$r2,#0x1f
   11232:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_GADC)
   11234:	54 20 00 10 	andi $r2,$r0,#0x10
   11238:	c2 07       	beqz38 $r2,11246 <clock_powerdown+0x58>
        {
            *(volatile unsigned int *)0xf0000008 &= (unsigned int)~0x00000080;  //gadc 0:en, 1:dis
   1123a:	46 3f 00 00 	sethi $r3,#0xf0000
   1123e:	a0 9a       	lwi333 $r2,[$r3+#0x8]
   11240:	66 21 00 80 	bitci $r2,$r2,#0x80
   11244:	a8 9a       	swi333 $r2,[$r3+#0x8]
        }
        if(u32PowerUpBit & CLK_ENNUM_SVM)
   11246:	54 20 00 20 	andi $r2,$r0,#0x20
   1124a:	c2 07       	beqz38 $r2,11258 <clock_powerdown+0x6a>
        {
            *(volatile unsigned int *)0xf0000008 &= (unsigned int)~0x00800000;  //svm 0:en, 1:dis
   1124c:	46 3f 00 00 	sethi $r3,#0xf0000
   11250:	a0 9a       	lwi333 $r2,[$r3+#0x8]
   11252:	42 21 5c 09 	bclr $r2,$r2,#0x17
   11256:	a8 9a       	swi333 $r2,[$r3+#0x8]
        }
        if(u32PowerUpBit & CLK_ENNUM_PVIRX)
   11258:	54 20 00 40 	andi $r2,$r0,#0x40
   1125c:	c2 0d       	beqz38 $r2,11276 <clock_powerdown+0x88>
        {
            *(volatile unsigned int *)0xf000000C &= (unsigned int)~0x80808080;  //pvirx 0:en, 1:dis
   1125e:	46 3f 00 00 	sethi $r3,#0xf0000
   11262:	a1 1b       	lwi333 $r4,[$r3+#0xc]
   11264:	46 27 f7 f7 	sethi $r2,#0x7f7f7
   11268:	50 21 0f 7f 	addi $r2,$r2,#0xf7f
   1126c:	ff 16       	and33 $r4,$r2
   1126e:	a9 1b       	swi333 $r4,[$r3+#0xc]
            *(volatile unsigned int *)0xf0000010 &= (unsigned int)~0x80808080;  //vadc 0:en, 1:dis
   11270:	a1 1c       	lwi333 $r4,[$r3+#0x10]
   11272:	fe a6       	and33 $r2,$r4
   11274:	a8 9c       	swi333 $r2,[$r3+#0x10]
        }
        if(u32PowerUpBit & CLK_ENNUM_ISP)
   11276:	54 20 00 80 	andi $r2,$r0,#0x80
   1127a:	c2 0a       	beqz38 $r2,1128e <clock_powerdown+0xa0>
        {
            *(volatile unsigned int *)0xf0000014 &= (unsigned int)~0x80808080;  //isp 0:en, 1:dis
   1127c:	46 3f 00 00 	sethi $r3,#0xf0000
   11280:	a1 1d       	lwi333 $r4,[$r3+#0x14]
   11282:	46 27 f7 f7 	sethi $r2,#0x7f7f7
   11286:	50 21 0f 7f 	addi $r2,$r2,#0xf7f
   1128a:	fe a6       	and33 $r2,$r4
   1128c:	a8 9d       	swi333 $r2,[$r3+#0x14]
        }
        if(u32PowerUpBit & CLK_ENNUM_VIN)
   1128e:	54 20 01 00 	andi $r2,$r0,#0x100
   11292:	c2 07       	beqz38 $r2,112a0 <clock_powerdown+0xb2>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x00000080;  //vin 0:en, 1:dis
   11294:	46 3f 00 00 	sethi $r3,#0xf0000
   11298:	a0 9e       	lwi333 $r2,[$r3+#0x18]
   1129a:	66 21 00 80 	bitci $r2,$r2,#0x80
   1129e:	a8 9e       	swi333 $r2,[$r3+#0x18]
        }
        if(u32PowerUpBit & CLK_ENNUM_VPU)
   112a0:	54 20 02 00 	andi $r2,$r0,#0x200
   112a4:	c2 07       	beqz38 $r2,112b2 <clock_powerdown+0xc4>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x00008000;  //vpu 0:en, 1:dis
   112a6:	46 3f 00 00 	sethi $r3,#0xf0000
   112aa:	a0 9e       	lwi333 $r2,[$r3+#0x18]
   112ac:	42 21 3c 09 	bclr $r2,$r2,#0xf
   112b0:	a8 9e       	swi333 $r2,[$r3+#0x18]
        }
        if(u32PowerUpBit & CLK_ENNUM_DU)
   112b2:	54 20 04 00 	andi $r2,$r0,#0x400
   112b6:	c2 07       	beqz38 $r2,112c4 <clock_powerdown+0xd6>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x00800000;  //du 0:en, 1:dis
   112b8:	46 3f 00 00 	sethi $r3,#0xf0000
   112bc:	a0 9e       	lwi333 $r2,[$r3+#0x18]
   112be:	42 21 5c 09 	bclr $r2,$r2,#0x17
   112c2:	a8 9e       	swi333 $r2,[$r3+#0x18]
        }
        if(u32PowerUpBit & CLK_ENNUM_PVITX)
   112c4:	54 20 08 00 	andi $r2,$r0,#0x800
   112c8:	c2 13       	beqz38 $r2,112ee <clock_powerdown+0x100>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x80000000;  //pvitx rd 0:en, 1:dis
   112ca:	46 2f 00 00 	sethi $r2,#0xf0000
   112ce:	a0 d6       	lwi333 $r3,[$r2+#0x18]
   112d0:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   112d4:	a8 d6       	swi333 $r3,[$r2+#0x18]
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x80000000;  //pvitx wr 0:en, 1:dis
   112d6:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112d8:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   112dc:	a8 d7       	swi333 $r3,[$r2+#0x1c]
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x00000080;  //pvitx fifo 0:en, 1:dis
   112de:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112e0:	66 31 80 80 	bitci $r3,$r3,#0x80
   112e4:	a8 d7       	swi333 $r3,[$r2+#0x1c]
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x00008000;  //pvitx vdac 0:en, 1:dis
   112e6:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112e8:	42 31 bc 09 	bclr $r3,$r3,#0xf
   112ec:	a8 d7       	swi333 $r3,[$r2+#0x1c]
        }
        if(u32PowerUpBit & CLK_ENNUM_RO)
   112ee:	54 20 10 00 	andi $r2,$r0,#0x1000
   112f2:	c2 15       	beqz38 $r2,1131c <clock_powerdown+0x12e>
        {
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x00800000;  //recfmt 0:en, 1:dis
   112f4:	46 2f 00 00 	sethi $r2,#0xf0000
   112f8:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112fa:	42 31 dc 09 	bclr $r3,$r3,#0x17
   112fe:	a8 d7       	swi333 $r3,[$r2+#0x1c]
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x00000080;  //recfmt_2x_clock 0:en, 1:dis
   11300:	50 41 00 20 	addi $r4,$r2,#0x20
   11304:	b4 64       	lwi450 $r3,[$r4]
   11306:	66 31 80 80 	bitci $r3,$r3,#0x80
   1130a:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x00008000;  //recfmt_2x_mph0 0:en, 1:dis
   1130c:	b4 64       	lwi450 $r3,[$r4]
   1130e:	42 31 bc 09 	bclr $r3,$r3,#0xf
   11312:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x00800000;  //recfmt_2x_mph1 0:en, 1:dis
   11314:	b4 64       	lwi450 $r3,[$r4]
   11316:	42 31 dc 09 	bclr $r3,$r3,#0x17
   1131a:	b6 64       	swi450 $r3,[$r4]
        }
        if(u32PowerUpBit & CLK_ENNUM_QUAD)
   1131c:	54 20 20 00 	andi $r2,$r0,#0x2000
   11320:	c2 0d       	beqz38 $r2,1133a <clock_powerdown+0x14c>
        {
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x80000000;  //quad 0:en, 1:dis
   11322:	46 2f 00 00 	sethi $r2,#0xf0000
   11326:	50 41 00 20 	addi $r4,$r2,#0x20
   1132a:	b4 64       	lwi450 $r3,[$r4]
   1132c:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   11330:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000024 &= (unsigned int)~0x00000080;  //quad_2x 0:en, 1:dis
   11332:	a0 e1       	lwi333 $r3,[$r4+#0x4]
   11334:	66 31 80 80 	bitci $r3,$r3,#0x80
   11338:	a8 e1       	swi333 $r3,[$r4+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_DOUT)
   1133a:	54 20 40 00 	andi $r2,$r0,#0x4000
   1133e:	c2 0d       	beqz38 $r2,11358 <clock_powerdown+0x16a>
        {
            *(volatile unsigned int *)0xf0000024 &= (unsigned int)~0x00008000;  //disfmt 0:en, 1:dis
   11340:	46 2f 00 00 	sethi $r2,#0xf0000
   11344:	50 41 00 24 	addi $r4,$r2,#0x24
   11348:	b4 64       	lwi450 $r3,[$r4]
   1134a:	42 31 bc 09 	bclr $r3,$r3,#0xf
   1134e:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000024 &= (unsigned int)~0x80000000;  //disfmt_2x 0:en, 1:dis
   11350:	b4 64       	lwi450 $r3,[$r4]
   11352:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   11356:	b6 64       	swi450 $r3,[$r4]
        }
        if(u32PowerUpBit & CLK_ENNUM_MIPI)
   11358:	42 20 3c 0b 	btst $r2,$r0,#0xf
   1135c:	c2 15       	beqz38 $r2,11386 <clock_powerdown+0x198>
        {
            *(volatile unsigned int *)0xf0000028 &= (unsigned int)~0x00008000;  //rxbyteclkhs 0:en, 1:dis
   1135e:	46 2f 00 00 	sethi $r2,#0xf0000
   11362:	50 41 00 28 	addi $r4,$r2,#0x28
   11366:	b4 64       	lwi450 $r3,[$r4]
   11368:	42 31 bc 09 	bclr $r3,$r3,#0xf
   1136c:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000028 &= (unsigned int)~0x00800000;  //mipi_lane 0:en, 1:dis
   1136e:	b4 64       	lwi450 $r3,[$r4]
   11370:	42 31 dc 09 	bclr $r3,$r3,#0x17
   11374:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000028 &= (unsigned int)~0x80000000;  //mipi_pixel 0:en, 1:dis
   11376:	b4 64       	lwi450 $r3,[$r4]
   11378:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   1137c:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf000002C &= (unsigned int)~0x00000080;  //mipi cci 0:en, 1:dis
   1137e:	a0 e1       	lwi333 $r3,[$r4+#0x4]
   11380:	66 31 80 80 	bitci $r3,$r3,#0x80
   11384:	a8 e1       	swi333 $r3,[$r4+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_DDR)
   11386:	42 20 40 0b 	btst $r2,$r0,#0x10
   1138a:	c2 0c       	beqz38 $r2,113a2 <clock_powerdown+0x1b4>
        {
            *(volatile unsigned int *)0xf000002C &= (unsigned int)~0x80808000;  //ddr 0:en, 1:dis
   1138c:	46 3f 00 00 	sethi $r3,#0xf0000
   11390:	04 41 80 0b 	lwi $r4,[$r3+#0x2c]
   11394:	46 27 f7 f7 	sethi $r2,#0x7f7f7
   11398:	50 21 0f ff 	addi $r2,$r2,#0xfff
   1139c:	fe a6       	and33 $r2,$r4
   1139e:	14 21 80 0b 	swi $r2,[$r3+#0x2c]
        }
        if(u32PowerUpBit & CLK_ENNUM_JTAG)
   113a2:	42 20 44 0b 	btst $r2,$r0,#0x11
   113a6:	c2 09       	beqz38 $r2,113b8 <clock_powerdown+0x1ca>
        {
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x00000080;  //jtag 0:en, 1:dis
   113a8:	46 3f 00 00 	sethi $r3,#0xf0000
   113ac:	04 21 80 0c 	lwi $r2,[$r3+#0x30]
   113b0:	66 21 00 80 	bitci $r2,$r2,#0x80
   113b4:	14 21 80 0c 	swi $r2,[$r3+#0x30]
        }
        if(u32PowerUpBit & CLK_ENNUM_I2S)
   113b8:	42 20 48 0b 	btst $r2,$r0,#0x12
   113bc:	c2 09       	beqz38 $r2,113ce <clock_powerdown+0x1e0>
        {
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x00008000;  //i2S 0:en, 1:dis
   113be:	46 3f 00 00 	sethi $r3,#0xf0000
   113c2:	04 21 80 0c 	lwi $r2,[$r3+#0x30]
   113c6:	42 21 3c 09 	bclr $r2,$r2,#0xf
   113ca:	14 21 80 0c 	swi $r2,[$r3+#0x30]
        }
        if(u32PowerUpBit & CLK_ENNUM_PARAVIN)
   113ce:	42 00 4c 0b 	btst $r0,$r0,#0x13
   113d2:	c0 0d       	beqz38 $r0,113ec <clock_powerdown+0x1fe>
        {
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x00800000;  //par0 0:en, 1:dis
   113d4:	46 0f 00 00 	sethi $r0,#0xf0000
   113d8:	50 30 00 30 	addi $r3,$r0,#0x30
   113dc:	b4 43       	lwi450 $r2,[$r3]
   113de:	42 21 5c 09 	bclr $r2,$r2,#0x17
   113e2:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x80000000;  //par1 0:en, 1:dis
   113e4:	b4 43       	lwi450 $r2,[$r3]
   113e6:	42 21 7c 09 	bclr $r2,$r2,#0x1f
   113ea:	b6 43       	swi450 $r2,[$r3]
        }
    }/*}}}*/
    /* power down bit */
    {/*{{{*/
        if(u32PowerDownBit & CLK_ENNUM_QSPI)
   113ec:	96 0c       	xlsb33 $r0,$r1
   113ee:	c0 07       	beqz38 $r0,113fc <clock_powerdown+0x20e>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x00000080;  //Qspi 0:en, 1:dis
   113f0:	46 2f 00 00 	sethi $r2,#0xf0000
   113f4:	a0 11       	lwi333 $r0,[$r2+#0x4]
   113f6:	58 00 00 80 	ori $r0,$r0,#0x80
   113fa:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_TIMERS)
   113fc:	54 00 80 02 	andi $r0,$r1,#0x2
   11400:	c0 07       	beqz38 $r0,1140e <clock_powerdown+0x220>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x00008000;  //timers 0:en, 1:dis
   11402:	46 2f 00 00 	sethi $r2,#0xf0000
   11406:	a0 11       	lwi333 $r0,[$r2+#0x4]
   11408:	42 00 3c 08 	bset $r0,$r0,#0xf
   1140c:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_WDT)
   1140e:	54 00 80 04 	andi $r0,$r1,#0x4
   11412:	c0 07       	beqz38 $r0,11420 <clock_powerdown+0x232>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x00800000;  //wdt 0:en, 1:dis
   11414:	46 2f 00 00 	sethi $r2,#0xf0000
   11418:	a0 11       	lwi333 $r0,[$r2+#0x4]
   1141a:	42 00 5c 08 	bset $r0,$r0,#0x17
   1141e:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_UART)
   11420:	54 00 80 08 	andi $r0,$r1,#0x8
   11424:	c0 07       	beqz38 $r0,11432 <clock_powerdown+0x244>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x80000000;  //uart 0:en, 1:dis
   11426:	46 2f 00 00 	sethi $r2,#0xf0000
   1142a:	a0 11       	lwi333 $r0,[$r2+#0x4]
   1142c:	42 00 7c 08 	bset $r0,$r0,#0x1f
   11430:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_GADC)
   11432:	54 00 80 10 	andi $r0,$r1,#0x10
   11436:	c0 07       	beqz38 $r0,11444 <clock_powerdown+0x256>
        {
            *(volatile unsigned int *)0xf0000008 |= (unsigned int)0x00000080;  //gadc 0:en, 1:dis
   11438:	46 2f 00 00 	sethi $r2,#0xf0000
   1143c:	a0 12       	lwi333 $r0,[$r2+#0x8]
   1143e:	58 00 00 80 	ori $r0,$r0,#0x80
   11442:	a8 12       	swi333 $r0,[$r2+#0x8]
        }
        if(u32PowerDownBit & CLK_ENNUM_SVM)
   11444:	54 00 80 20 	andi $r0,$r1,#0x20
   11448:	c0 07       	beqz38 $r0,11456 <clock_powerdown+0x268>
        {
            *(volatile unsigned int *)0xf0000008 |= (unsigned int)0x00800000;  //svm 0:en, 1:dis
   1144a:	46 2f 00 00 	sethi $r2,#0xf0000
   1144e:	a0 12       	lwi333 $r0,[$r2+#0x8]
   11450:	42 00 5c 08 	bset $r0,$r0,#0x17
   11454:	a8 12       	swi333 $r0,[$r2+#0x8]
        }
        if(u32PowerDownBit & CLK_ENNUM_PVIRX)
   11456:	54 00 80 40 	andi $r0,$r1,#0x40
   1145a:	c0 0d       	beqz38 $r0,11474 <clock_powerdown+0x286>
        {
            *(volatile unsigned int *)0xf000000C |= (unsigned int)0x80808080;  //pvirx 0:en, 1:dis
   1145c:	46 2f 00 00 	sethi $r2,#0xf0000
   11460:	a0 d3       	lwi333 $r3,[$r2+#0xc]
   11462:	46 08 08 08 	sethi $r0,#0x80808
   11466:	58 00 00 80 	ori $r0,$r0,#0x80
   1146a:	fe c7       	or33 $r3,$r0
   1146c:	a8 d3       	swi333 $r3,[$r2+#0xc]
            *(volatile unsigned int *)0xf0000010 |= (unsigned int)0x80808080;  //vadc 0:en, 1:dis
   1146e:	a0 d4       	lwi333 $r3,[$r2+#0x10]
   11470:	fe 1f       	or33 $r0,$r3
   11472:	a8 14       	swi333 $r0,[$r2+#0x10]
        }
        if(u32PowerDownBit & CLK_ENNUM_ISP)
   11474:	54 00 80 80 	andi $r0,$r1,#0x80
   11478:	c0 0a       	beqz38 $r0,1148c <clock_powerdown+0x29e>
        {
            *(volatile unsigned int *)0xf0000014 |= (unsigned int)0x80808080;  //isp 0:en, 1:dis
   1147a:	46 2f 00 00 	sethi $r2,#0xf0000
   1147e:	a0 d5       	lwi333 $r3,[$r2+#0x14]
   11480:	46 08 08 08 	sethi $r0,#0x80808
   11484:	58 00 00 80 	ori $r0,$r0,#0x80
   11488:	fe 1f       	or33 $r0,$r3
   1148a:	a8 15       	swi333 $r0,[$r2+#0x14]
        }
        if(u32PowerDownBit & CLK_ENNUM_VIN)
   1148c:	54 00 81 00 	andi $r0,$r1,#0x100
   11490:	c0 07       	beqz38 $r0,1149e <clock_powerdown+0x2b0>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x00000080;  //vin 0:en, 1:dis
   11492:	46 2f 00 00 	sethi $r2,#0xf0000
   11496:	a0 16       	lwi333 $r0,[$r2+#0x18]
   11498:	58 00 00 80 	ori $r0,$r0,#0x80
   1149c:	a8 16       	swi333 $r0,[$r2+#0x18]
        }
        if(u32PowerDownBit & CLK_ENNUM_VPU)
   1149e:	54 00 82 00 	andi $r0,$r1,#0x200
   114a2:	c0 07       	beqz38 $r0,114b0 <clock_powerdown+0x2c2>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x00008000;  //vpu 0:en, 1:dis
   114a4:	46 2f 00 00 	sethi $r2,#0xf0000
   114a8:	a0 16       	lwi333 $r0,[$r2+#0x18]
   114aa:	42 00 3c 08 	bset $r0,$r0,#0xf
   114ae:	a8 16       	swi333 $r0,[$r2+#0x18]
        }
        if(u32PowerDownBit & CLK_ENNUM_DU)
   114b0:	54 00 84 00 	andi $r0,$r1,#0x400
   114b4:	c0 07       	beqz38 $r0,114c2 <clock_powerdown+0x2d4>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x00800000;  //du 0:en, 1:dis
   114b6:	46 2f 00 00 	sethi $r2,#0xf0000
   114ba:	a0 16       	lwi333 $r0,[$r2+#0x18]
   114bc:	42 00 5c 08 	bset $r0,$r0,#0x17
   114c0:	a8 16       	swi333 $r0,[$r2+#0x18]
        }
        if(u32PowerDownBit & CLK_ENNUM_PVITX)
   114c2:	54 00 88 00 	andi $r0,$r1,#0x800
   114c6:	c0 13       	beqz38 $r0,114ec <clock_powerdown+0x2fe>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x80000000;  //pvitx rd 0:en, 1:dis
   114c8:	46 0f 00 00 	sethi $r0,#0xf0000
   114cc:	a0 86       	lwi333 $r2,[$r0+#0x18]
   114ce:	42 21 7c 08 	bset $r2,$r2,#0x1f
   114d2:	a8 86       	swi333 $r2,[$r0+#0x18]
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x80000000;  //pvitx wr 0:en, 1:dis
   114d4:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114d6:	42 21 7c 08 	bset $r2,$r2,#0x1f
   114da:	a8 87       	swi333 $r2,[$r0+#0x1c]
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x00000080;  //pvitx fifo 0:en, 1:dis
   114dc:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114de:	58 21 00 80 	ori $r2,$r2,#0x80
   114e2:	a8 87       	swi333 $r2,[$r0+#0x1c]
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x00008000;  //pvitx vdac 0:en, 1:dis
   114e4:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114e6:	42 21 3c 08 	bset $r2,$r2,#0xf
   114ea:	a8 87       	swi333 $r2,[$r0+#0x1c]
        }
        if(u32PowerDownBit & CLK_ENNUM_RO)
   114ec:	54 00 90 00 	andi $r0,$r1,#0x1000
   114f0:	c0 15       	beqz38 $r0,1151a <clock_powerdown+0x32c>
        {
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x00800000;  //recfmt 0:en, 1:dis
   114f2:	46 0f 00 00 	sethi $r0,#0xf0000
   114f6:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114f8:	42 21 5c 08 	bset $r2,$r2,#0x17
   114fc:	a8 87       	swi333 $r2,[$r0+#0x1c]
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x00000080;  //recfmt_2x_clock 0:en, 1:dis
   114fe:	50 30 00 20 	addi $r3,$r0,#0x20
   11502:	b4 43       	lwi450 $r2,[$r3]
   11504:	58 21 00 80 	ori $r2,$r2,#0x80
   11508:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x00008000;  //recfmt_2x_mph0 0:en, 1:dis
   1150a:	b4 43       	lwi450 $r2,[$r3]
   1150c:	42 21 3c 08 	bset $r2,$r2,#0xf
   11510:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x00800000;  //recfmt_2x_mph1 0:en, 1:dis
   11512:	b4 43       	lwi450 $r2,[$r3]
   11514:	42 21 5c 08 	bset $r2,$r2,#0x17
   11518:	b6 43       	swi450 $r2,[$r3]
        }
        if(u32PowerDownBit & CLK_ENNUM_QUAD)
   1151a:	54 00 a0 00 	andi $r0,$r1,#0x2000
   1151e:	c0 0d       	beqz38 $r0,11538 <clock_powerdown+0x34a>
        {
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x80000000;  //quad 0:en, 1:dis
   11520:	46 0f 00 00 	sethi $r0,#0xf0000
   11524:	50 30 00 20 	addi $r3,$r0,#0x20
   11528:	b4 43       	lwi450 $r2,[$r3]
   1152a:	42 21 7c 08 	bset $r2,$r2,#0x1f
   1152e:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000024 |= (unsigned int)0x00000080;  //quad_2x 0:en, 1:dis
   11530:	a0 99       	lwi333 $r2,[$r3+#0x4]
   11532:	58 21 00 80 	ori $r2,$r2,#0x80
   11536:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_DOUT)
   11538:	54 00 c0 00 	andi $r0,$r1,#0x4000
   1153c:	c0 0d       	beqz38 $r0,11556 <clock_powerdown+0x368>
        {
            *(volatile unsigned int *)0xf0000024 |= (unsigned int)0x00008000;  //disfmt 0:en, 1:dis
   1153e:	46 0f 00 00 	sethi $r0,#0xf0000
   11542:	50 30 00 24 	addi $r3,$r0,#0x24
   11546:	b4 43       	lwi450 $r2,[$r3]
   11548:	42 21 3c 08 	bset $r2,$r2,#0xf
   1154c:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000024 |= (unsigned int)0x80000000;  //disfmt_2x 0:en, 1:dis
   1154e:	b4 43       	lwi450 $r2,[$r3]
   11550:	42 21 7c 08 	bset $r2,$r2,#0x1f
   11554:	b6 43       	swi450 $r2,[$r3]
        }
        if(u32PowerDownBit & CLK_ENNUM_MIPI)
   11556:	42 00 bc 0b 	btst $r0,$r1,#0xf
   1155a:	c0 15       	beqz38 $r0,11584 <clock_powerdown+0x396>
        {
            *(volatile unsigned int *)0xf0000028 |= (unsigned int)0x00008000;  //rxbyteclkhs 0:en, 1:dis
   1155c:	46 0f 00 00 	sethi $r0,#0xf0000
   11560:	50 30 00 28 	addi $r3,$r0,#0x28
   11564:	b4 43       	lwi450 $r2,[$r3]
   11566:	42 21 3c 08 	bset $r2,$r2,#0xf
   1156a:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000028 |= (unsigned int)0x00800000;  //mipi_lane 0:en, 1:dis
   1156c:	b4 43       	lwi450 $r2,[$r3]
   1156e:	42 21 5c 08 	bset $r2,$r2,#0x17
   11572:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000028 |= (unsigned int)0x80000000;  //mipi_pixel 0:en, 1:dis
   11574:	b4 43       	lwi450 $r2,[$r3]
   11576:	42 21 7c 08 	bset $r2,$r2,#0x1f
   1157a:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf000002C |= (unsigned int)0x00000080;  //mipi cci 0:en, 1:dis
   1157c:	a0 99       	lwi333 $r2,[$r3+#0x4]
   1157e:	58 21 00 80 	ori $r2,$r2,#0x80
   11582:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_DDR)
   11584:	42 00 c0 0b 	btst $r0,$r1,#0x10
   11588:	c0 0a       	beqz38 $r0,1159c <clock_powerdown+0x3ae>
        {
            *(volatile unsigned int *)0xf000002C |= (unsigned int)0x80808000;  //ddr 0:en, 1:dis
   1158a:	46 2f 00 00 	sethi $r2,#0xf0000
   1158e:	04 31 00 0b 	lwi $r3,[$r2+#0x2c]
   11592:	46 08 08 08 	sethi $r0,#0x80808
   11596:	fe 1f       	or33 $r0,$r3
   11598:	14 01 00 0b 	swi $r0,[$r2+#0x2c]
        }
        if(u32PowerDownBit & CLK_ENNUM_JTAG)
   1159c:	42 00 c4 0b 	btst $r0,$r1,#0x11
   115a0:	c0 09       	beqz38 $r0,115b2 <clock_powerdown+0x3c4>
        {
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x00000080;  //jtag 0:en, 1:dis
   115a2:	46 2f 00 00 	sethi $r2,#0xf0000
   115a6:	04 01 00 0c 	lwi $r0,[$r2+#0x30]
   115aa:	58 00 00 80 	ori $r0,$r0,#0x80
   115ae:	14 01 00 0c 	swi $r0,[$r2+#0x30]
        }
        if(u32PowerDownBit & CLK_ENNUM_I2S)
   115b2:	42 00 c8 0b 	btst $r0,$r1,#0x12
   115b6:	c0 09       	beqz38 $r0,115c8 <clock_powerdown+0x3da>
        {
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x00008000;  //i2S 0:en, 1:dis
   115b8:	46 2f 00 00 	sethi $r2,#0xf0000
   115bc:	04 01 00 0c 	lwi $r0,[$r2+#0x30]
   115c0:	42 00 3c 08 	bset $r0,$r0,#0xf
   115c4:	14 01 00 0c 	swi $r0,[$r2+#0x30]
        }
        if(u32PowerDownBit & CLK_ENNUM_PARAVIN)
   115c8:	42 10 cc 0b 	btst $r1,$r1,#0x13
   115cc:	c1 0d       	beqz38 $r1,115e6 <clock_powerdown+0x3f8>
        {
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x00800000;  //par0 0:en, 1:dis
   115ce:	46 0f 00 00 	sethi $r0,#0xf0000
   115d2:	50 20 00 30 	addi $r2,$r0,#0x30
   115d6:	b4 22       	lwi450 $r1,[$r2]
   115d8:	42 10 dc 08 	bset $r1,$r1,#0x17
   115dc:	b6 22       	swi450 $r1,[$r2]
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x80000000;  //par1 0:en, 1:dis
   115de:	b4 22       	lwi450 $r1,[$r2]
   115e0:	42 10 fc 08 	bset $r1,$r1,#0x1f
   115e4:	b6 22       	swi450 $r1,[$r2]
   115e6:	dd 9e       	ret5 $lp

000115e8 <SetClockPD>:

    return;
}

void SetClockPD(void)
{
   115e8:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
        //CLK_ENNUM_PARAVIN       |
        0;

    u32PowerDownBit = u32PowerAllBit & (unsigned int)~u32PowerUpBit;

    clock_powerdown(u32PowerUpBit, u32PowerDownBit);
   115ea:	46 10 00 cf 	sethi $r1,#0xcf
   115ee:	44 03 00 0f 	movi $r0,#0x3000f
   115f2:	50 10 8f f0 	addi $r1,$r1,#0xff0
   115f6:	49 ff fd fc 	jal 111ee <clock_powerdown>
   115fa:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000115fc <spi_nor_flash_boot>:
#include "common.h"

#define BOOT_RESULT_ADDR			0x13ff0

uint32 spi_nor_flash_boot(void)
{
   115fc:	fc 40       	push25 $r10,#0    ! {$r6~$r10, $fp, $gp, $lp}
   115fe:	ee e0       	addi10.sp #-288
	uint8 u8SectValid = 1;
	//====================================
	// set spi flash quad
	//====================================

	flash_init(PCLK/2, SPI_MODE, 1);
   11600:	46 00 1d c5 	sethi $r0,#0x1dc5
   11604:	84 20       	movi55 $r1,#0x0
   11606:	50 00 0c 3e 	addi $r0,$r0,#0xc3e
   1160a:	84 41       	movi55 $r2,#0x1
   1160c:	49 00 03 e1 	jal 11dce <flash_init>
	fr_info.flash_type = SPI_FLASH_TYPE_NOR;	// nor flash
	fr_info.dummy_size = SPI_MEMCTRL_DUMMY_SIZE_16;
	fr_info.mode_size = SPI_MEMCTRL_MODE_SIZE_8;
	fr_info.mode_out_state = SPI_MEMCTRL_MODE_STATE_VAL;
	fr_info.mode_value = 0;
	fr_info.read_type = SPI_MEMCTRL_READ_QUAD_IO;
   11610:	46 30 c0 00 	sethi $r3,#0xc000

	if(gstFlashID.u8AddrMode4Byte){
   11614:	2e 00 02 8f 	lbi.gp $r0,[+#0x28f]
	fr_info.flash_type = SPI_FLASH_TYPE_NOR;	// nor flash
	fr_info.dummy_size = SPI_MEMCTRL_DUMMY_SIZE_16;
	fr_info.mode_size = SPI_MEMCTRL_MODE_SIZE_8;
	fr_info.mode_out_state = SPI_MEMCTRL_MODE_STATE_VAL;
	fr_info.mode_value = 0;
	fr_info.read_type = SPI_MEMCTRL_READ_QUAD_IO;
   11618:	58 31 a8 10 	ori $r3,$r3,#0x2810
   1161c:	f3 81       	swi37.sp $r3,[+#0x4]
   1161e:	84 23       	movi55 $r1,#0x3

	if(gstFlashID.u8AddrMode4Byte){
   11620:	c0 08       	beqz38 $r0,11630 <spi_nor_flash_boot+0x34>
		fr_info.addr_4byte = 1;
   11622:	42 31 f0 08 	bset $r3,$r3,#0x1c
   11626:	f3 81       	swi37.sp $r3,[+#0x4]
		spi_memctrl_set(QSPI_DIV, QSPI_DELAY, 0xEC, fr_info);
   11628:	84 00       	movi55 $r0,#0x0
   1162a:	44 20 00 ec 	movi $r2,#0xec
   1162e:	d5 03       	j8 11634 <spi_nor_flash_boot+0x38>
	}else{
		fr_info.addr_4byte = 0;
		spi_memctrl_set(QSPI_DIV, QSPI_DELAY, 0xEB, fr_info);
   11630:	44 20 00 eb 	movi $r2,#0xeb
   11634:	49 00 02 c5 	jal 11bbe <spi_memctrl_set>
	}

	spi_memctrl_mode_set(SPI_MEMC_MEMORY_MAP_MODE, 0);
	// read flash header
	memcpy(&stFHdr, (uint8 *)(SPI_MEM_BASE_ADDR), sizeof(PP_FLASH_HDR_S));
   11638:	46 71 00 00 	sethi $r7,#0x10000
	}else{
		fr_info.addr_4byte = 0;
		spi_memctrl_set(QSPI_DIV, QSPI_DELAY, 0xEB, fr_info);
	}

	spi_memctrl_mode_set(SPI_MEMC_MEMORY_MAP_MODE, 0);
   1163c:	84 20       	movi55 $r1,#0x0
   1163e:	84 01       	movi55 $r0,#0x1
   11640:	49 00 02 d8 	jal 11bf0 <spi_memctrl_mode_set>
	// read flash header
	memcpy(&stFHdr, (uint8 *)(SPI_MEM_BASE_ADDR), sizeof(PP_FLASH_HDR_S));
   11644:	b0 03       	addri36.sp $r0,#0xc
   11646:	80 27       	mov55 $r1,$r7
   11648:	44 20 01 14 	movi $r2,#0x114
   1164c:	49 00 05 32 	jal 120b0 <memcpy>

	if(stFHdr.u32Sign != BOOT_HEADER_SIGN)goto END_FT;
   11650:	46 0a bc d1 	sethi $r0,#0xabcd1
   11654:	b4 a7       	lwi450 $r5,[$r7]
   11656:	50 00 02 34 	addi $r0,$r0,#0x234
		spi_memctrl_set(QSPI_DIV, QSPI_DELAY, 0xEB, fr_info);
	}

	spi_memctrl_mode_set(SPI_MEMC_MEMORY_MAP_MODE, 0);
	// read flash header
	memcpy(&stFHdr, (uint8 *)(SPI_MEM_BASE_ADDR), sizeof(PP_FLASH_HDR_S));
   1165a:	a1 b9       	lwi333 $r6,[$r7+#0x4]

	if(stFHdr.u32Sign != BOOT_HEADER_SIGN)goto END_FT;
   1165c:	d8 58       	bnes38 $r0,1170c <spi_nor_flash_boot+0x110>
	if(stFHdr.u32FlashType != SPI_FLASH_TYPE_NOR)goto END_FT;
   1165e:	ce 57       	bnez38 $r6,1170c <spi_nor_flash_boot+0x110>

#ifdef SPI_FLASH_READ_QDMA
	spi_memctrl_mode_set(SPI_MEMC_QDMA_MODE, 0);
   11660:	80 06       	mov55 $r0,$r6
   11662:	80 26       	mov55 $r1,$r6
   11664:	49 00 02 c6 	jal 11bf0 <spi_memctrl_mode_set>
	//=============================================================================
	// ISP firmware load & run
	//=============================================================================
	u8SectValid = 1;
	enSect = eFLASH_SECT_IFW;
	if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_IFW].u32Ver)){
   11668:	f0 10       	lwi37.sp $r0,[+#0x40]
   1166a:	8e 01       	subi45 $r0,#0x1
   1166c:	5c f0 7f fe 	slti $r15,$r0,#-2
   11670:	e9 07       	bnezs8 1167e <spi_nor_flash_boot+0x82>
		enSect = eFLASH_SECT_IFW;
	}else{
		if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_IFW1].u32Ver)){
   11672:	f0 14       	lwi37.sp $r0,[+#0x50]
   11674:	8e 01       	subi45 $r0,#0x1
   11676:	5c f0 7f fe 	slti $r15,$r0,#-2
   1167a:	e9 4c       	bnezs8 11712 <spi_nor_flash_boot+0x116>
   1167c:	d5 3d       	j8 116f6 <spi_nor_flash_boot+0xfa>
	// ISP firmware load & run
	//=============================================================================
	u8SectValid = 1;
	enSect = eFLASH_SECT_IFW;
	if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_IFW].u32Ver)){
		enSect = eFLASH_SECT_IFW;
   1167e:	84 c2       	movi55 $r6,#0x2
		}
	}

	if(u8SectValid){
		// isp init data loading
		if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_ISP_DATA].u32Ver)){
   11680:	f0 34       	lwi37.sp $r0,[+#0xd0]
   11682:	8e 01       	subi45 $r0,#0x1
   11684:	5c f0 7f fe 	slti $r15,$r0,#-2
   11688:	e8 06       	beqzs8 11694 <spi_nor_flash_boot+0x98>
#ifdef SPI_FLASH_READ_QDMA
			// QDMA read
			spi_memctrl_read_qdma(stFHdr.stSect[eFLASH_SECT_ISP_DATA].u32FlashAddr, (uint8 *)stFHdr.stSect[eFLASH_SECT_ISP_DATA].u32LoadAddr, stFHdr.stSect[eFLASH_SECT_ISP_DATA].u32Size);
   1168a:	f0 35       	lwi37.sp $r0,[+#0xd4]
   1168c:	f1 36       	lwi37.sp $r1,[+#0xd8]
   1168e:	f2 37       	lwi37.sp $r2,[+#0xdc]
   11690:	49 00 02 ff 	jal 11c8e <spi_memctrl_read_qdma>
#endif

		}

		// sensor init data loading
		if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_SENSOR_DATA].u32Ver)){
   11694:	f0 38       	lwi37.sp $r0,[+#0xe0]
   11696:	8e 01       	subi45 $r0,#0x1
   11698:	5c f0 7f fe 	slti $r15,$r0,#-2
   1169c:	e8 06       	beqzs8 116a8 <spi_nor_flash_boot+0xac>
#ifdef SPI_FLASH_READ_QDMA
			// QDMA read
			spi_memctrl_read_qdma(stFHdr.stSect[eFLASH_SECT_SENSOR_DATA].u32FlashAddr, (unsigned char *)stFHdr.stSect[eFLASH_SECT_SENSOR_DATA].u32LoadAddr, stFHdr.stSect[eFLASH_SECT_SENSOR_DATA].u32Size);
   1169e:	f0 39       	lwi37.sp $r0,[+#0xe4]
   116a0:	f1 3a       	lwi37.sp $r1,[+#0xe8]
   116a2:	f2 3b       	lwi37.sp $r2,[+#0xec]
   116a4:	49 00 02 f5 	jal 11c8e <spi_memctrl_read_qdma>
		}
		
		// isp firmware loading
#ifdef SPI_FLASH_READ_QDMA
		// QDMA read
		spi_memctrl_read_qdma(stFHdr.stSect[enSect].u32FlashAddr, (uint8 *)stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
   116a8:	b0 03       	addri36.sp $r0,#0xc
   116aa:	40 20 18 80 	add_slli $r2,$r0,$r6,#0x4
   116ae:	8c 58       	addi45 $r2,#0x18
   116b0:	04 91 00 01 	lwi $r9,[$r2+#0x4]
   116b4:	a1 d2       	lwi333 $r7,[$r2+#0x8]
   116b6:	40 00 18 80 	add_slli $r0,$r0,$r6,#0x4
   116ba:	80 29       	mov55 $r1,$r9
   116bc:	80 47       	mov55 $r2,$r7
   116be:	a0 06       	lwi333 $r0,[$r0+#0x18]
   116c0:	49 00 02 e7 	jal 11c8e <spi_memctrl_read_qdma>
		cache_inv_range((uint32 *)stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
   116c4:	80 09       	mov55 $r0,$r9
   116c6:	80 27       	mov55 $r1,$r7
   116c8:	49 ff f5 e2 	jal 1028c <cache_inv_range>
		memcpy((uint8 *)stFHdr.stSect[enSect].u32LoadAddr, (uint8 *)(SPI_MEM_BASE_ADDR + stFHdr.stSect[enSect].u32FlashAddr), stFHdr.stSect[enSect].u32Size);
		cache_wb_range((uint32 *)stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
#endif

		// ISP core reset vector 0x20000000
		*(volatile uint32 *) SUB_CPU_RESET_VECTOR_ADDR = 0x2000;
   116cc:	44 10 20 00 	movi $r1,#0x2000
   116d0:	46 0f 15 00 	sethi $r0,#0xf1500
   116d4:	14 10 00 21 	swi $r1,[$r0+#0x84]
		
		// ISP core reset disable
		*(volatile uint32 *) SUB_CPU_RESET_ADDR = 0x00000001;
   116d8:	84 21       	movi55 $r1,#0x1
   116da:	46 0f 01 00 	sethi $r0,#0xf0100
   116de:	14 10 00 20 	swi $r1,[$r0+#0x80]
   116e2:	44 00 05 dc 	movi $r0,#0x5dc

		u32Result = enSect;

		LOOPDELAY_MSEC(1);
   116e6:	46 1f 00 00 	sethi $r1,#0xf0000
   116ea:	b4 41       	lwi450 $r2,[$r1]
   116ec:	f2 82       	swi37.sp $r2,[+#0x8]
   116ee:	f2 02       	lwi37.sp $r2,[+#0x8]
   116f0:	8e 01       	subi45 $r0,#0x1
   116f2:	b6 41       	swi450 $r2,[$r1]
   116f4:	c8 fb       	bnez38 $r0,116ea <spi_nor_flash_boot+0xee>
	//=============================================================================
	// main firmware load
	//=============================================================================
	u8SectValid = 1;
	enSect = eFLASH_SECT_MFW;
	if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_MFW].u32Ver)){
   116f6:	f0 18       	lwi37.sp $r0,[+#0x60]
   116f8:	8e 01       	subi45 $r0,#0x1
   116fa:	5c f0 7f fe 	slti $r15,$r0,#-2
   116fe:	e9 0c       	bnezs8 11716 <spi_nor_flash_boot+0x11a>
		enSect = eFLASH_SECT_MFW;
	}else{
		if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_MFW1].u32Ver)){
   11700:	f0 1c       	lwi37.sp $r0,[+#0x70]
   11702:	8e 01       	subi45 $r0,#0x1
   11704:	5c f0 7f fe 	slti $r15,$r0,#-2
   11708:	e9 09       	bnezs8 1171a <spi_nor_flash_boot+0x11e>
   1170a:	d5 02       	j8 1170e <spi_nor_flash_boot+0x112>
	SPI_MEM_FR_INFO fr_info;
	//FLASH_HDR_T fhdr;
	PP_FLASH_HDR_S stFHdr;
	uint32 jump_addr = (uint32)-1;
	PP_FLASH_SECT_E enSect;
	uint32 u32Result = 0;
   1170c:	84 c0       	movi55 $r6,#0x0
{

	SPI_MEM_FR_INFO fr_info;
	//FLASH_HDR_T fhdr;
	PP_FLASH_HDR_S stFHdr;
	uint32 jump_addr = (uint32)-1;
   1170e:	84 ff       	movi55 $r7,#-1
   11710:	d5 1b       	j8 11746 <spi_nor_flash_boot+0x14a>
	enSect = eFLASH_SECT_IFW;
	if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_IFW].u32Ver)){
		enSect = eFLASH_SECT_IFW;
	}else{
		if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_IFW1].u32Ver)){
			enSect = eFLASH_SECT_IFW1;
   11712:	84 c3       	movi55 $r6,#0x3
   11714:	d5 b6       	j8 11680 <spi_nor_flash_boot+0x84>
	// main firmware load
	//=============================================================================
	u8SectValid = 1;
	enSect = eFLASH_SECT_MFW;
	if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_MFW].u32Ver)){
		enSect = eFLASH_SECT_MFW;
   11716:	85 24       	movi55 $r9,#0x4
   11718:	d5 02       	j8 1171c <spi_nor_flash_boot+0x120>
	}else{
		if(!FLASH_VER_ERROR_CHECK(stFHdr.stSect[eFLASH_SECT_MFW1].u32Ver)){
			enSect = eFLASH_SECT_MFW1;
   1171a:	85 25       	movi55 $r9,#0x5
	if(u8SectValid){
		//_delay(0x1000000);
#ifdef SPI_FLASH_READ_QDMA
		// QDMA read
		dbg("flash addr:0x%x, load addr: 0x%x, size: 0x%x\n", stFHdr.stSect[enSect].u32FlashAddr, stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
		spi_memctrl_read_qdma(stFHdr.stSect[enSect].u32FlashAddr, (uint8 *)stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
   1171c:	b0 03       	addri36.sp $r0,#0xc
   1171e:	40 00 24 80 	add_slli $r0,$r0,$r9,#0x4
   11722:	8c 18       	addi45 $r0,#0x18
   11724:	a1 c1       	lwi333 $r7,[$r0+#0x4]
   11726:	04 a0 00 02 	lwi $r10,[$r0+#0x8]
   1172a:	b0 03       	addri36.sp $r0,#0xc
   1172c:	40 30 24 80 	add_slli $r3,$r0,$r9,#0x4
   11730:	a0 1e       	lwi333 $r0,[$r3+#0x18]
   11732:	80 27       	mov55 $r1,$r7
   11734:	80 4a       	mov55 $r2,$r10
   11736:	49 00 02 ac 	jal 11c8e <spi_memctrl_read_qdma>
		cache_inv_range((uint32 *)stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
   1173a:	80 07       	mov55 $r0,$r7
   1173c:	80 2a       	mov55 $r1,$r10
   1173e:	49 ff f5 a7 	jal 1028c <cache_inv_range>
		memcpy((uint8 *)stFHdr.stSect[enSect].u32LoadAddr, (uint8 *)(SPI_MEM_BASE_ADDR + stFHdr.stSect[enSect].u32FlashAddr), stFHdr.stSect[enSect].u32Size);
		cache_wb_range((uint32 *)stFHdr.stSect[enSect].u32LoadAddr, stFHdr.stSect[enSect].u32Size);
#endif
		
		jump_addr = stFHdr.stSect[enSect].u32LoadAddr;
		u32Result |= ((enSect&0xff)<<8);
   11742:	40 63 25 04 	or_slli $r6,$r6,$r9,#0x8
	spi_memctrl_set(4, 0x3, fr_info);
#endif

END_FT:

	*(volatile unsigned int *)BOOT_RESULT_ADDR = u32Result;
   11746:	44 01 3f f0 	movi $r0,#0x13ff0
   1174a:	b6 c0       	swi450 $r6,[$r0]
	// jump
	return jump_addr;
	
	
}
   1174c:	80 07       	mov55 $r0,$r7
   1174e:	ed 20       	addi10.sp #0x120
   11750:	fc c0       	pop25 $r10,#0    ! {$r6~$r10, $fp, $gp, $lp}

00011752 <spi_nand_flash_boot>:

uint32 spi_nand_flash_boot(void)
{
   11752:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
   11754:	ee e8       	addi10.sp #-280
	support_qdma = 1;
#else
	support_qdma = 0;
#endif

	if(snand_flash_init(PCLK/2, SPI_MODE, 1) < 0){
   11756:	46 00 1d c5 	sethi $r0,#0x1dc5
   1175a:	50 00 0c 3e 	addi $r0,$r0,#0xc3e
   1175e:	84 20       	movi55 $r1,#0x0
   11760:	84 41       	movi55 $r2,#0x1
   11762:	49 00 00 b3 	jal 118c8 <snand_flash_init>
   11766:	4e 04 00 04 	bgez $r0,1176e <spi_nand_flash_boot+0x1c>
}

uint32 spi_nand_flash_boot(void)
{
	PP_FLASH_HDR_S stFHdr;
	uint32 jump_addr = (uint32)-1;
   1176a:	84 1f       	movi55 $r0,#-1
   1176c:	d5 40       	j8 117ec <spi_nand_flash_boot+0x9a>
	fr_info.mode_size = SPI_MEMCTRL_MODE_SIZE_0;
	fr_info.mode_out_state = SPI_MEMCTRL_MODE_STATE_NONE;
	fr_info.mode_value = 0;
	fr_info.read_type = SPI_MEMCTRL_READ_QUAD_IO;

	if(gstFlashNandID.u8ManufacturerID == NAND_MANID_GIGADEVICE)
   1176e:	2e 10 02 7c 	lbi.gp $r1,[+#0x27c]

	fr_info.flash_type = SPI_FLASH_TYPE_NAND;
	fr_info.mode_size = SPI_MEMCTRL_MODE_SIZE_0;
	fr_info.mode_out_state = SPI_MEMCTRL_MODE_STATE_NONE;
	fr_info.mode_value = 0;
	fr_info.read_type = SPI_MEMCTRL_READ_QUAD_IO;
   11772:	46 08 c0 00 	sethi $r0,#0x8c000

	if(gstFlashNandID.u8ManufacturerID == NAND_MANID_GIGADEVICE)
   11776:	5a 18 c8 05 	bnec $r1,#0xc8,11780 <spi_nand_flash_boot+0x2e>
		fr_info.dummy_size = SPI_MEMCTRL_DUMMY_SIZE_8;
   1177a:	58 00 00 08 	ori $r0,$r0,#0x8
   1177e:	d5 03       	j8 11784 <spi_nand_flash_boot+0x32>
	else // micron, winbond
		fr_info.dummy_size = SPI_MEMCTRL_DUMMY_SIZE_16;
   11780:	58 00 00 10 	ori $r0,$r0,#0x10
   11784:	b6 1f       	swi450 $r0,[$sp]

	spi_memctrl_set(QSPI_DIV, QSPI_DELAY, 0xEB, fr_info);
   11786:	44 20 00 eb 	movi $r2,#0xeb
   1178a:	b4 7f       	lwi450 $r3,[$sp]
   1178c:	84 00       	movi55 $r0,#0x0
   1178e:	84 23       	movi55 $r1,#0x3
   11790:	49 00 02 17 	jal 11bbe <spi_memctrl_set>
	spi_memctrl_mode_set(SPI_MEMC_MEMORY_MAP_MODE, 0);
   11794:	84 20       	movi55 $r1,#0x0
   11796:	84 01       	movi55 $r0,#0x1
   11798:	49 00 02 2c 	jal 11bf0 <spi_memctrl_mode_set>

	snand_flash_read_memc((uint8 *)&stFHdr, 0, sizeof(PP_FLASH_HDR_S), 0);
   1179c:	84 20       	movi55 $r1,#0x0
   1179e:	b0 01       	addri36.sp $r0,#0x4
   117a0:	44 20 01 14 	movi $r2,#0x114
   117a4:	80 61       	mov55 $r3,$r1
   117a6:	49 00 01 69 	jal 11a78 <snand_flash_read_memc>

	if(stFHdr.u32Sign != BOOT_HEADER_SIGN)goto END_FT;
   117aa:	46 0a bc d1 	sethi $r0,#0xabcd1
   117ae:	f5 01       	lwi37.sp $r5,[+#0x4]
   117b0:	50 00 02 34 	addi $r0,$r0,#0x234
   117b4:	d8 db       	bnes38 $r0,1176a <spi_nand_flash_boot+0x18>
	if(stFHdr.u32FlashType != SPI_FLASH_TYPE_NAND)goto END_FT;
   117b6:	f6 02       	lwi37.sp $r6,[+#0x8]
   117b8:	5a 68 01 d9 	bnec $r6,#0x1,1176a <spi_nand_flash_boot+0x18>

	if(snand_batl_init() < 0)goto END_FT;
   117bc:	49 00 01 e2 	jal 11b80 <snand_batl_init>
   117c0:	4e 05 ff d5 	bltz $r0,1176a <spi_nand_flash_boot+0x18>

	if(support_qdma)
		spi_memctrl_mode_set(SPI_MEMC_QDMA_MODE, 0);
   117c4:	84 00       	movi55 $r0,#0x0
   117c6:	80 20       	mov55 $r1,$r0
   117c8:	49 00 02 14 	jal 11bf0 <spi_memctrl_mode_set>
	else
		spi_memctrl_mode_set(SPI_MEMC_MEMORY_MAP_MODE, 0);

	// Load secondary bootloader
	if(stFHdr.stSect[eFLASH_SECT_BL2].u32Ver != 0xffffffff && stFHdr.stSect[eFLASH_SECT_BL2].u32Ver > 0){
   117cc:	f0 0a       	lwi37.sp $r0,[+#0x28]
   117ce:	8e 01       	subi45 $r0,#0x1
   117d0:	5c f0 7f fe 	slti $r15,$r0,#-2
   117d4:	e8 cb       	beqzs8 1176a <spi_nand_flash_boot+0x18>
		//_delay(0x1000000);
		snand_flash_read_memc((uint8 *)stFHdr.stSect[eFLASH_SECT_BL2].u32LoadAddr, stFHdr.stSect[eFLASH_SECT_BL2].u32FlashAddr, stFHdr.stSect[eFLASH_SECT_BL2].u32Size, support_qdma);
   117d6:	f1 0b       	lwi37.sp $r1,[+#0x2c]
   117d8:	f2 0d       	lwi37.sp $r2,[+#0x34]
   117da:	80 66       	mov55 $r3,$r6
   117dc:	f0 0c       	lwi37.sp $r0,[+#0x30]
   117de:	49 00 01 4d 	jal 11a78 <snand_flash_read_memc>
		if(!support_qdma)
			cache_wb_range((uint32 *)stFHdr.stSect[eFLASH_SECT_BL2].u32LoadAddr, stFHdr.stSect[eFLASH_SECT_BL2].u32Size);
		else
			cache_inv_range((uint32 *)stFHdr.stSect[eFLASH_SECT_BL2].u32LoadAddr, stFHdr.stSect[eFLASH_SECT_BL2].u32Size);
   117e2:	f0 0c       	lwi37.sp $r0,[+#0x30]
   117e4:	f1 0d       	lwi37.sp $r1,[+#0x34]
   117e6:	49 ff f5 53 	jal 1028c <cache_inv_range>

		jump_addr = stFHdr.stSect[eFLASH_SECT_BL2].u32LoadAddr;
   117ea:	f0 0c       	lwi37.sp $r0,[+#0x30]

	dbg("sign: 0x%x, type: 0x%x, bl2 ver: 0x%x, jump_addr: 0x%x\n", stFHdr.u32Sign, stFHdr.u32FlashType, stFHdr.stSect[eFLASH_SECT_BL2].u32Ver, jump_addr);
	return jump_addr;
	
	
}
   117ec:	ed 18       	addi10.sp #0x118
   117ee:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000117f0 <snand_flash_wait>:
static uint32 gPageCachedFlag = 0;
static uint32 gCachedAddr = 0;


static void snand_flash_wait(void)
{
   117f0:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	uint8 cmd[4];
	uint8 buf[4];

	cmd[0] = CMD_GET_FEATURE;
   117f2:	84 0f       	movi55 $r0,#0xf
   117f4:	10 0f 80 00 	sbi $r0,[$sp+#0x0]
	cmd[1] = FEATURE_ADDR_STATUS;
   117f8:	44 0f ff c0 	movi $r0,#-64
   117fc:	10 0f 80 01 	sbi $r0,[$sp+#0x1]
	cmd[2] = 0;
   11800:	84 00       	movi55 $r0,#0x0
   11802:	10 0f 80 02 	sbi $r0,[$sp+#0x2]

	do{
		spi_xfer(eSPI_CHANNEL_FLASH, cmd, buf, 3);
   11806:	84 03       	movi55 $r0,#0x3
   11808:	80 3f       	mov55 $r1,$sp
   1180a:	b0 81       	addri36.sp $r2,#0x4
   1180c:	80 60       	mov55 $r3,$r0
   1180e:	49 ff f6 82 	jal 10512 <spi_xfer>
	}while(buf[2] & 1);
   11812:	00 0f 80 06 	lbi $r0,[$sp+#0x6]
   11816:	96 04       	xlsb33 $r0,$r0
   11818:	c8 f7       	bnez38 $r0,11806 <snand_flash_wait+0x16>

}
   1181a:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

0001181c <snand_flash_read_id>:

	return 0;
}

sint32 snand_flash_read_id(uint8* id)
{
   1181c:	fc 21       	push25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}
	uint8 cmd[4];
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
   1181e:	84 c0       	movi55 $r6,#0x0

	return 0;
}

sint32 snand_flash_read_id(uint8* id)
{
   11820:	80 e0       	mov55 $r7,$r0
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
	cmd[0] = CMD_READ_ID;
   11822:	44 0f ff 9f 	movi $r0,#-97
	uint8 cmd[4];
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
   11826:	b6 df       	swi450 $r6,[$sp]
	cmd[0] = CMD_READ_ID;

	spi_xfer(eSPI_CHANNEL_FLASH, cmd, buf, size);
   11828:	80 3f       	mov55 $r1,$sp
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
	cmd[0] = CMD_READ_ID;
   1182a:	10 0f 80 00 	sbi $r0,[$sp+#0x0]

	spi_xfer(eSPI_CHANNEL_FLASH, cmd, buf, size);
   1182e:	b0 81       	addri36.sp $r2,#0x4
   11830:	84 64       	movi55 $r3,#0x4
   11832:	84 03       	movi55 $r0,#0x3
   11834:	49 ff f6 6f 	jal 10512 <spi_xfer>

	memcpy(id, buf, 4);
   11838:	b0 01       	addri36.sp $r0,#0x4
   1183a:	3a 00 00 00 	lmw.bi $r0,[$r0],$r0,#0x0    ! {$r0}
   1183e:	3a 03 80 20 	smw.bi $r0,[$r7],$r0,#0x0    ! {$r0}

	return 0;
}
   11842:	80 06       	mov55 $r0,$r6
   11844:	fc a1       	pop25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}

00011846 <snand_find_id>:
	return 0;

}

sint32 snand_find_id(PP_FLASH_NAND_ID_S *pstID)
{
   11846:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
   11848:	80 c0       	mov55 $r6,$r0
	uint8 id[4];
	uint32 i;

	// find flash manufacturer id
	snand_flash_read_id(id);
   1184a:	b0 01       	addri36.sp $r0,#0x4
   1184c:	49 ff ff e8 	jal 1181c <snand_flash_read_id>
   11850:	44 01 21 ac 	movi $r0,#0x121ac
	for(i=0;i<sizeof(gstNandFlashIDTable)/sizeof(gstNandFlashIDTable[0]);i++){
		if(gstNandFlashIDTable[i].u8ManufacturerID == id[2] && gstNandFlashIDTable[i].u8DeviceID0 == id[3]){
   11854:	00 2f 80 06 	lbi $r2,[$sp+#0x6]
   11858:	00 3f 80 07 	lbi $r3,[$sp+#0x7]
	uint8 id[4];
	uint32 i;

	// find flash manufacturer id
	snand_flash_read_id(id);
	for(i=0;i<sizeof(gstNandFlashIDTable)/sizeof(gstNandFlashIDTable[0]);i++){
   1185c:	84 20       	movi55 $r1,#0x0
   1185e:	80 80       	mov55 $r4,$r0
		if(gstNandFlashIDTable[i].u8ManufacturerID == id[2] && gstNandFlashIDTable[i].u8DeviceID0 == id[3]){
   11860:	a7 40       	lbi333 $r5,[$r0+#0x0]
   11862:	da 0a       	bnes38 $r2,11876 <snand_find_id+0x30>
   11864:	a7 41       	lbi333 $r5,[$r0+#0x1]
   11866:	db 08       	bnes38 $r3,11876 <snand_find_id+0x30>
			memcpy(pstID, &gstNandFlashIDTable[i], sizeof(PP_FLASH_NAND_ID_S));
   11868:	40 12 04 80 	add_slli $r1,$r4,$r1,#0x4
   1186c:	3b 00 cc 00 	lmw.bi $r16,[$r1],$r19,#0x0    ! {$r16~$r19}
   11870:	3b 03 4c 20 	smw.bi $r16,[$r6],$r19,#0x0    ! {$r16~$r19}
			break;
   11874:	d5 05       	j8 1187e <snand_find_id+0x38>
	uint8 id[4];
	uint32 i;

	// find flash manufacturer id
	snand_flash_read_id(id);
	for(i=0;i<sizeof(gstNandFlashIDTable)/sizeof(gstNandFlashIDTable[0]);i++){
   11876:	8c 21       	addi45 $r1,#0x1
   11878:	8c 10       	addi45 $r0,#0x10
   1187a:	5a 18 05 f3 	bnec $r1,#0x5,11860 <snand_find_id+0x1a>
		if(gstNandFlashIDTable[i].u8ManufacturerID == id[2] && gstNandFlashIDTable[i].u8DeviceID0 == id[3]){
			memcpy(pstID, &gstNandFlashIDTable[i], sizeof(PP_FLASH_NAND_ID_S));
			break;
		}
	}
	if(pstID->u8ManufacturerID == 0){
   1187e:	a6 30       	lbi333 $r0,[$r6+#0x0]
   11880:	e6 01       	slti45 $r0,#0x1
		dbg("error! unsupported flash id(0x%x)\n", id[2]);
		return -1;
	}

	return 0;
}
   11882:	52 07 80 00 	subri $r0,$r15,#0x0
   11886:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00011888 <snand_flash_get_feature>:
	return 0;

}

sint32 snand_flash_get_feature(uint8 addr)
{
   11888:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	uint8 cmd[3];
	uint8 feature[3];

	cmd[0] = CMD_GET_FEATURE;
	cmd[1] = addr;
   1188a:	10 0f 80 01 	sbi $r0,[$sp+#0x1]
	cmd[2] = 0;
   1188e:	84 00       	movi55 $r0,#0x0
   11890:	10 0f 80 02 	sbi $r0,[$sp+#0x2]
sint32 snand_flash_get_feature(uint8 addr)
{
	uint8 cmd[3];
	uint8 feature[3];

	cmd[0] = CMD_GET_FEATURE;
   11894:	84 2f       	movi55 $r1,#0xf
	cmd[1] = addr;
	cmd[2] = 0;
	
	spi_xfer(eSPI_CHANNEL_FLASH, cmd, feature, 3);
   11896:	84 03       	movi55 $r0,#0x3
sint32 snand_flash_get_feature(uint8 addr)
{
	uint8 cmd[3];
	uint8 feature[3];

	cmd[0] = CMD_GET_FEATURE;
   11898:	10 1f 80 00 	sbi $r1,[$sp+#0x0]
	cmd[1] = addr;
	cmd[2] = 0;
	
	spi_xfer(eSPI_CHANNEL_FLASH, cmd, feature, 3);
   1189c:	b0 81       	addri36.sp $r2,#0x4
   1189e:	80 3f       	mov55 $r1,$sp
   118a0:	80 60       	mov55 $r3,$r0
   118a2:	49 ff f6 38 	jal 10512 <spi_xfer>

	return (uint32)feature[2];

}
   118a6:	00 0f 80 06 	lbi $r0,[$sp+#0x6]
   118aa:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

000118ac <snand_flash_set_feature>:

void snand_flash_set_feature(uint8 addr, uint8 feature)
{
   118ac:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	uint8 cmd[3];

	cmd[0] = CMD_SET_FEATURE;
   118ae:	fa 4f       	movpi45 $r2,#0x1f
	cmd[1] = addr;
   118b0:	10 0f 80 05 	sbi $r0,[$sp+#0x5]
	cmd[2] = feature;

	spi_tx(eSPI_CHANNEL_FLASH, cmd, 3);
   118b4:	84 03       	movi55 $r0,#0x3

void snand_flash_set_feature(uint8 addr, uint8 feature)
{
	uint8 cmd[3];

	cmd[0] = CMD_SET_FEATURE;
   118b6:	10 2f 80 04 	sbi $r2,[$sp+#0x4]
	cmd[1] = addr;
	cmd[2] = feature;
   118ba:	10 1f 80 06 	sbi $r1,[$sp+#0x6]

	spi_tx(eSPI_CHANNEL_FLASH, cmd, 3);
   118be:	80 40       	mov55 $r2,$r0
   118c0:	b0 41       	addri36.sp $r1,#0x4
   118c2:	49 ff f5 c6 	jal 1044e <spi_tx>
   118c6:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

000118c8 <snand_flash_init>:

	return 0;
}

sint32 snand_flash_init(uint32 freq, uint32 clk_mode, uint8 quad_io)
{
   118c8:	fc 21       	push25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}
   118ca:	b6 1f       	swi450 $r0,[$sp]
   118cc:	f1 81       	swi37.sp $r1,[+#0x4]

	spi_initialize(eSPI_CHANNEL_FLASH, 0, freq, clk_mode, 8, NULL);
   118ce:	84 20       	movi55 $r1,#0x0
   118d0:	80 a1       	mov55 $r5,$r1
   118d2:	f3 01       	lwi37.sp $r3,[+#0x4]
   118d4:	84 88       	movi55 $r4,#0x8

	return 0;
}

sint32 snand_flash_init(uint32 freq, uint32 clk_mode, uint8 quad_io)
{
   118d6:	80 e2       	mov55 $r7,$r2

	spi_initialize(eSPI_CHANNEL_FLASH, 0, freq, clk_mode, 8, NULL);
   118d8:	84 03       	movi55 $r0,#0x3
   118da:	b4 5f       	lwi450 $r2,[$sp]
   118dc:	49 ff f5 89 	jal 103ee <spi_initialize>

	gTxBuf = (uint8 *)gGlobalBuf;
   118e0:	44 01 22 b4 	movi $r0,#0x122b4
   118e4:	3c 0f ff 87 	swi.gp $r0,[+#-484]
	gRxBuf = (uint8 *)(gGlobalBuf + MAX_DATA_SIZE/2);
   118e8:	50 00 02 00 	addi $r0,$r0,#0x200

	gPageCachedFlag = 0;
   118ec:	84 20       	movi55 $r1,#0x0
{

	spi_initialize(eSPI_CHANNEL_FLASH, 0, freq, clk_mode, 8, NULL);

	gTxBuf = (uint8 *)gGlobalBuf;
	gRxBuf = (uint8 *)(gGlobalBuf + MAX_DATA_SIZE/2);
   118ee:	3c 0f ff 86 	swi.gp $r0,[+#-488]

	gPageCachedFlag = 0;

	memset(&gstFlashNandID, 0, sizeof(gstFlashNandID));
   118f2:	fa 40       	movpi45 $r2,#0x10
   118f4:	44 01 26 b4 	movi $r0,#0x126b4
	spi_initialize(eSPI_CHANNEL_FLASH, 0, freq, clk_mode, 8, NULL);

	gTxBuf = (uint8 *)gGlobalBuf;
	gRxBuf = (uint8 *)(gGlobalBuf + MAX_DATA_SIZE/2);

	gPageCachedFlag = 0;
   118f8:	3c 1f ff 85 	swi.gp $r1,[+#-492]

	memset(&gstFlashNandID, 0, sizeof(gstFlashNandID));
   118fc:	49 00 03 f0 	jal 120dc <memset>
	if(snand_find_id(&gstFlashNandID)){
   11900:	44 01 26 b4 	movi $r0,#0x126b4
   11904:	49 ff ff a1 	jal 11846 <snand_find_id>
   11908:	80 c0       	mov55 $r6,$r0
   1190a:	c8 1e       	bnez38 $r0,11946 <snand_flash_init+0x7e>
		return -1;
	}
	gPAGE_SIZE = gstFlashNandID.u32PageSize;
	gPAGES_BLOCK = gstFlashNandID.u32EraseBlockSize/gstFlashNandID.u32PageSize;
   1190c:	3c 0c 00 a2 	lwi.gp $r0,[+#0x288]

	memset(&gstFlashNandID, 0, sizeof(gstFlashNandID));
	if(snand_find_id(&gstFlashNandID)){
		return -1;
	}
	gPAGE_SIZE = gstFlashNandID.u32PageSize;
   11910:	3c 1c 00 a1 	lwi.gp $r1,[+#0x284]
   11914:	3c 1f ff 5c 	swi.gp $r1,[+#-656]
	gPAGES_BLOCK = gstFlashNandID.u32EraseBlockSize/gstFlashNandID.u32PageSize;
	gBLOCK_SIZE = gstFlashNandID.u32EraseBlockSize;
   11918:	3c 0f ff 5a 	swi.gp $r0,[+#-664]
	memset(&gstFlashNandID, 0, sizeof(gstFlashNandID));
	if(snand_find_id(&gstFlashNandID)){
		return -1;
	}
	gPAGE_SIZE = gstFlashNandID.u32PageSize;
	gPAGES_BLOCK = gstFlashNandID.u32EraseBlockSize/gstFlashNandID.u32PageSize;
   1191c:	40 10 04 37 	divr $r1,$r1,$r0,$r1
	gBLOCK_SIZE = gstFlashNandID.u32EraseBlockSize;

	if(gstFlashNandID.u8ManufacturerID == NAND_MANID_GIGADEVICE){
   11920:	2e 00 02 7c 	lbi.gp $r0,[+#0x27c]
	memset(&gstFlashNandID, 0, sizeof(gstFlashNandID));
	if(snand_find_id(&gstFlashNandID)){
		return -1;
	}
	gPAGE_SIZE = gstFlashNandID.u32PageSize;
	gPAGES_BLOCK = gstFlashNandID.u32EraseBlockSize/gstFlashNandID.u32PageSize;
   11924:	3c 1f ff 5b 	swi.gp $r1,[+#-660]
	gBLOCK_SIZE = gstFlashNandID.u32EraseBlockSize;

	if(gstFlashNandID.u8ManufacturerID == NAND_MANID_GIGADEVICE){
   11928:	5a 08 c8 10 	bnec $r0,#0xc8,11948 <snand_flash_init+0x80>
		if(quad_io){
   1192c:	c7 0e       	beqz38 $r7,11948 <snand_flash_init+0x80>
			uint8 feature;
			feature = snand_flash_get_feature(0xb0);
   1192e:	44 00 00 b0 	movi $r0,#0xb0
   11932:	49 ff ff ab 	jal 11888 <snand_flash_get_feature>
   11936:	96 40       	zeb33 $r1,$r0
			feature |= 1;
			snand_flash_set_feature(0xb0, feature);
   11938:	58 10 80 01 	ori $r1,$r1,#0x1
   1193c:	44 00 00 b0 	movi $r0,#0xb0
   11940:	49 ff ff b6 	jal 118ac <snand_flash_set_feature>
   11944:	d5 02       	j8 11948 <snand_flash_init+0x80>

	gPageCachedFlag = 0;

	memset(&gstFlashNandID, 0, sizeof(gstFlashNandID));
	if(snand_find_id(&gstFlashNandID)){
		return -1;
   11946:	84 df       	movi55 $r6,#-1
			snand_flash_set_feature(0xb0, feature);
		}
	}

	return 0;
}
   11948:	80 06       	mov55 $r0,$r6
   1194a:	fc a1       	pop25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}

0001194c <snand_flash_read>:
	spi_tx(eSPI_CHANNEL_FLASH, cmd, 3);

}

sint32 snand_flash_read(uint8 *buf, uint32 addr, sint32 size)
{
   1194c:	fc 64       	push25 $r14,#32    ! {$r6~$r14, $fp, $gp, $lp}
   1194e:	36 3f 80 04 	fsdi $fd3,[$sp+#0x10]
   11952:	36 4f 80 06 	fsdi $fd4,[$sp+#0x18]
   11956:	6a 03 00 09 	fmtsr $r0,$fs6

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   1195a:	44 01 22 58 	movi $r0,#0x12258
	spi_tx(eSPI_CHANNEL_FLASH, cmd, 3);

}

sint32 snand_flash_read(uint8 *buf, uint32 addr, sint32 size)
{
   1195e:	6a 23 80 09 	fmtsr $r2,$fs7

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   11962:	6a 04 00 09 	fmtsr $r0,$fs8
	spi_tx(eSPI_CHANNEL_FLASH, cmd, 3);

}

sint32 snand_flash_read(uint8 *buf, uint32 addr, sint32 size)
{
   11966:	81 a1       	mov55 $r13,$r1
	uint32 read_size;
	uint32 row_addr;
	uint32 col_addr;
	uint32 block_addr;

	read_size = 0;
   11968:	85 80       	movi55 $r12,#0x0
static sint32 read_from_cache(uint8 *buf, uint32 row_addr, uint32 col_addr, sint32 size)
{

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);

	gTxBuf[0] = CMD_READ_CACHE;
   1196a:	85 0b       	movi55 $r8,#0xb
	uint32 col_addr;
	uint32 block_addr;

	read_size = 0;

	while(read_size < size){
   1196c:	6a 03 80 01 	fmfsr $r0,$fs7
   11970:	40 f6 00 06 	slt $r15,$r12,$r0
   11974:	e8 7c       	beqzs8 11a6c <snand_flash_read+0x120>

		row_addr = addr/gPAGE_SIZE;
   11976:	3c 6d ff 5c 	lwi.gp $r6,[+#-656]
		col_addr = addr - row_addr * gPAGE_SIZE;
   1197a:	81 6d       	mov55 $r11,$r13

	read_size = 0;

	while(read_size < size){

		row_addr = addr/gPAGE_SIZE;
   1197c:	40 76 98 f7 	divr $r7,$r7,$r13,$r6
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);
   11980:	6a 03 80 01 	fmfsr $r0,$fs7

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));
   11984:	6a 24 00 01 	fmfsr $r2,$fs8
	read_size = 0;

	while(read_size < size){

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
   11988:	42 b3 98 75 	msubr32 $r11,$r7,$r6
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);
   1198c:	8a 0c       	sub45 $r0,$r12
   1198e:	8a cb       	sub45 $r6,$r11
   11990:	e2 06       	slt45 $r0,$r6
   11992:	40 60 3c 1b 	cmovn $r6,$r0,$r15

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   11996:	3c 0d ff 5b 	lwi.gp $r0,[+#-660]
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));

		page_read(buf, row_addr, col_addr, read_unit);
   1199a:	81 46       	mov55 $r10,$r6

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   1199c:	40 13 80 37 	divr $r1,$r1,$r7,$r0
   119a0:	8c 22       	addi45 $r1,#0x2
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));
   119a2:	38 21 06 02 	lw $r2,[$r2+($r1<<#0x2)]
   119a6:	9e 41       	subi333 $r1,$r0,#0x1
   119a8:	ff ce       	and33 $r7,$r1
   119aa:	42 70 08 73 	maddr32 $r7,$r0,$r2

	//=======================================================
	//	READ TO CACHE
	//=======================================================

	if(gPageCachedFlag == 0 || gCachedAddr != row_addr){
   119ae:	3c 0d ff 85 	lwi.gp $r0,[+#-492]
   119b2:	c0 04       	beqz38 $r0,119ba <snand_flash_read+0x6e>
   119b4:	3c 5d ff 84 	lwi.gp $r5,[+#-496]
   119b8:	d7 1a       	beqs38 $r7,119ec <snand_flash_read+0xa0>

		// send read cmd
		cmd[0] = CMD_READ_PAGE;
   119ba:	fa 03       	movpi45 $r0,#0x13
   119bc:	10 0f 80 08 	sbi $r0,[$sp+#0x8]
		cmd[1] = ((row_addr>>16)&0xff);
   119c0:	40 03 c0 09 	srli $r0,$r7,#0x10
   119c4:	10 0f 80 09 	sbi $r0,[$sp+#0x9]
		cmd[2] = ((row_addr>>8)&0xff);
   119c8:	40 03 a0 09 	srli $r0,$r7,#0x8
   119cc:	10 0f 80 0a 	sbi $r0,[$sp+#0xa]
		cmd[3] = ((row_addr>>0)&0xff);

		spi_tx(eSPI_CHANNEL_FLASH, cmd, 4);
   119d0:	b0 42       	addri36.sp $r1,#0x8
   119d2:	84 44       	movi55 $r2,#0x4
   119d4:	84 03       	movi55 $r0,#0x3

		// send read cmd
		cmd[0] = CMD_READ_PAGE;
		cmd[1] = ((row_addr>>16)&0xff);
		cmd[2] = ((row_addr>>8)&0xff);
		cmd[3] = ((row_addr>>0)&0xff);
   119d6:	10 7f 80 0b 	sbi $r7,[$sp+#0xb]

		spi_tx(eSPI_CHANNEL_FLASH, cmd, 4);
   119da:	49 ff f5 3a 	jal 1044e <spi_tx>

		snand_flash_wait();
   119de:	49 ff ff 09 	jal 117f0 <snand_flash_wait>

		gCachedAddr = row_addr;
		gPageCachedFlag = 1;
   119e2:	84 01       	movi55 $r0,#0x1

		spi_tx(eSPI_CHANNEL_FLASH, cmd, 4);

		snand_flash_wait();

		gCachedAddr = row_addr;
   119e4:	3c 7f ff 84 	swi.gp $r7,[+#-496]
		gPageCachedFlag = 1;
   119e8:	3c 0f ff 85 	swi.gp $r0,[+#-492]
}

static sint32 read_from_cache(uint8 *buf, uint32 row_addr, uint32 col_addr, sint32 size)
{

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);
   119ec:	6a e3 00 01 	fmfsr $r14,$fs6
   119f0:	44 90 01 00 	movi $r9,#0x100

	gTxBuf[0] = CMD_READ_CACHE;
	gTxBuf[1] = ((col_addr>>8)&0xff);
	gTxBuf[2] = ((col_addr>>0)&0xff);
	gTxBuf[3] = 0;
   119f4:	84 80       	movi55 $r4,#0x0
	}

	//=======================================================
	//	READ FROM CACHE
	//=======================================================
	while(size > 0){
   119f6:	4e a7 00 30 	blez $r10,11a56 <snand_flash_read+0x10a>
		read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
   119fa:	e3 2a       	slt45 $r9,$r10
   119fc:	e9 03       	bnezs8 11a02 <snand_flash_read+0xb6>
   119fe:	81 2a       	mov55 $r9,$r10
   11a00:	d5 03       	j8 11a06 <snand_flash_read+0xba>
   11a02:	44 90 01 00 	movi $r9,#0x100
}

static sint32 read_from_cache(uint8 *buf, uint32 row_addr, uint32 col_addr, sint32 size)
{

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);
   11a06:	3c 1d ff 5b 	lwi.gp $r1,[+#-660]
   11a0a:	fe 7e       	and33 $r1,$r7
   11a0c:	c1 06       	beqz38 $r1,11a18 <snand_flash_read+0xcc>
   11a0e:	3c 3d ff 5c 	lwi.gp $r3,[+#-656]
   11a12:	40 35 8c 24 	or_slli $r3,$r11,$r3,#0x1
   11a16:	d5 02       	j8 11a1a <snand_flash_read+0xce>
   11a18:	80 6b       	mov55 $r3,$r11

	gTxBuf[0] = CMD_READ_CACHE;
   11a1a:	3c 1d ff 87 	lwi.gp $r1,[+#-484]
	gTxBuf[1] = ((col_addr>>8)&0xff);
   11a1e:	40 01 a0 09 	srli $r0,$r3,#0x8
	gTxBuf[2] = ((col_addr>>0)&0xff);
	gTxBuf[3] = 0;
   11a22:	af 0b       	sbi333 $r4,[$r1+#0x3]
{

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);

	gTxBuf[0] = CMD_READ_CACHE;
	gTxBuf[1] = ((col_addr>>8)&0xff);
   11a24:	ae 09       	sbi333 $r0,[$r1+#0x1]
	gTxBuf[2] = ((col_addr>>0)&0xff);
   11a26:	ae ca       	sbi333 $r3,[$r1+#0x2]
static sint32 read_from_cache(uint8 *buf, uint32 row_addr, uint32 col_addr, sint32 size)
{

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);

	gTxBuf[0] = CMD_READ_CACHE;
   11a28:	10 80 80 00 	sbi $r8,[$r1+#0x0]
	gTxBuf[1] = ((col_addr>>8)&0xff);
	gTxBuf[2] = ((col_addr>>0)&0xff);
	gTxBuf[3] = 0;


	spi_xfer(eSPI_CHANNEL_FLASH, gTxBuf, gRxBuf, size + 4);
   11a2c:	3c 2d ff 86 	lwi.gp $r2,[+#-488]
   11a30:	50 34 80 04 	addi $r3,$r9,#0x4
   11a34:	84 03       	movi55 $r0,#0x3
	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);

	gTxBuf[0] = CMD_READ_CACHE;
	gTxBuf[1] = ((col_addr>>8)&0xff);
	gTxBuf[2] = ((col_addr>>0)&0xff);
	gTxBuf[3] = 0;
   11a36:	f4 81       	swi37.sp $r4,[+#0x4]


	spi_xfer(eSPI_CHANNEL_FLASH, gTxBuf, gRxBuf, size + 4);
   11a38:	49 ff f5 6d 	jal 10512 <spi_xfer>
	memcpy(buf, &gRxBuf[4], size);
   11a3c:	3c 1d ff 86 	lwi.gp $r1,[+#-488]
   11a40:	80 0e       	mov55 $r0,$r14
   11a42:	8c 24       	addi45 $r1,#0x4
   11a44:	80 49       	mov55 $r2,$r9
   11a46:	49 00 03 35 	jal 120b0 <memcpy>
	//	READ FROM CACHE
	//=======================================================
	while(size > 0){
		read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
		read_from_cache(buf, row_addr, col_addr, read_unit);
		buf += read_unit;
   11a4a:	40 e7 24 00 	add $r14,$r14,$r9
		col_addr += read_unit;
   11a4e:	89 69       	add45 $r11,$r9
		size -= read_unit;
   11a50:	8b 49       	sub45 $r10,$r9
   11a52:	f4 01       	lwi37.sp $r4,[+#0x4]
   11a54:	d5 d1       	j8 119f6 <snand_flash_read+0xaa>
		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));

		page_read(buf, row_addr, col_addr, read_unit);

		buf += read_unit;
   11a56:	6a 03 00 01 	fmfsr $r0,$fs6
		addr += read_unit;
   11a5a:	40 d6 98 00 	add $r13,$r13,$r6
		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));

		page_read(buf, row_addr, col_addr, read_unit);

		buf += read_unit;
   11a5e:	88 06       	add45 $r0,$r6
   11a60:	6a 03 00 09 	fmtsr $r0,$fs6
		addr += read_unit;
		read_size += read_unit;
   11a64:	40 c6 18 00 	add $r12,$r12,$r6
   11a68:	48 ff ff 82 	j 1196c <snand_flash_read+0x20>
		
	}

	return 0;	
}
   11a6c:	84 00       	movi55 $r0,#0x0
   11a6e:	34 3f 80 04 	fldi $fd3,[$sp+#0x10]
   11a72:	34 4f 80 06 	fldi $fd4,[$sp+#0x18]
   11a76:	fc e4       	pop25 $r14,#32    ! {$r6~$r14, $fp, $gp, $lp}

00011a78 <snand_flash_read_memc>:

sint32 snand_flash_read_memc(uint8 *buf, uint32 addr, sint32 size, uint8 dma)
{
   11a78:	fc 63       	push25 $r14,#24    ! {$r6~$r14, $fp, $gp, $lp}
   11a7a:	36 3f 80 02 	fsdi $fd3,[$sp+#0x8]
   11a7e:	36 4f 80 04 	fsdi $fd4,[$sp+#0x10]
   11a82:	81 00       	mov55 $r8,$r0

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   11a84:	44 01 22 58 	movi $r0,#0x12258
   11a88:	6a 04 00 09 	fmtsr $r0,$fs8
	if(dma){
		spi_memctrl_read_qdma(col_addr, buf, size);
	}else{
		while(size > 0){
			read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
			ptr = (uint8 *)(SPI_MEM_BASE_ADDR + col_addr);
   11a8c:	46 01 00 00 	sethi $r0,#0x10000

	return 0;	
}

sint32 snand_flash_read_memc(uint8 *buf, uint32 addr, sint32 size, uint8 dma)
{
   11a90:	6a 33 80 09 	fmtsr $r3,$fs7
	if(dma){
		spi_memctrl_read_qdma(col_addr, buf, size);
	}else{
		while(size > 0){
			read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
			ptr = (uint8 *)(SPI_MEM_BASE_ADDR + col_addr);
   11a94:	6a 04 80 09 	fmtsr $r0,$fs9

	return 0;	
}

sint32 snand_flash_read_memc(uint8 *buf, uint32 addr, sint32 size, uint8 dma)
{
   11a98:	81 81       	mov55 $r12,$r1
   11a9a:	81 c2       	mov55 $r14,$r2
	uint32 read_size;
	uint32 row_addr;
	uint32 col_addr;
	uint32 block_addr;

	read_size = 0;
   11a9c:	85 60       	movi55 $r11,#0x0

	while(read_size < size){
   11a9e:	e3 6e       	slt45 $r11,$r14
   11aa0:	e8 6a       	beqzs8 11b74 <snand_flash_read_memc+0xfc>

		row_addr = addr/gPAGE_SIZE;
   11aa2:	3c 6d ff 5c 	lwi.gp $r6,[+#-656]
		col_addr = addr - row_addr * gPAGE_SIZE;
   11aa6:	81 2c       	mov55 $r9,$r12

	read_size = 0;

	while(read_size < size){

		row_addr = addr/gPAGE_SIZE;
   11aa8:	40 76 18 f7 	divr $r7,$r7,$r12,$r6
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));
   11aac:	6a 24 00 01 	fmfsr $r2,$fs8
	read_size = 0;

	while(read_size < size){

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
   11ab0:	42 93 98 75 	msubr32 $r9,$r7,$r6
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);
   11ab4:	40 07 2c 01 	sub $r0,$r14,$r11
   11ab8:	8a c9       	sub45 $r6,$r9
   11aba:	e2 06       	slt45 $r0,$r6
   11abc:	40 60 3c 1b 	cmovn $r6,$r0,$r15

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   11ac0:	3c 0d ff 5b 	lwi.gp $r0,[+#-660]
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));

		//page_read(buf, row_addr, col_addr, read_unit);
		page_read_memc(buf, row_addr, col_addr, read_unit, dma);
   11ac4:	81 46       	mov55 $r10,$r6

		row_addr = addr/gPAGE_SIZE;
		col_addr = addr - row_addr * gPAGE_SIZE;
		read_unit = ((size - read_size > (gPAGE_SIZE - col_addr)) ? (gPAGE_SIZE - col_addr) : size - read_size);

		block_addr = gstBATL.u32LUT[(row_addr/gPAGES_BLOCK)];
   11ac6:	40 13 80 37 	divr $r1,$r1,$r7,$r0
   11aca:	8c 22       	addi45 $r1,#0x2
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));
   11acc:	38 11 06 02 	lw $r1,[$r2+($r1<<#0x2)]
   11ad0:	9f 01       	subi333 $r4,$r0,#0x1
   11ad2:	ff e6       	and33 $r7,$r4
   11ad4:	42 70 04 73 	maddr32 $r7,$r0,$r1

	//if(gPageCachedFlag == 0 || gCachedAddr != row_addr){
	if(1){

		// send read cmd
		cmd[0] = CMD_READ_PAGE;
   11ad8:	fa 03       	movpi45 $r0,#0x13
   11ada:	10 0f 80 00 	sbi $r0,[$sp+#0x0]
		cmd[1] = ((row_addr>>16)&0xff);
   11ade:	40 03 c0 09 	srli $r0,$r7,#0x10
   11ae2:	10 0f 80 01 	sbi $r0,[$sp+#0x1]
		cmd[2] = ((row_addr>>8)&0xff);
   11ae6:	40 03 a0 09 	srli $r0,$r7,#0x8
   11aea:	10 0f 80 02 	sbi $r0,[$sp+#0x2]
		cmd[3] = ((row_addr>>0)&0xff);

		spi_tx(eSPI_CHANNEL_FLASH, cmd, 4);
   11aee:	80 3f       	mov55 $r1,$sp
   11af0:	84 44       	movi55 $r2,#0x4
   11af2:	84 03       	movi55 $r0,#0x3

		// send read cmd
		cmd[0] = CMD_READ_PAGE;
		cmd[1] = ((row_addr>>16)&0xff);
		cmd[2] = ((row_addr>>8)&0xff);
		cmd[3] = ((row_addr>>0)&0xff);
   11af4:	10 7f 80 03 	sbi $r7,[$sp+#0x3]

		spi_tx(eSPI_CHANNEL_FLASH, cmd, 4);
   11af8:	49 ff f4 ab 	jal 1044e <spi_tx>

		snand_flash_wait();
   11afc:	49 ff fe 7a 	jal 117f0 <snand_flash_wait>

		gCachedAddr = row_addr;
		gPageCachedFlag = 1;
   11b00:	84 01       	movi55 $r0,#0x1
   11b02:	3c 0f ff 85 	swi.gp $r0,[+#-492]

	//=======================================================
	//	READ FROM CACHE
	//=======================================================

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);
   11b06:	3c 0d ff 5b 	lwi.gp $r0,[+#-660]

		spi_tx(eSPI_CHANNEL_FLASH, cmd, 4);

		snand_flash_wait();

		gCachedAddr = row_addr;
   11b0a:	3c 7f ff 84 	swi.gp $r7,[+#-496]

	//=======================================================
	//	READ FROM CACHE
	//=======================================================

	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);
   11b0e:	ff c6       	and33 $r7,$r0
   11b10:	c7 05       	beqz38 $r7,11b1a <snand_flash_read_memc+0xa2>
   11b12:	3c 0d ff 5c 	lwi.gp $r0,[+#-656]
   11b16:	40 94 80 24 	or_slli $r9,$r9,$r0,#0x1

	if(dma){
   11b1a:	6a 03 80 01 	fmfsr $r0,$fs7
   11b1e:	c8 05       	bnez38 $r0,11b28 <snand_flash_read_memc+0xb0>
   11b20:	81 a8       	mov55 $r13,$r8
   11b22:	44 70 01 00 	movi $r7,#0x100
   11b26:	d5 1c       	j8 11b5e <snand_flash_read_memc+0xe6>
		spi_memctrl_read_qdma(col_addr, buf, size);
   11b28:	80 09       	mov55 $r0,$r9
   11b2a:	80 28       	mov55 $r1,$r8
   11b2c:	80 46       	mov55 $r2,$r6
   11b2e:	49 00 00 b0 	jal 11c8e <spi_memctrl_read_qdma>
   11b32:	d5 1c       	j8 11b6a <snand_flash_read_memc+0xf2>
	}else{
		while(size > 0){
			read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
   11b34:	e2 ea       	slt45 $r7,$r10
   11b36:	e9 17       	bnezs8 11b64 <snand_flash_read_memc+0xec>
   11b38:	80 ea       	mov55 $r7,$r10
			ptr = (uint8 *)(SPI_MEM_BASE_ADDR + col_addr);
   11b3a:	6a 04 80 01 	fmfsr $r0,$fs9
			cache_inv_range((uint32 *)ptr, read_unit);
   11b3e:	80 27       	mov55 $r1,$r7
	if(dma){
		spi_memctrl_read_qdma(col_addr, buf, size);
	}else{
		while(size > 0){
			read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
			ptr = (uint8 *)(SPI_MEM_BASE_ADDR + col_addr);
   11b40:	88 09       	add45 $r0,$r9
   11b42:	6a 03 00 09 	fmtsr $r0,$fs6
			cache_inv_range((uint32 *)ptr, read_unit);
   11b46:	49 ff f3 a3 	jal 1028c <cache_inv_range>
			memcpy(buf, ptr, read_unit);
   11b4a:	80 0d       	mov55 $r0,$r13
   11b4c:	80 47       	mov55 $r2,$r7
   11b4e:	6a 13 00 01 	fmfsr $r1,$fs6

			buf += read_unit;
   11b52:	40 d6 9c 00 	add $r13,$r13,$r7
	}else{
		while(size > 0){
			read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
			ptr = (uint8 *)(SPI_MEM_BASE_ADDR + col_addr);
			cache_inv_range((uint32 *)ptr, read_unit);
			memcpy(buf, ptr, read_unit);
   11b56:	49 00 02 ad 	jal 120b0 <memcpy>

			buf += read_unit;
			col_addr += read_unit;
   11b5a:	89 27       	add45 $r9,$r7
			size -= read_unit;
   11b5c:	8b 47       	sub45 $r10,$r7
	if(gPAGES_BLOCK & row_addr)col_addr |= (gPAGE_SIZE<<1);

	if(dma){
		spi_memctrl_read_qdma(col_addr, buf, size);
	}else{
		while(size > 0){
   11b5e:	4e a6 ff eb 	bgtz $r10,11b34 <snand_flash_read_memc+0xbc>
   11b62:	d5 04       	j8 11b6a <snand_flash_read_memc+0xf2>
			read_unit = (size > read_unit) ? 256 : size;		// spi controller max transfer cnt: 512
   11b64:	44 70 01 00 	movi $r7,#0x100
   11b68:	d5 e9       	j8 11b3a <snand_flash_read_memc+0xc2>
		row_addr = block_addr * gPAGES_BLOCK + (row_addr & (gPAGES_BLOCK-1));

		//page_read(buf, row_addr, col_addr, read_unit);
		page_read_memc(buf, row_addr, col_addr, read_unit, dma);

		buf += read_unit;
   11b6a:	89 06       	add45 $r8,$r6
		addr += read_unit;
   11b6c:	40 c6 18 00 	add $r12,$r12,$r6
		read_size += read_unit;
   11b70:	89 66       	add45 $r11,$r6
   11b72:	d5 96       	j8 11a9e <snand_flash_read_memc+0x26>


	}

	return 0;
}
   11b74:	84 00       	movi55 $r0,#0x0
   11b76:	34 3f 80 02 	fldi $fd3,[$sp+#0x8]
   11b7a:	34 4f 80 04 	fldi $fd4,[$sp+#0x10]
   11b7e:	fc e3       	pop25 $r14,#24    ! {$r6~$r14, $fp, $gp, $lp}

00011b80 <snand_batl_init>:
{
	sint32 i;

	dbg("NAND BATL Size: %d\n", (int)sizeof(gstBATL));

	for(i=0;i<SPI_NAND_FLASH_BLOCK_TOTAL;i++){
   11b80:	84 00       	movi55 $r0,#0x0
   11b82:	44 21 22 58 	movi $r2,#0x12258
   11b86:	40 11 00 40 	add_slli $r1,$r2,$r0,#0x2
		gstBATL.u32LUT[i] = i;
   11b8a:	a8 0a       	swi333 $r0,[$r1+#0x8]
{
	sint32 i;

	dbg("NAND BATL Size: %d\n", (int)sizeof(gstBATL));

	for(i=0;i<SPI_NAND_FLASH_BLOCK_TOTAL;i++){
   11b8c:	8c 01       	addi45 $r0,#0x1
   11b8e:	5a 08 14 fc 	bnec $r0,#0x14,11b86 <snand_batl_init+0x6>

	return 0;
}

sint32 snand_batl_init(void)
{
   11b92:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
#if NO_BATL
	memcpy(gstBATL.s8Marker, gs8BATLMarker, sizeof(gs8BATLMarker));

#else

	snand_flash_read_memc((uint8 *)&gstBATL, NAND_BATL_ADDR, sizeof(gstBATL), 0);
   11b94:	84 60       	movi55 $r3,#0x0
   11b96:	44 10 10 00 	movi $r1,#0x1000
   11b9a:	44 20 00 58 	movi $r2,#0x58
   11b9e:	44 01 22 58 	movi $r0,#0x12258
   11ba2:	49 ff ff 6b 	jal 11a78 <snand_flash_read_memc>

	if(memcmp(gstBATL.s8Marker, gs8BATLMarker, sizeof(gs8BATLMarker)) != 0)
   11ba6:	44 11 21 fc 	movi $r1,#0x121fc
   11baa:	84 48       	movi55 $r2,#0x8
   11bac:	44 01 22 58 	movi $r0,#0x12258
   11bb0:	49 00 02 62 	jal 12074 <memcmp>
   11bb4:	84 20       	movi55 $r1,#0x0
   11bb6:	40 00 80 06 	slt $r0,$r1,$r0
		return -1;
#endif

	return 0;

}
   11bba:	fe 02       	neg33 $r0,$r0
   11bbc:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

00011bbe <spi_memctrl_set>:

void spi_memctrl_set(uint32 div, uint32 rx_delay, uint8 read_cmd, SPI_MEM_FR_INFO fr_info)
{
	uint32 *ptr;

	gpSPIMem->divider = div;
   11bbe:	46 4f 0b 00 	sethi $r4,#0xf0b00
   11bc2:	a8 25       	swi333 $r0,[$r4+#0x14]
	gpSPIMem->rx_delay = rx_delay;
	gpSPIMem->fr_cmd = read_cmd;
	gpSPIMem->buf_sel = 0;
   11bc4:	84 00       	movi55 $r0,#0x0
void spi_memctrl_set(uint32 div, uint32 rx_delay, uint8 read_cmd, SPI_MEM_FR_INFO fr_info)
{
	uint32 *ptr;

	gpSPIMem->divider = div;
	gpSPIMem->rx_delay = rx_delay;
   11bc6:	a8 66       	swi333 $r1,[$r4+#0x18]
	gpSPIMem->fr_cmd = read_cmd;
   11bc8:	a8 a7       	swi333 $r2,[$r4+#0x1c]
	gpSPIMem->buf_sel = 0;
   11bca:	14 02 00 0e 	swi $r0,[$r4+#0x38]
	ptr = (uint32 *)&fr_info;
	gpSPIMem->fr_info = *ptr;
   11bce:	14 32 00 08 	swi $r3,[$r4+#0x20]

	g_qdma_buf_idx = 0;
   11bd2:	3e 07 fe 78 	sbi.gp $r0,[+#-392]
   11bd6:	dd 9e       	ret5 $lp

00011bd8 <spi_memctrl_crc_en>:
	//print_hexw((uint32 *)gpSPIMem, 0x24);
}

void spi_memctrl_crc_en(uint32 en)
{
	gpSPIMem->crc_en = (en & 1);
   11bd8:	96 04       	xlsb33 $r0,$r0
   11bda:	46 1f 0b 00 	sethi $r1,#0xf0b00
   11bde:	14 00 80 10 	swi $r0,[$r1+#0x40]
   11be2:	dd 9e       	ret5 $lp

00011be4 <spi_memctrl_crc_get>:
}

uint16 spi_memctrl_crc_get(void)
{
	return (uint16)(gpSPIMem->crc_result & 0xffff);
   11be4:	46 0f 0b 00 	sethi $r0,#0xf0b00
   11be8:	04 00 00 11 	lwi $r0,[$r0+#0x44]
}
   11bec:	96 01       	zeh33 $r0,$r0
   11bee:	dd 9e       	ret5 $lp

00011bf0 <spi_memctrl_mode_set>:

int spi_memctrl_mode_set(uint8 mode, uint32 bulk_size)
{
   11bf0:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	int ret = 0;
	vuint32 cmd;

	bulk_size &= (~0xf);

	if(mode == SPI_MEMC_MEMORY_MAP_MODE){
   11bf2:	5a 08 01 12 	bnec $r0,#0x1,11c16 <spi_memctrl_mode_set+0x26>
int spi_memctrl_mode_set(uint8 mode, uint32 bulk_size)
{
	int ret = 0;
	vuint32 cmd;

	bulk_size &= (~0xf);
   11bf6:	66 10 80 0f 	bitci $r1,$r1,#0xf

	if(mode == SPI_MEMC_MEMORY_MAP_MODE){
		if(bulk_size > 256 || bulk_size < 16)return 1;
   11bfa:	50 f0 ff f0 	addi $r15,$r1,#-16
   11bfe:	5c f7 80 f1 	slti $r15,$r15,#0xf1
   11c02:	e8 1a       	beqzs8 11c36 <spi_memctrl_mode_set+0x46>

		if(bulk_size){
			gpSPIMem->buf_start |= (1<<1);
   11c04:	46 0f 0b 00 	sethi $r0,#0xf0b00
   11c08:	83 80       	mov55 $fp,$r0
   11c0a:	ba 0f       	lwi37 $r2,[$fp+#0x3c]
   11c0c:	58 21 00 02 	ori $r2,$r2,#0x2
   11c10:	ba 8f       	swi37 $r2,[$fp+#0x3c]
		}else{
			gpSPIMem->buf_start &= (~(1<<1));
		}
		gpSPIMem->dst_size[0] = bulk_size;
   11c12:	b9 8c       	swi37 $r1,[$fp+#0x30]
   11c14:	d5 08       	j8 11c24 <spi_memctrl_mode_set+0x34>
	}else{	// QDMA MODE
		gpSPIMem->buf_start &= (~(1<<1));
   11c16:	46 1f 0b 00 	sethi $r1,#0xf0b00
   11c1a:	83 81       	mov55 $fp,$r1
   11c1c:	b8 0f       	lwi37 $r0,[$fp+#0x3c]
   11c1e:	66 00 00 02 	bitci $r0,$r0,#0x2
   11c22:	b8 8f       	swi37 $r0,[$fp+#0x3c]
	}

	gpSPIMem->buf_sel = 0;
   11c24:	46 1f 0b 00 	sethi $r1,#0xf0b00
   11c28:	84 00       	movi55 $r0,#0x0
   11c2a:	14 00 80 0e 	swi $r0,[$r1+#0x38]
	cmd = gpSPIMem->fr_cmd;
   11c2e:	a0 8f       	lwi333 $r2,[$r1+#0x1c]
   11c30:	f2 81       	swi37.sp $r2,[+#0x4]
	gpSPIMem->fr_cmd = cmd;
   11c32:	f2 01       	lwi37.sp $r2,[+#0x4]
   11c34:	a8 8f       	swi333 $r2,[$r1+#0x1c]

	return ret;
}
   11c36:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00011c38 <spi_memctrl_qdma_fill_buff>:

inline int spi_memctrl_qdma_fill_buff(uint32 flash_addr, uint8 buf_idx, uint32 dst_addr, uint32 size)
{
	int ret = 0;

	if(size > 256 || size < 16)return 1;
   11c38:	50 f1 ff f0 	addi $r15,$r3,#-16
   11c3c:	5c f7 80 f1 	slti $r15,$r15,#0xf1
   11c40:	e8 25       	beqzs8 11c8a <spi_memctrl_qdma_fill_buff+0x52>
	if(buf_idx > 1)return 1;
   11c42:	e6 22       	slti45 $r1,#0x2
   11c44:	e8 23       	beqzs8 11c8a <spi_memctrl_qdma_fill_buff+0x52>
   11c46:	46 4f 0b 00 	sethi $r4,#0xf0b00
   11c4a:	40 52 04 40 	add_slli $r5,$r4,$r1,#0x2

	gpSPIMem->dst_addr[buf_idx] = dst_addr;
   11c4e:	14 22 80 0a 	swi $r2,[$r5+#0x28]
	gpSPIMem->dst_size[buf_idx] = size;
   11c52:	14 32 80 0c 	swi $r3,[$r5+#0x30]
   11c56:	80 64       	mov55 $r3,$r4

	while(gpSPIMem->buf_start & 1);
   11c58:	04 21 80 0f 	lwi $r2,[$r3+#0x3c]
   11c5c:	96 94       	xlsb33 $r2,$r2
   11c5e:	ca fd       	bnez38 $r2,11c58 <spi_memctrl_qdma_fill_buff+0x20>

	while(gpSPIMem->buf_sel & (1<<(8+buf_idx)));
   11c60:	50 50 80 08 	addi $r5,$r1,#0x8
   11c64:	84 41       	movi55 $r2,#0x1
   11c66:	40 51 14 0c 	sll $r5,$r2,$r5
   11c6a:	04 21 80 0e 	lwi $r2,[$r3+#0x38]
   11c6e:	46 4f 0b 00 	sethi $r4,#0xf0b00
   11c72:	fe ae       	and33 $r2,$r5
   11c74:	ca fb       	bnez38 $r2,11c6a <spi_memctrl_qdma_fill_buff+0x32>

	gpSPIMem->fr_addr = flash_addr;
   11c76:	50 32 00 24 	addi $r3,$r4,#0x24
   11c7a:	b6 03       	swi450 $r0,[$r3]
	////
//	gpSPIMem->dst_addr[buf_idx] = dst_addr;
//	gpSPIMem->dst_size[buf_idx] = size;
	////

	gpSPIMem->buf_sel = buf_idx;
   11c7c:	a8 5d       	swi333 $r1,[$r3+#0x14]
	gpSPIMem->buf_start |= 1;
   11c7e:	a0 1e       	lwi333 $r0,[$r3+#0x18]
   11c80:	58 00 00 01 	ori $r0,$r0,#0x1
   11c84:	a8 1e       	swi333 $r0,[$r3+#0x18]
   11c86:	80 02       	mov55 $r0,$r2
   11c88:	dd 9e       	ret5 $lp

inline int spi_memctrl_qdma_fill_buff(uint32 flash_addr, uint8 buf_idx, uint32 dst_addr, uint32 size)
{
	int ret = 0;

	if(size > 256 || size < 16)return 1;
   11c8a:	84 01       	movi55 $r0,#0x1

//	while(gpSPIMem->buf_start & 1);
//	while(gpSPIMem->buf_sel & (1<<(8+buf_idx)));

	return ret;
}
   11c8c:	dd 9e       	ret5 $lp

00011c8e <spi_memctrl_read_qdma>:
	return ret;
}
*/

int spi_memctrl_read_qdma(uint32 flash_addr, uint8 *buf, uint32 size)
{
   11c8e:	fc 60       	push25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}
	int ret;
	//uint8 buf_idx = 0;
	uint32 read_size = 0;
   11c90:	84 c0       	movi55 $r6,#0x0
	return ret;
}
*/

int spi_memctrl_read_qdma(uint32 flash_addr, uint8 *buf, uint32 size)
{
   11c92:	81 60       	mov55 $r11,$r0
   11c94:	81 81       	mov55 $r12,$r1
   11c96:	81 42       	mov55 $r10,$r2
   11c98:	50 d1 00 0f 	addi $r13,$r2,#0xf
	//uint8 buf_idx = 0;
	uint32 read_size = 0;
	uint32 buf_size;

	do{
		if(size > read_size + 256)buf_size = 256;
   11c9c:	50 03 01 00 	addi $r0,$r6,#0x100
   11ca0:	e2 0a       	slt45 $r0,$r10
   11ca2:	e9 06       	bnezs8 11cae <spi_memctrl_read_qdma+0x20>
		else buf_size = (((size - read_size) + 0xf) & (~0xf));
   11ca4:	40 76 98 01 	sub $r7,$r13,$r6
   11ca8:	66 73 80 0f 	bitci $r7,$r7,#0xf
   11cac:	d5 03       	j8 11cb2 <spi_memctrl_read_qdma+0x24>
	//uint8 buf_idx = 0;
	uint32 read_size = 0;
	uint32 buf_size;

	do{
		if(size > read_size + 256)buf_size = 256;
   11cae:	44 70 01 00 	movi $r7,#0x100
		else buf_size = (((size - read_size) + 0xf) & (~0xf));

		//printf("flash addr: 0x%x, buf: 0x%x, read_size: 0x%x, size: 0x%x, idx: %d\n", flash_addr, (uint32)&buf[read_size], read_size, buf_size, buf_idx);
		ret = spi_memctrl_qdma_fill_buff(flash_addr, g_qdma_buf_idx, (uint32)&buf[read_size], buf_size);
   11cb2:	2e 97 fe 78 	lbi.gp $r9,[+#-392]
   11cb6:	80 0b       	mov55 $r0,$r11
   11cb8:	80 29       	mov55 $r1,$r9
   11cba:	40 26 18 00 	add $r2,$r12,$r6
   11cbe:	80 67       	mov55 $r3,$r7
   11cc0:	49 ff ff bc 	jal 11c38 <spi_memctrl_qdma_fill_buff>
		if(ret != 0)return ret;
   11cc4:	c8 10       	bnez38 $r0,11ce4 <spi_memctrl_read_qdma+0x56>

		flash_addr += buf_size;
		read_size += buf_size;
   11cc6:	88 c7       	add45 $r6,$r7

		g_qdma_buf_idx ^= 1;
   11cc8:	56 94 80 01 	xori $r9,$r9,#0x1
	}while(size > read_size);
   11ccc:	e2 ca       	slt45 $r6,$r10

		//printf("flash addr: 0x%x, buf: 0x%x, read_size: 0x%x, size: 0x%x, idx: %d\n", flash_addr, (uint32)&buf[read_size], read_size, buf_size, buf_idx);
		ret = spi_memctrl_qdma_fill_buff(flash_addr, g_qdma_buf_idx, (uint32)&buf[read_size], buf_size);
		if(ret != 0)return ret;

		flash_addr += buf_size;
   11cce:	89 67       	add45 $r11,$r7
		read_size += buf_size;

		g_qdma_buf_idx ^= 1;
   11cd0:	3e 97 fe 78 	sbi.gp $r9,[+#-392]
	}while(size > read_size);
   11cd4:	e9 e4       	bnezs8 11c9c <spi_memctrl_read_qdma+0xe>

	while(gpSPIMem->buf_sel & (3<<8));
   11cd6:	46 2f 0b 00 	sethi $r2,#0xf0b00
   11cda:	04 11 00 0e 	lwi $r1,[$r2+#0x38]
   11cde:	54 10 83 00 	andi $r1,$r1,#0x300
   11ce2:	c9 fc       	bnez38 $r1,11cda <spi_memctrl_read_qdma+0x4c>
	//OSAL_sleep(30);
	//OSAL_sleep(1);

	return ret;

}
   11ce4:	fc e0       	pop25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}

00011ce6 <flash_read_id>:

	return 0;
}

sint32 flash_read_id(uint8 *id)
{
   11ce6:	fc 21       	push25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}
	uint8 cmd[4];
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
   11ce8:	84 c0       	movi55 $r6,#0x0

	return 0;
}

sint32 flash_read_id(uint8 *id)
{
   11cea:	80 e0       	mov55 $r7,$r0
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
	cmd[0] = CMD_READ_ID;
   11cec:	44 0f ff 9f 	movi $r0,#-97
	uint8 cmd[4];
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
   11cf0:	b6 df       	swi450 $r6,[$sp]
	cmd[0] = CMD_READ_ID;
	

	spi_xfer(eSPI_CHANNEL_FLASH, cmd, buf, size);
   11cf2:	80 3f       	mov55 $r1,$sp
	uint8 buf[4];
	sint32 size;

	size = 4;
	memset(cmd, 0, sizeof(cmd));
	cmd[0] = CMD_READ_ID;
   11cf4:	10 0f 80 00 	sbi $r0,[$sp+#0x0]
	

	spi_xfer(eSPI_CHANNEL_FLASH, cmd, buf, size);
   11cf8:	b0 81       	addri36.sp $r2,#0x4
   11cfa:	84 64       	movi55 $r3,#0x4
   11cfc:	84 03       	movi55 $r0,#0x3
   11cfe:	49 ff f4 0a 	jal 10512 <spi_xfer>

	memcpy(id, buf, 4);
   11d02:	b0 01       	addri36.sp $r0,#0x4
   11d04:	3a 00 00 00 	lmw.bi $r0,[$r0],$r0,#0x0    ! {$r0}
   11d08:	3a 03 80 20 	smw.bi $r0,[$r7],$r0,#0x0    ! {$r0}

	return 0;	
}
   11d0c:	80 06       	mov55 $r0,$r6
   11d0e:	fc a1       	pop25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}

00011d10 <flash_find_id>:

	return 0;
}

sint32 flash_find_id(PP_FLASH_ID_S *pstID)
{
   11d10:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
   11d12:	80 c0       	mov55 $r6,$r0
	uint8 id[8];
	uint32 i;

	// find flash manufacturer id
	flash_read_id(id);
   11d14:	80 1f       	mov55 $r0,$sp
   11d16:	49 ff ff e8 	jal 11ce6 <flash_read_id>
   11d1a:	44 01 22 04 	movi $r0,#0x12204
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
		if(gstFlashIDTable[i].u8ManufacturerID == id[1] && gstFlashIDTable[i].u8DeviceID0 == id[2]){
   11d1e:	00 2f 80 01 	lbi $r2,[$sp+#0x1]
   11d22:	00 3f 80 02 	lbi $r3,[$sp+#0x2]
	uint8 id[8];
	uint32 i;

	// find flash manufacturer id
	flash_read_id(id);
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
   11d26:	84 20       	movi55 $r1,#0x0
   11d28:	80 80       	mov55 $r4,$r0
		if(gstFlashIDTable[i].u8ManufacturerID == id[1] && gstFlashIDTable[i].u8DeviceID0 == id[2]){
   11d2a:	a7 40       	lbi333 $r5,[$r0+#0x0]
   11d2c:	da 1f       	bnes38 $r2,11d6a <flash_find_id+0x5a>
   11d2e:	a7 41       	lbi333 $r5,[$r0+#0x1]
   11d30:	db 1d       	bnes38 $r3,11d6a <flash_find_id+0x5a>
			memcpy(pstID, &gstFlashIDTable[i], sizeof(PP_FLASH_ID_S));
			pstID->u32TotalSize = 1024 * 1024 * (1<<((id[3]&0xf)-1)) / 8;
   11d32:	00 0f 80 03 	lbi $r0,[$sp+#0x3]

	// find flash manufacturer id
	flash_read_id(id);
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
		if(gstFlashIDTable[i].u8ManufacturerID == id[1] && gstFlashIDTable[i].u8DeviceID0 == id[2]){
			memcpy(pstID, &gstFlashIDTable[i], sizeof(PP_FLASH_ID_S));
   11d36:	40 12 04 80 	add_slli $r1,$r4,$r1,#0x4
			pstID->u32TotalSize = 1024 * 1024 * (1<<((id[3]&0xf)-1)) / 8;
   11d3a:	96 1f       	fexti33 $r0,#0x3

	// find flash manufacturer id
	flash_read_id(id);
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
		if(gstFlashIDTable[i].u8ManufacturerID == id[1] && gstFlashIDTable[i].u8DeviceID0 == id[2]){
			memcpy(pstID, &gstFlashIDTable[i], sizeof(PP_FLASH_ID_S));
   11d3c:	3b 00 cc 00 	lmw.bi $r16,[$r1],$r19,#0x0    ! {$r16~$r19}
			pstID->u32TotalSize = 1024 * 1024 * (1<<((id[3]&0xf)-1)) / 8;
   11d40:	8e 01       	subi45 $r0,#0x1
   11d42:	46 10 01 00 	sethi $r1,#0x100
   11d46:	40 00 80 0c 	sll $r0,$r1,$r0
   11d4a:	85 e8       	movi55 $r15,#0x8
   11d4c:	40 00 3c 16 	divsr $r0,$r0,$r0,$r15
			if(pstID->u32TotalSize >= (32*1024*1024)){
   11d50:	46 10 1f ff 	sethi $r1,#0x1fff
   11d54:	50 10 8f ff 	addi $r1,$r1,#0xfff
   11d58:	e2 20       	slt45 $r1,$r0

	// find flash manufacturer id
	flash_read_id(id);
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
		if(gstFlashIDTable[i].u8ManufacturerID == id[1] && gstFlashIDTable[i].u8DeviceID0 == id[2]){
			memcpy(pstID, &gstFlashIDTable[i], sizeof(PP_FLASH_ID_S));
   11d5a:	3b 03 4c 20 	smw.bi $r16,[$r6],$r19,#0x0    ! {$r16~$r19}
			pstID->u32TotalSize = 1024 * 1024 * (1<<((id[3]&0xf)-1)) / 8;
   11d5e:	a8 31       	swi333 $r0,[$r6+#0x4]
			if(pstID->u32TotalSize >= (32*1024*1024)){
				pstID->u8AddrMode4Byte = 1;
   11d60:	84 01       	movi55 $r0,#0x1
	flash_read_id(id);
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
		if(gstFlashIDTable[i].u8ManufacturerID == id[1] && gstFlashIDTable[i].u8DeviceID0 == id[2]){
			memcpy(pstID, &gstFlashIDTable[i], sizeof(PP_FLASH_ID_S));
			pstID->u32TotalSize = 1024 * 1024 * (1<<((id[3]&0xf)-1)) / 8;
			if(pstID->u32TotalSize >= (32*1024*1024)){
   11d62:	e9 02       	bnezs8 11d66 <flash_find_id+0x56>
				pstID->u8AddrMode4Byte = 1;
			}else{
				pstID->u8AddrMode4Byte = 0;
   11d64:	84 00       	movi55 $r0,#0x0
   11d66:	ae 33       	sbi333 $r0,[$r6+#0x3]
   11d68:	d5 05       	j8 11d72 <flash_find_id+0x62>
	uint8 id[8];
	uint32 i;

	// find flash manufacturer id
	flash_read_id(id);
	for(i=0;i<sizeof(gstFlashIDTable)/sizeof(gstFlashIDTable[0]);i++){
   11d6a:	8c 21       	addi45 $r1,#0x1
   11d6c:	8c 10       	addi45 $r0,#0x10
   11d6e:	5a 18 04 de 	bnec $r1,#0x4,11d2a <flash_find_id+0x1a>
				pstID->u8AddrMode4Byte = 0;
			}
			break;
		}
	}
	if(pstID->u8ManufacturerID == 0){
   11d72:	a6 30       	lbi333 $r0,[$r6+#0x0]
   11d74:	e6 01       	slti45 $r0,#0x1

	dbg("Serial NOR Flash. Id: 0x%x, 0x%x, 0x%x, 0x%x\n", id[0], id[1], id[2], id[3]);
	dbg("Flash size: 0x%x, Page size: 0x%x, Block size: 0x%x\n", pstID->u32TotalSize, pstID->u32PageSize, pstID->u32EraseBlockSize );

	return 0;
}
   11d76:	52 07 80 00 	subri $r0,$r15,#0x0
   11d7a:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00011d7c <flash_read_status>:

	return 0;	
}

sint32 flash_read_status(void)
{
   11d7c:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	uint8 cmd[2];
	uint8 status[2];
	
	cmd[0] = CMD_READ_STATUS;
   11d7e:	84 05       	movi55 $r0,#0x5
   11d80:	10 0f 80 00 	sbi $r0,[$sp+#0x0]
	
	spi_xfer(eSPI_CHANNEL_FLASH, cmd, status, 2);
   11d84:	80 3f       	mov55 $r1,$sp
   11d86:	b0 81       	addri36.sp $r2,#0x4
   11d88:	84 62       	movi55 $r3,#0x2
   11d8a:	84 03       	movi55 $r0,#0x3
   11d8c:	49 ff f3 c3 	jal 10512 <spi_xfer>

	return (uint32)status[1];

}
   11d90:	00 0f 80 05 	lbi $r0,[$sp+#0x5]
   11d94:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00011d96 <flash_write_status>:

sint32 flash_write_status(uint8 status)
{
   11d96:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	uint8 cmd[2];
	
	cmd[0] = CMD_WRITE_STATUS;
   11d98:	84 21       	movi55 $r1,#0x1
   11d9a:	10 1f 80 04 	sbi $r1,[$sp+#0x4]
	cmd[1] = status;
   11d9e:	10 0f 80 05 	sbi $r0,[$sp+#0x5]
	
	//spi_xfer(cmd, NULL, 2);
	spi_tx(eSPI_CHANNEL_FLASH, cmd, 2);
   11da2:	b0 41       	addri36.sp $r1,#0x4
   11da4:	84 42       	movi55 $r2,#0x2
   11da6:	84 03       	movi55 $r0,#0x3
   11da8:	49 ff f3 53 	jal 1044e <spi_tx>

	return 0;

}
   11dac:	84 00       	movi55 $r0,#0x0
   11dae:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00011db0 <flash_write_enable>:


sint32 flash_write_enable(uint8 enable)
{
   11db0:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	uint8 cmd;

	if(enable)cmd = CMD_WRITE_ENABLE;
   11db2:	c0 03       	beqz38 $r0,11db8 <flash_write_enable+0x8>
   11db4:	84 06       	movi55 $r0,#0x6
   11db6:	d5 02       	j8 11dba <flash_write_enable+0xa>
	else cmd = CMD_WRITE_DISABLE;
   11db8:	84 04       	movi55 $r0,#0x4
   11dba:	10 0f 80 07 	sbi $r0,[$sp+#0x7]
	
	//spi_xfer(&cmd, NULL, 1);
	spi_tx(eSPI_CHANNEL_FLASH, &cmd, 1);
   11dbe:	50 1f 80 07 	addi $r1,$sp,#0x7
   11dc2:	84 41       	movi55 $r2,#0x1
   11dc4:	84 03       	movi55 $r0,#0x3
   11dc6:	49 ff f3 44 	jal 1044e <spi_tx>

	return 0;

}
   11dca:	84 00       	movi55 $r0,#0x0
   11dcc:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00011dce <flash_init>:
}



sint32 flash_init(uint32 freq, uint32 clk_mode, uint8 quad_io)
{
   11dce:	fc 21       	push25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}
   11dd0:	b6 1f       	swi450 $r0,[$sp]
   11dd2:	f1 81       	swi37.sp $r1,[+#0x4]
	sint32 status;
	
    spi_initialize(eSPI_CHANNEL_FLASH, 0, freq, clk_mode, 8, NULL);
   11dd4:	84 20       	movi55 $r1,#0x0
   11dd6:	80 a1       	mov55 $r5,$r1
   11dd8:	f3 01       	lwi37.sp $r3,[+#0x4]
   11dda:	84 88       	movi55 $r4,#0x8
}



sint32 flash_init(uint32 freq, uint32 clk_mode, uint8 quad_io)
{
   11ddc:	80 e2       	mov55 $r7,$r2
	sint32 status;
	
    spi_initialize(eSPI_CHANNEL_FLASH, 0, freq, clk_mode, 8, NULL);
   11dde:	84 03       	movi55 $r0,#0x3
   11de0:	b4 5f       	lwi450 $r2,[$sp]
   11de2:	49 ff f3 06 	jal 103ee <spi_initialize>
        uint8 id[8];
        flash_read_id(id);
        //printf("flash id: 0x%x, 0x%x, 0x%x, 0x%x\n", id[0], id[1], id[2], id[3]);
    }
#endif
	memset(&gstFlashID, 0, sizeof(gstFlashID));
   11de6:	84 20       	movi55 $r1,#0x0
   11de8:	fa 40       	movpi45 $r2,#0x10
   11dea:	44 01 26 c4 	movi $r0,#0x126c4
   11dee:	49 00 01 77 	jal 120dc <memset>
	if(flash_find_id(&gstFlashID)){
   11df2:	44 01 26 c4 	movi $r0,#0x126c4
   11df6:	49 ff ff 8d 	jal 11d10 <flash_find_id>
   11dfa:	80 c0       	mov55 $r6,$r0
   11dfc:	c8 1f       	bnez38 $r0,11e3a <flash_init+0x6c>
		return -1;

	}

	status = flash_read_status();
   11dfe:	49 ff ff bf 	jal 11d7c <flash_read_status>
	if( ((status>>6)&1) != quad_io){	// need quad mode set
   11e02:	42 50 18 0b 	btst $r5,$r0,#0x6
   11e06:	d7 1b       	beqs38 $r7,11e3c <flash_init+0x6e>

		flash_write_enable(1);
   11e08:	84 01       	movi55 $r0,#0x1
   11e0a:	49 ff ff d3 	jal 11db0 <flash_write_enable>
		do{
			status = flash_read_status();
   11e0e:	49 ff ff b7 	jal 11d7c <flash_read_status>
		}while(!(status & 2));
   11e12:	54 10 00 02 	andi $r1,$r0,#0x2
   11e16:	c1 fc       	beqz38 $r1,11e0e <flash_init+0x40>
	
		if(quad_io)
   11e18:	c7 04       	beqz38 $r7,11e20 <flash_init+0x52>
			status |= (1<<6);
   11e1a:	58 00 00 40 	ori $r0,$r0,#0x40
   11e1e:	d5 03       	j8 11e24 <flash_init+0x56>
		else
			status &= (~(1<<6));
   11e20:	66 00 00 40 	bitci $r0,$r0,#0x40

		flash_write_status(status);
   11e24:	96 00       	zeb33 $r0,$r0
   11e26:	49 ff ff b8 	jal 11d96 <flash_write_status>
static sint32 flash_cmd_wait_ready(uint32 timeout)
{
	sint32 status;
	
	do{
		status = flash_read_status();
   11e2a:	49 ff ff a9 	jal 11d7c <flash_read_status>
		//printf("status: 0x%x\n", status);
	}while(status & 1);
   11e2e:	97 84       	xlsb33 $r6,$r0
   11e30:	ce fd       	bnez38 $r6,11e2a <flash_init+0x5c>
			status &= (~(1<<6));

		flash_write_status(status);
		flash_cmd_wait_ready(1);

		flash_write_enable(0);
   11e32:	80 06       	mov55 $r0,$r6
   11e34:	49 ff ff be 	jal 11db0 <flash_write_enable>
   11e38:	d5 02       	j8 11e3c <flash_init+0x6e>
        //printf("flash id: 0x%x, 0x%x, 0x%x, 0x%x\n", id[0], id[1], id[2], id[3]);
    }
#endif
	memset(&gstFlashID, 0, sizeof(gstFlashID));
	if(flash_find_id(&gstFlashID)){
		return -1;
   11e3a:	84 df       	movi55 $r6,#-1

		flash_write_enable(0);
	}

	return 0;
}
   11e3c:	80 06       	mov55 $r0,$r6
   11e3e:	fc a1       	pop25 $r8,#8    ! {$r6~$r8, $fp, $gp, $lp}

00011e40 <fail>:
#include <stdio.h>
#include "system.h"

void fail()
{
   11e40:	dd 9e       	ret5 $lp

00011e42 <ddr3_set>:
    //while(1);

}

void ddr3_set(void)
{
   11e42:	fc 12       	push25 $r6,#144    ! {$r6, $fp, $gp, $lp}

    DDR_MODE = DDR3_MODE; // DDR3


    // ddr postclk, postclk 2x reset release
    *(volatile unsigned int *) 0xF0000048 = 0x00003f9f; // sw rst (ddr_postclk, postclk_2x)
   11e44:	44 00 3f 9f 	movi $r0,#0x3f9f
   11e48:	46 1f 00 00 	sethi $r1,#0xf0000
   11e4c:	14 00 80 12 	swi $r0,[$r1+#0x48]

    // ddr mode set (ddr3)
    // DSRONB, DLL FRANGE setting (1000~1200)
    // phy pll pdn release
    *(volatile unsigned int *) 0xf0100088 = 0x00000000 | DDR_MODE; // DDR mode set
   11e50:	46 2f 01 00 	sethi $r2,#0xf0100
   11e54:	84 00       	movi55 $r0,#0x0
   11e56:	83 82       	mov55 $fp,$r2
   11e58:	b8 a2       	swi37 $r0,[$fp+#0x88]
    *(volatile unsigned int *) 0xf0100088 = 0x00080000 | DDR_MODE | DLLFRANGE; // DSRONB, DLLFRANGE SET
   11e5a:	46 00 00 80 	sethi $r0,#0x80
   11e5e:	50 00 05 00 	addi $r0,$r0,#0x500
   11e62:	b8 a2       	swi37 $r0,[$fp+#0x88]
    *(volatile unsigned int *) 0xf0100088 = 0x00084000 | DDR_MODE | DLLFRANGE; // phy_pll_pdn enable
   11e64:	58 00 40 00 	ori $r0,$r0,#0x4000
   11e68:	b8 a2       	swi37 $r0,[$fp+#0x88]
   11e6a:	44 20 00 96 	movi $r2,#0x96

    // ddr reset low. las, cas, wen low, clock enable ######################################
    LOOPDELAY_10USEC(10); // wait 100us
   11e6e:	b4 61       	lwi450 $r3,[$r1]
   11e70:	b6 7f       	swi450 $r3,[$sp]
   11e72:	b4 7f       	lwi450 $r3,[$sp]
   11e74:	8e 41       	subi45 $r2,#0x1
   11e76:	46 0f 00 00 	sethi $r0,#0xf0000
   11e7a:	b6 61       	swi450 $r3,[$r1]
   11e7c:	ca f9       	bnez38 $r2,11e6e <ddr3_set+0x2c>

    // ddr phy pll reset release
    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, postclk_2x)
   11e7e:	44 10 3f df 	movi $r1,#0x3fdf
   11e82:	14 10 00 12 	swi $r1,[$r0+#0x48]
   11e86:	84 2f       	movi55 $r1,#0xf
    // wait 10 * MCLK
    LOOPDELAY_10USEC(1); // wait 10us
   11e88:	b4 40       	lwi450 $r2,[$r0]
   11e8a:	f2 81       	swi37.sp $r2,[+#0x4]
   11e8c:	f2 01       	lwi37.sp $r2,[+#0x4]
   11e8e:	8e 21       	subi45 $r1,#0x1
   11e90:	b6 40       	swi450 $r2,[$r0]
   11e92:	c9 fb       	bnez38 $r1,11e88 <ddr3_set+0x46>

    // ddr phy dll pdn release
    *(volatile unsigned int *) 0xf0100088 = 0x00087000 | DDR_MODE | DLLFRANGE; // phy_dll_pdn enable
   11e94:	46 00 00 87 	sethi $r0,#0x87
   11e98:	50 00 05 00 	addi $r0,$r0,#0x500
   11e9c:	46 1f 01 00 	sethi $r1,#0xf0100
   11ea0:	14 00 80 22 	swi $r0,[$r1+#0x88]
   11ea4:	44 00 00 96 	movi $r0,#0x96

    LOOPDELAY_10USEC(10); // wait 100us
   11ea8:	46 1f 00 00 	sethi $r1,#0xf0000
   11eac:	b4 41       	lwi450 $r2,[$r1]
   11eae:	f2 82       	swi37.sp $r2,[+#0x8]
   11eb0:	f2 02       	lwi37.sp $r2,[+#0x8]
   11eb2:	8e 01       	subi45 $r0,#0x1
   11eb4:	b6 41       	swi450 $r2,[$r1]
   11eb6:	c8 fb       	bnez38 $r0,11eac <ddr3_set+0x6a>

    // ddr phy reset release
    *(volatile unsigned int *) 0xF0000048 = 0x00003fff; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   11eb8:	44 20 3f ff 	movi $r2,#0x3fff
   11ebc:	46 1f 00 00 	sethi $r1,#0xf0000
   11ec0:	14 20 80 12 	swi $r2,[$r1+#0x48]
#else
#error "unkonwn ddr3 speed dllframe"
#endif


    reg00_value = 
   11ec4:	46 10 86 09 	sethi $r1,#0x8609
   11ec8:	50 10 8e 13 	addi $r1,$r1,#0xe13
   11ecc:	f1 83       	swi37.sp $r1,[+#0xc]
    const unsigned int ZQCS		    = 0x0;
    const unsigned int MRS_mode        = 0x0;
    const unsigned int MemCmd_exit_srf = 0x0; 
    const unsigned int MemCmd_srf      = 0x0; 
    const unsigned int MemCmd_mrs      = 0x0;
    volatile unsigned int MemCmd_initial  = 0x0;
   11ece:	f0 a3       	swi37.sp $r0,[+#0x8c]
        | (ZQCS	           << 6)
        | (MRS_mode        << 4)
        | (MemCmd_exit_srf << 3)
        | (MemCmd_srf      << 2)
        | (MemCmd_mrs      << 1)
        | (MemCmd_initial); 
   11ed0:	f1 23       	lwi37.sp $r1,[+#0x8c]
    const unsigned int MemCmd_srf      = 0x0; 
    const unsigned int MemCmd_mrs      = 0x0;
    volatile unsigned int MemCmd_initial  = 0x0;


    reg04_value =
   11ed2:	f1 84       	swi37.sp $r1,[+#0x10]
    //                    4'b1100 = 10, 4'b1110 = 11, 4'b0001 = 12, 4'b0011 = 13, 4'b0101 = 14

    const unsigned int Burst_Type = 0x0;   //MR0[3] Burst_Type, 1'b0 = Sequential, 1'b1 = Interleaved  
    const unsigned int BL_DDR3    = 0x0;    //MR0[1:0] Burst_Length, 2'b00 = BL8, 2'b01= BC4 or 8 (on the fly), 2'b10 = BC4

    reg08_value =
   11ed4:	46 10 02 40 	sethi $r1,#0x240
   11ed8:	50 10 8a 30 	addi $r1,$r1,#0xa30
   11edc:	f1 85       	swi37.sp $r1,[+#0x14]
    const unsigned int ASR    = 0x1;    //MR2[6], 1'b0=manual, 1'b1=automatic
    const unsigned int CWL    = 0x1;    //MR2[5:3], 3'b000 = 5, 3'b001 = 6, 3'b010 =7, 3'b011 = 8, 3'b100 =9, 
    // 3'b101 = 10, 3'b110 = 11, 3'b111 =12
    const unsigned int PASR   = 0x0;   //MR2[2:0] PASR Partial Array Self Refresh  

    reg0C_value =
   11ede:	44 10 00 48 	movi $r1,#0x48
   11ee2:	f1 86       	swi37.sp $r1,[+#0x18]
#endif




    reg10_value =
   11ee4:	46 12 00 00 	sethi $r1,#0x20000
   11ee8:	50 10 80 55 	addi $r1,$r1,#0x55
   11eec:	f1 87       	swi37.sp $r1,[+#0x1c]
    const unsigned int TRFC = 0x24;  
    const unsigned int TFAW = 0xe;  
    const unsigned int TRC  = 0x10;  
    const unsigned int TRAS = 0xb;    

    reg14_value = 
   11eee:	46 12 40 e1 	sethi $r1,#0x240e1
   11ef2:	8c 2b       	addi45 $r1,#0xb
   11ef4:	f1 88       	swi37.sp $r1,[+#0x20]
    const unsigned int TMRD = 0x1;      
    const unsigned int TRP  = 0x4;   
    const unsigned int TRRD = 0x3;          
    const unsigned int TRCD = 0x4;    

    reg18_value = 
   11ef6:	46 14 29 51 	sethi $r1,#0x42951
   11efa:	50 10 84 34 	addi $r1,$r1,#0x434
   11efe:	f1 89       	swi37.sp $r1,[+#0x24]
    // Refresh interval = TREFI(32 x 0x0f) x MCLK cycle(500MHz->2ns) x Post Refresh Cnt(4) = 3840ns
    // Requirement. Commercial: 7800ns, Industrial: 3900ns
    const unsigned int TREFI      = 0x0f;
    //const unsigned int TREFI      = 0x03;

    reg1C_value =
   11f00:	44 10 20 0f 	movi $r1,#0x200f
   11f04:	f1 8a       	swi37.sp $r1,[+#0x28]
    const unsigned int AUTO_IO_CTRL_PDN = 0x0;
    const unsigned int ODTMD_DQS            = 0x1;
    const unsigned int SIO              = 0x0;       
    const unsigned int ODTMD_DQ            = 0x1;

    reg20_value =   
   11f06:	44 10 1f 11 	movi $r1,#0x1f11
   11f0a:	f1 8b       	swi37.sp $r1,[+#0x2c]
    const unsigned int DLLSEL_B3 = 0x7;
    const unsigned int DLLSEL_B2 = 0x7;
    const unsigned int DLLSEL_B1 = 0x7;
    const unsigned int DLLSEL_B0 = 0x7;
#endif
    reg24_value =
   11f0c:	46 17 77 77 	sethi $r1,#0x77777
   11f10:	50 10 87 77 	addi $r1,$r1,#0x777
   11f14:	f1 8c       	swi37.sp $r1,[+#0x30]
    //const unsigned int Burst_orient_ch_true = 0xd5;  // 1101 0101
    const unsigned int Burst_orient_ch_true = 0xff;  // 1101 0101
    const unsigned int Ch_hi_prior = 0x00;  //High priority: 0, 2, 5, 6, 7
    const unsigned int Reorder_burst_en = 0x00;

    reg30_value =
   11f16:	46 11 60 0f 	sethi $r1,#0x1600f
   11f1a:	50 10 8f 00 	addi $r1,$r1,#0xf00
   11f1e:	f1 8d       	swi37.sp $r1,[+#0x34]
    const unsigned int GrantCnt0 = 0x6;
    const unsigned int GrantCnt1 = 0x5;
    const unsigned int GrantCnt2 = 0x5;
    const unsigned int GrantCnt3 = 0xf;

    reg34_value =
   11f20:	46 10 f0 50 	sethi $r1,#0xf050
   11f24:	50 10 85 06 	addi $r1,$r1,#0x506
   11f28:	f1 8e       	swi37.sp $r1,[+#0x38]
    const unsigned int GrantCnt4 = 0x5;
    const unsigned int GrantCnt5 = 0x3;
    const unsigned int GrantCnt6 = 0x8;
    const unsigned int GrantCnt7 = 0x5;

    reg38_value =
   11f2a:	46 10 50 80 	sethi $r1,#0x5080
   11f2e:	50 10 83 05 	addi $r1,$r1,#0x305
   11f32:	f1 8f       	swi37.sp $r1,[+#0x3c]
    const unsigned int cf_tphy_wrlat  = 0x2;
    const unsigned int cf_tphy_wrdata = 0x1;
    const unsigned int cf_trddata_en  = 0x2; 
    const unsigned int cf_tphy_rdlat  = 0x0;

    reg3C_value =   
   11f34:	44 12 00 12 	movi $r1,#0x20012
   11f38:	f1 90       	swi37.sp $r1,[+#0x40]
    //--------------------   
    const unsigned int debug_int_en = 0x0;
    const unsigned int flush_int_en = 0xaa;
    const unsigned int flush_en = 0x0;

    reg40_value =
   11f3a:	44 10 aa 00 	movi $r1,#0xaa00
   11f3e:	f1 91       	swi37.sp $r1,[+#0x44]
    const unsigned int CH4_hprot_sel     = 0x01;  
    const unsigned int CH5_hprot_sel     = 0x01;  
    const unsigned int CH6_hprot_sel     = 0x01;  
    const unsigned int CH7_hprot_sel     = 0x01;

    reg48_value =
   11f40:	46 10 05 55 	sethi $r1,#0x555
   11f44:	50 10 85 00 	addi $r1,$r1,#0x500
   11f48:	f1 92       	swi37.sp $r1,[+#0x48]
    const unsigned int wlevel_byte1_hw_disable = 0x1;
    const unsigned int wlevel_byte0_hw_disable = 0x1;
#endif
    const unsigned int tWLO = 0x6;   

    reg60_value =
   11f4a:	46 10 0f f0 	sethi $r1,#0xff0
   11f4e:	8c 26       	addi45 $r1,#0x6

    const unsigned int ZQ_update = 0x0; 
    const unsigned int tWEVEL_UP = 0x0; 
    const unsigned int tDLL_UP   = 0x0;

    reg4C_value =
   11f50:	f0 93       	swi37.sp $r0,[+#0x4c]
    const unsigned int wlevel_byte1_hw_disable = 0x1;
    const unsigned int wlevel_byte0_hw_disable = 0x1;
#endif
    const unsigned int tWLO = 0x6;   

    reg60_value =
   11f52:	f1 94       	swi37.sp $r1,[+#0x50]
    const unsigned int rlevel_byte2_hw_disable = 0x1;
    const unsigned int rlevel_byte1_hw_disable = 0x1;
    const unsigned int rlevel_byte0_hw_disable = 0x1;
#endif
	
    reg70_value =
   11f54:	44 10 00 ff 	movi $r1,#0xff
    const unsigned int PDL_set_B7 = 0x0;  //bit[30:24]
    const unsigned int PDL_set_B6 = 0x0;  //bit[22:16]
    const unsigned int PDL_set_B5 = 0x0;  //bit[14:8]
    const unsigned int PDL_set_B4 = 0x0;  //bit[6:0]

    reg64_value =
   11f58:	f0 95       	swi37.sp $r0,[+#0x54]
    const unsigned int PDL_set_B3 = 0x0;  //bit[30:24]
    const unsigned int PDL_set_B2 = 0x0;  //bit[22:16]
    const unsigned int PDL_set_B1 = 0x0;  //bit[14:8]
    const unsigned int PDL_set_B0 = 0x0;  //bit[6:0]

    reg68_value =
   11f5a:	f0 96       	swi37.sp $r0,[+#0x58]
    const unsigned int dqs_sel_wr_byte1 = 0x0; //bit[5]
    const unsigned int dqs_sel_byte1    = 0x0; //bit[4]
    const unsigned int dqs_sel_wr_byte0 = 0x0; //bit[1]
    const unsigned int dqs_sel_byte0    = 0x0; //bit[0]

    reg6C_value =
   11f5c:	f0 97       	swi37.sp $r0,[+#0x5c]
    const unsigned int rlevel_byte2_hw_disable = 0x1;
    const unsigned int rlevel_byte1_hw_disable = 0x1;
    const unsigned int rlevel_byte0_hw_disable = 0x1;
#endif
	
    reg70_value =
   11f5e:	f1 98       	swi37.sp $r1,[+#0x60]
    const unsigned int msdly_byte3 = 0x1; 
    const unsigned int msdly_byte2 = 0x1; 
    const unsigned int msdly_byte1 = 0x1; 
    const unsigned int msdly_byte0 = 0x1; 

    reg74_value =
   11f60:	46 11 11 11 	sethi $r1,#0x11111
   11f64:	50 10 81 11 	addi $r1,$r1,#0x111
   11f68:	f1 99       	swi37.sp $r1,[+#0x64]
    const unsigned int wrdll_sel_byte3 = 0x0; 
    const unsigned int wrdll_sel_byte2 = 0x0; 
    const unsigned int wrdll_sel_byte1 = 0x0; 
    const unsigned int wrdll_sel_byte0 = 0x0; 

    reg78_value =
   11f6a:	f0 9a       	swi37.sp $r0,[+#0x68]
    // --- Offset 0x7C ---
    //--------------------   

    const unsigned int TM_cycle_reg = 0x0; 

    reg7C_value = TM_cycle_reg;
   11f6c:	f0 9b       	swi37.sp $r0,[+#0x6c]
    const unsigned int CH2_pref_value   = 0x1;
    const unsigned int CH2_limited_pref = 0x1;  
    const unsigned int CH3_pref_value   = 0x1;
    const unsigned int CH3_limited_pref = 0x1;  

    regA0_value =
   11f6e:	46 08 18 18 	sethi $r0,#0x81818
   11f72:	50 00 01 81 	addi $r0,$r0,#0x181
   11f76:	f0 9c       	swi37.sp $r0,[+#0x70]
    const unsigned int CH6_pref_value   = 0x1;
    const unsigned int CH6_limited_pref = 0x1;  
    const unsigned int CH7_pref_value   = 0x1;
    const unsigned int CH7_limited_pref = 0x1;  

    regA4_value =
   11f78:	f0 9d       	swi37.sp $r0,[+#0x74]
    //--------------------

    //wait_cycle_200us = 20'h1a0ab;
    const unsigned int wait_cycle_200us = 0x00200;

    regA8_value = wait_cycle_200us;
   11f7a:	44 00 02 00 	movi $r0,#0x200
   11f7e:	f0 9e       	swi37.sp $r0,[+#0x78]
    //--------------------

    //wait_cycle_500us = 20'h61a80;
    const unsigned int wait_cycle_500us = 0x1f000;

    regAC_value = wait_cycle_500us;
   11f80:	44 01 f0 00 	movi $r0,#0x1f000
   11f84:	f0 9f       	swi37.sp $r0,[+#0x7c]
    const unsigned int QoS_Period = 0x1; //0: 512 cycles
    //1: 1024 cycles
    //2: 2048 cycles
    //3: 4096 cycles  

    regB0_value=
   11f86:	84 02       	movi55 $r0,#0x2
   11f88:	f0 a0       	swi37.sp $r0,[+#0x80]
    const unsigned int ch2_QoS_CmdCnt = 0x3;
    const unsigned int ch1_QoS_CmdCnt = 0x4;
    const unsigned int ch0_QoS_CmdCnt = 0x4;


    regB4_value=
   11f8a:	46 00 30 30 	sethi $r0,#0x3030
   11f8e:	50 00 04 04 	addi $r0,$r0,#0x404
   11f92:	f0 a1       	swi37.sp $r0,[+#0x84]
    const unsigned int ch6_QoS_CmdCnt = 0x1;
    const unsigned int ch5_QoS_CmdCnt = 0x2;
    const unsigned int ch4_QoS_CmdCnt = 0x2;


    regB8_value=
   11f94:	46 00 10 10 	sethi $r0,#0x1010
   11f98:	50 00 02 02 	addi $r0,$r0,#0x202
   11f9c:	f0 a2       	swi37.sp $r0,[+#0x88]
    | (ch4_QoS_CmdCnt);




    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;
   11f9e:	f1 03       	lwi37.sp $r1,[+#0xc]
   11fa0:	46 0f 05 00 	sethi $r0,#0xf0500
   11fa4:	b6 20       	swi450 $r1,[$r0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x04) = reg04_value;
   11fa6:	f1 04       	lwi37.sp $r1,[+#0x10]
   11fa8:	a8 41       	swi333 $r1,[$r0+#0x4]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x08) = reg08_value;
   11faa:	f1 05       	lwi37.sp $r1,[+#0x14]
   11fac:	a8 42       	swi333 $r1,[$r0+#0x8]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x0C) = reg0C_value;  
   11fae:	f1 06       	lwi37.sp $r1,[+#0x18]
   11fb0:	a8 43       	swi333 $r1,[$r0+#0xc]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x10) = reg10_value;
   11fb2:	f1 07       	lwi37.sp $r1,[+#0x1c]
   11fb4:	a8 44       	swi333 $r1,[$r0+#0x10]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x14) = reg14_value;
   11fb6:	f1 08       	lwi37.sp $r1,[+#0x20]
   11fb8:	a8 45       	swi333 $r1,[$r0+#0x14]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x18) = reg18_value;
   11fba:	f1 09       	lwi37.sp $r1,[+#0x24]
   11fbc:	a8 46       	swi333 $r1,[$r0+#0x18]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x1c) = reg1C_value;
   11fbe:	f1 0a       	lwi37.sp $r1,[+#0x28]
   11fc0:	a8 47       	swi333 $r1,[$r0+#0x1c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x20) = reg20_value;
   11fc2:	f1 0b       	lwi37.sp $r1,[+#0x2c]
   11fc4:	83 80       	mov55 $fp,$r0
   11fc6:	b9 88       	swi37 $r1,[$fp+#0x20]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   11fc8:	f1 0c       	lwi37.sp $r1,[+#0x30]
   11fca:	b9 89       	swi37 $r1,[$fp+#0x24]
    //*(volatile unsigned int *) (DDR_REG_BASE + 0x28) = reg28_value;
    //*(volatile unsigned int *) (DDR_REG_BASE + 0x2C) = reg2C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x30) = reg30_value;
   11fcc:	f1 0d       	lwi37.sp $r1,[+#0x34]
   11fce:	b9 8c       	swi37 $r1,[$fp+#0x30]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x34) = reg34_value;
   11fd0:	f1 0e       	lwi37.sp $r1,[+#0x38]
   11fd2:	b9 8d       	swi37 $r1,[$fp+#0x34]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x38) = reg38_value;
   11fd4:	f1 0f       	lwi37.sp $r1,[+#0x3c]
   11fd6:	b9 8e       	swi37 $r1,[$fp+#0x38]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x3C) = reg3C_value;
   11fd8:	f1 10       	lwi37.sp $r1,[+#0x40]
   11fda:	b9 8f       	swi37 $r1,[$fp+#0x3c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x40) = reg40_value;
   11fdc:	f1 11       	lwi37.sp $r1,[+#0x44]
   11fde:	b9 90       	swi37 $r1,[$fp+#0x40]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x48) = reg48_value;
   11fe0:	f1 12       	lwi37.sp $r1,[+#0x48]
   11fe2:	b9 92       	swi37 $r1,[$fp+#0x48]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x4C) = reg4C_value;
   11fe4:	f1 13       	lwi37.sp $r1,[+#0x4c]
   11fe6:	b9 93       	swi37 $r1,[$fp+#0x4c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x60) = reg60_value;
   11fe8:	f1 14       	lwi37.sp $r1,[+#0x50]
   11fea:	b9 98       	swi37 $r1,[$fp+#0x60]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x64) = reg64_value;
   11fec:	f1 15       	lwi37.sp $r1,[+#0x54]
   11fee:	b9 99       	swi37 $r1,[$fp+#0x64]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   11ff0:	f1 16       	lwi37.sp $r1,[+#0x58]
   11ff2:	b9 9a       	swi37 $r1,[$fp+#0x68]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   11ff4:	f1 17       	lwi37.sp $r1,[+#0x5c]
   11ff6:	b9 9b       	swi37 $r1,[$fp+#0x6c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x70) = reg70_value;
   11ff8:	f1 18       	lwi37.sp $r1,[+#0x60]
   11ffa:	b9 9c       	swi37 $r1,[$fp+#0x70]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   11ffc:	f1 19       	lwi37.sp $r1,[+#0x64]
   11ffe:	b9 9d       	swi37 $r1,[$fp+#0x74]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   12000:	f1 1a       	lwi37.sp $r1,[+#0x68]
   12002:	b9 9e       	swi37 $r1,[$fp+#0x78]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x7C) = reg7C_value;
   12004:	f1 1b       	lwi37.sp $r1,[+#0x6c]
   12006:	b9 9f       	swi37 $r1,[$fp+#0x7c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xa0) = regA0_value;
   12008:	f1 1c       	lwi37.sp $r1,[+#0x70]
   1200a:	b9 a8       	swi37 $r1,[$fp+#0xa0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xa4) = regA4_value;
   1200c:	f1 1d       	lwi37.sp $r1,[+#0x74]
   1200e:	b9 a9       	swi37 $r1,[$fp+#0xa4]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xa8) = regA8_value;
   12010:	f1 1e       	lwi37.sp $r1,[+#0x78]
   12012:	b9 aa       	swi37 $r1,[$fp+#0xa8]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xaC) = regAC_value;
   12014:	f1 1f       	lwi37.sp $r1,[+#0x7c]
   12016:	b9 ab       	swi37 $r1,[$fp+#0xac]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xb0) = regB0_value;
   12018:	f1 20       	lwi37.sp $r1,[+#0x80]
   1201a:	b9 ac       	swi37 $r1,[$fp+#0xb0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xb4) = regB4_value;
   1201c:	f1 21       	lwi37.sp $r1,[+#0x84]
   1201e:	b9 ad       	swi37 $r1,[$fp+#0xb4]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xb8) = regB8_value;
   12020:	f1 22       	lwi37.sp $r1,[+#0x88]
   12022:	b9 ae       	swi37 $r1,[$fp+#0xb8]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x138) = 0x5;
   12024:	84 25       	movi55 $r1,#0x5
   12026:	b9 ce       	swi37 $r1,[$fp+#0x138]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x134) = 0x00304444;
   12028:	46 10 03 04 	sethi $r1,#0x304
   1202c:	50 10 84 44 	addi $r1,$r1,#0x444
   12030:	b9 cd       	swi37 $r1,[$fp+#0x134]
   12032:	44 20 00 32 	movi $r2,#0x32

    //wait 500us
    for(i=0;i<50;i++)
    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;
   12036:	f3 03       	lwi37.sp $r3,[+#0xc]
   12038:	8e 41       	subi45 $r2,#0x1
   1203a:	46 1f 05 00 	sethi $r1,#0xf0500
   1203e:	b6 60       	swi450 $r3,[$r0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x138) = 0x5;

    *(volatile unsigned int *) (DDR_REG_BASE + 0x134) = 0x00304444;

    //wait 500us
    for(i=0;i<50;i++)
   12040:	ca fb       	bnez38 $r2,12036 <ddr3_set+0x1f4>
    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;

    MemCmd_initial = 0x1;
   12042:	84 01       	movi55 $r0,#0x1
   12044:	f0 a3       	swi37.sp $r0,[+#0x8c]
    reg04_value =
    (MRS_mode        << 4)
    | (MemCmd_exit_srf << 3)
    | (MemCmd_srf      << 2)
| (MemCmd_mrs      << 1)
    | (MemCmd_initial); 
   12046:	f0 23       	lwi37.sp $r0,[+#0x8c]
    for(i=0;i<50;i++)
    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;

    MemCmd_initial = 0x1;

    reg04_value =
   12048:	f0 84       	swi37.sp $r0,[+#0x10]
    | (MemCmd_exit_srf << 3)
    | (MemCmd_srf      << 2)
| (MemCmd_mrs      << 1)
    | (MemCmd_initial); 

    *(volatile unsigned int *) (DDR_REG_BASE + 0x04) = reg04_value;
   1204a:	f0 04       	lwi37.sp $r0,[+#0x10]
   1204c:	a8 09       	swi333 $r0,[$r1+#0x4]

    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);

while ( (data & 0x100) != 0x100) 
    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);
   1204e:	a0 09       	lwi333 $r0,[$r1+#0x4]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x04) = reg04_value;

    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);

while ( (data & 0x100) != 0x100) 
   12050:	54 00 01 00 	andi $r0,$r0,#0x100
   12054:	c0 fd       	beqz38 $r0,1204e <ddr3_set+0x20c>
    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);

    //DDR test write & verify
    *(volatile unsigned int *) (DDR_MEM_BASE) = 0x01020304; data = *(volatile unsigned int *) (DDR_MEM_BASE);
   12056:	46 00 10 20 	sethi $r0,#0x1020
   1205a:	46 12 00 00 	sethi $r1,#0x20000
   1205e:	50 00 03 04 	addi $r0,$r0,#0x304
   12062:	b6 01       	swi450 $r0,[$r1]
   12064:	b4 a1       	lwi450 $r5,[$r1]
if (data == 0x01020304)
   12066:	d8 06       	bnes38 $r0,12072 <ddr3_set+0x230>
{
    *(volatile unsigned int *) (DDR_MEM_BASE) = 0x89abcdef;
   12068:	46 08 9a bc 	sethi $r0,#0x89abc
   1206c:	50 00 0d ef 	addi $r0,$r0,#0xdef
   12070:	b6 01       	swi450 $r0,[$r1]
   12072:	fc 92       	pop25 $r6,#144    ! {$r6, $fp, $gp, $lp}

00012074 <memcmp>:
   12074:	40 51 08 09 	srli $r5,$r2,#0x2
   12078:	c5 0f       	beqz38 $r5,12096 <memcmp+0x22>
   1207a:	95 6a       	slli333 $r5,$r5,#0x2
   1207c:	99 68       	add333 $r5,$r5,$r0
   1207e:	96 8f       	fexti33 $r2,#0x1
   12080:	3a 30 0c 04 	lmw.bim $r3,[$r0],$r3,#0x0    ! {$r3}
   12084:	3a 40 90 04 	lmw.bim $r4,[$r1],$r4,#0x0    ! {$r4}
   12088:	4c 32 40 04 	bne $r3,$r4,12090 <memcmp+0x1c>
   1208c:	d8 fa       	bnes38 $r0,12080 <memcmp+0xc>
   1208e:	d5 04       	j8 12096 <memcmp+0x22>
   12090:	8e 04       	subi45 $r0,#0x4
   12092:	8e 24       	subi45 $r1,#0x4
   12094:	8c 44       	addi45 $r2,#0x4
   12096:	99 42       	add333 $r5,$r0,$r2
   12098:	d0 09       	beqs38 $r0,120aa <memcmp+0x36>
   1209a:	08 30 00 01 	lbi.bi $r3,[$r0],#0x1
   1209e:	08 40 80 01 	lbi.bi $r4,[$r1],#0x1
   120a2:	4c 32 3f fb 	beq $r3,$r4,12098 <memcmp+0x24>
   120a6:	9a 1c       	sub333 $r0,$r3,$r4
   120a8:	dd 9e       	ret5 $lp
   120aa:	84 00       	movi55 $r0,#0x0
   120ac:	dd 9e       	ret5 $lp
   120ae:	92 00       	nop16

000120b0 <memcpy>:
   120b0:	80 60       	mov55 $r3,$r0
   120b2:	40 51 08 09 	srli $r5,$r2,#0x2
   120b6:	4e 52 00 0a 	beqz $r5,120ca <memcpy+0x1a>
   120ba:	95 6a       	slli333 $r5,$r5,#0x2
   120bc:	99 69       	add333 $r5,$r5,$r1
   120be:	96 8f       	fexti33 $r2,#0x1
   120c0:	3a 40 90 04 	lmw.bim $r4,[$r1],$r4,#0x0    ! {$r4}
   120c4:	3a 41 90 24 	smw.bim $r4,[$r3],$r4,#0x0    ! {$r4}
   120c8:	d9 fc       	bnes38 $r1,120c0 <memcpy+0x10>
   120ca:	c2 08       	beqz38 $r2,120da <memcpy+0x2a>
   120cc:	40 50 88 00 	add $r5,$r1,$r2
   120d0:	08 40 80 01 	lbi.bi $r4,[$r1],#0x1
   120d4:	18 41 80 01 	sbi.bi $r4,[$r3],#0x1
   120d8:	d9 fc       	bnes38 $r1,120d0 <memcpy+0x20>
   120da:	dd 9e       	ret5 $lp

000120dc <memset>:
   120dc:	80 60       	mov55 $r3,$r0
   120de:	40 51 08 09 	srli $r5,$r2,#0x2
   120e2:	96 8f       	fexti33 $r2,#0x1
   120e4:	c5 0d       	beqz38 $r5,120fe <memset+0x22>
   120e6:	95 6a       	slli333 $r5,$r5,#0x2
   120e8:	99 5d       	add333 $r5,$r3,$r5
   120ea:	96 48       	zeb33 $r1,$r1
   120ec:	40 40 a0 08 	slli $r4,$r1,#0x8
   120f0:	fe 67       	or33 $r1,$r4
   120f2:	40 40 c0 08 	slli $r4,$r1,#0x10
   120f6:	fe 67       	or33 $r1,$r4
   120f8:	3a 11 84 24 	smw.bim $r1,[$r3],$r1,#0x0    ! {$r1}
   120fc:	db fe       	bnes38 $r3,120f8 <memset+0x1c>
   120fe:	99 5a       	add333 $r5,$r3,$r2
   12100:	d3 04       	beqs38 $r3,12108 <memset+0x2c>
   12102:	18 11 80 01 	sbi.bi $r1,[$r3],#0x1
   12106:	d5 fd       	j8 12100 <memset+0x24>
   12108:	dd 9e       	ret5 $lp
   1210a:	92 00       	nop16
