
./bin/PI5008K_Init_ddr3.adx:     file format elf32-nds32le
./bin/PI5008K_Init_ddr3.adx
architecture: n1h_v3, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000100dc

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000018ec memsz 0x00001d00 flags rwx
private flags = 30800a52: n1 instructions

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .nds32_init   00000024  00010000  00010000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00001848  00010024  00010024  00001024  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000080  0001186c  0001186c  0000286c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000400  00011900  00011900  000028ec  2**2
                  ALLOC
  4 .comment      0000002f  00000000  00000000  000028ec  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000148  00000000  00000000  00002920  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003978  00000000  00000000  00002a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ae2  00000000  00000000  000063e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e26  00000000  00000000  00006ec2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000049c  00000000  00000000  00009ce8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000f3c4  00000000  00000000  0000a184  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000017e1  00000000  00000000  00019548  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  0001ad30  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000030c4  00000000  00000000  0001ada8  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .nds32_init	00000000 .nds32_init
00010024 l    d  .text	00000000 .text
0001186c l    d  .rodata	00000000 .rodata
00011900 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    df *ABS*	00000000 ./src/crt0.o
00010000 l       .nds32_init	00000000 exception_vector
00010024 l       .text	00000000 OS_Trap_TLB_Fill
00010024 l       .text	00000000 OS_Trap_PTE_Not_Present
00010024 l       .text	00000000 OS_Trap_TLB_Misc
00010024 l       .text	00000000 OS_Trap_TLB_VLPT_Miss
00010024 l       .text	00000000 OS_Trap_Machine_Error
00010024 l       .text	00000000 OS_Trap_Debug_Related
00010024 l       .text	00000000 OS_Trap_General_Exception
00010026 l       .text	00000000 OS_Trap_Syscall
00010024 l       .nds32_init	00000000 exception_vector_end
00000000 l    df *ABS*	00000000 init-default.c
00010128 l     F .text	00000002 Default_Handler
00000000 l    df *ABS*	00000000 cache.c
00000000 l    df *ABS*	00000000 bootloader.c
00000000 l    df *ABS*	00000000 spi.c
000118bc l     O .rodata	00000010 gpSPI
0001186c l     O .rodata	00000020 gCS_GPIO
0001188c l     O .rodata	00000030 gCS_PinMux
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 ddr_calibration.c
00010724 l     F .text	00000052 find_center
00010776 l     F .text	000000bc Write_Read_compare
00010832 l     F .text	000004de do_calibration_DQ_DQS_READ
00010d10 l     F .text	00000238 do_calibration_DQ_DQS_WRITE
00010f48 l     F .text	000001ae do_calibration_Leveling
00000000 l    df *ABS*	00000000 clock_init.c
00000000 l    df *ABS*	00000000 clock_powerdown.c
00000000 l    df *ABS*	00000000 ddr3.c
00000000 l    df *ABS*	00000000 lib_a-memcpy.o
00000000 l    df *ABS*	00000000 lib_a-memset.o
00000000 l    df *ABS*	00000000 
000115da g     F .text	00000002 fail
0001070c g     F .text	00000018 uart_inbyte
000102b6 g     F .text	00000046 pattern_test
0001047c g     F .text	000000a8 spi_xfer
0001069e g     F .text	00000012 spi_wait
000106f6 g     F .text	00000016 uart_outbyte
00011900 g     O .bss	00000400 gGlobalBuf
00010000 g       *ABS*	00000000 LOAD_BEGIN
000102fc g     F .text	0000005c bootloader_main
000101b4 g     F .text	00000050 cache_enable
00011810 g     F .text	0000002c memcpy
000115dc g     F .text	00000232 ddr3_set
000110f6 g     F .text	0000003e ddr_calibration
00010150 g     F .text	00000046 __cpu_init
0001054e g     F .text	0000001a spi_slave_tx_byte
00010630 g     F .text	00000038 spi_cs_activate
00010204 g     F .text	0000005e cache_disable
0001028c g     F .text	0000002a cache_inv_range
00010196 g     F .text	0000001e __init
00010524 g     F .text	0000002a spi_slave_tx
00001900 g       *ABS*	00000000 LOAD_SIZE
000106b0 g     F .text	00000046 uart_init
000100dc g     F .text	0000004a _start
00011b00  w      .bss	00000000 _SDA_BASE_
00010358 g     F .text	00000060 spi_initialize
00010568 g     F .text	00000026 spi_slave_rx
00010000  w      .nds32_init	00000000 _RELAX_END_
0001041a g     F .text	00000062 spi_rx
00011900 g       .bss	00000000 __bss_start
0001183c g     F .text	0000002e memset
000115c6 g     F .text	00000014 SetClockPD
000103b8 g     F .text	00000062 spi_tx
00000000  w      *ABS*	00000000 _ITB_BASE_
00011900 g       *ABS*	00000000 __data_lmastart
00011900 g       .bss	00000000 _edata
00011d00 g       .bss	00000000 _end
000105a8 g     F .text	00000088 spi_direct_cs_enable
00010262 g     F .text	0000002a cache_wb_range
0001012a g     F .text	00000026 __c_init
00010128  w    F .text	00000002 syscall_handler
00011134 g     F .text	00000098 asic_init
00013ff0 g       *ABS*	00000000 _stack
00011900 g       .rodata	00000000 __data_start
0001058e g     F .text	0000001a spi_slave_rx_byte
000111cc g     F .text	000003fa clock_powerdown
00010668 g     F .text	00000036 spi_cs_deactivate
00010000 g       *ABS*	00000000 NDS_SAG_LMA_LOAD



Disassembly of section .nds32_init:

00010000 <_RELAX_END_>:
!========================================================================
! Vector table
!========================================================================
	.align 2
exception_vector:
	j _start                    !  (0) Trap Reset
   10000:	48 00 00 6e 	j 100dc <_start>
	vector TLB_Fill             !  (1) Trap TLB fill
   10004:	48 00 00 10 	j 10024 <exception_vector_end>
	vector PTE_Not_Present      !  (2) Trap PTE not present
   10008:	48 00 00 0e 	j 10024 <exception_vector_end>
	vector TLB_Misc             !  (3) Trap TLB misc
   1000c:	48 00 00 0c 	j 10024 <exception_vector_end>
	vector TLB_VLPT_Miss        !  (4) Trap TLB VLPT miss
   10010:	48 00 00 0a 	j 10024 <exception_vector_end>
	vector Machine_Error        !  (5) Trap Machine error
   10014:	48 00 00 08 	j 10024 <exception_vector_end>
	vector Debug_Related        !  (6) Trap Debug related
   10018:	48 00 00 06 	j 10024 <exception_vector_end>
	vector General_Exception    !  (7) Trap General exception
   1001c:	48 00 00 04 	j 10024 <exception_vector_end>
	vector Syscall              !  (8) Syscall
   10020:	48 00 00 03 	j 10026 <OS_Trap_Syscall>

Disassembly of section .text:

00010024 <OS_Trap_Debug_Related>:
OS_Trap_TLB_VLPT_Miss:
OS_Trap_Machine_Error:
OS_Trap_Debug_Related:
OS_Trap_General_Exception:

1:  b   1b
   10024:	d5 00       	j8 10024 <OS_Trap_Debug_Related>

00010026 <OS_Trap_Syscall>:
OS_Trap_Syscall:
	SYSCALL_SAVE_ALL
   10026:	3a 1f a4 3c 	smw.adm $r1,[$sp],$r9,#0x0    ! {$r1~$r9}
   1002a:	3a ff ef bc 	smw.adm $r15,[$sp],$p1,#0xe    ! {$r15~$p1, $fp, $gp, $lp}
   1002e:	42 6e 80 20 	mfusr $r6,$ifc_lp
   10032:	42 7c 80 20 	mfusr $r7,$lb
   10036:	42 8d 00 20 	mfusr $r8,$le
   1003a:	42 9d 80 20 	mfusr $r9,$lc
   1003e:	3a 6f a4 3c 	smw.adm $r6,[$sp],$r9,#0x0    ! {$r6~$r9}
   10042:	3a 6f 98 3c 	smw.adm $r6,[$sp],$r6,#0x0    ! {$r6}
   10046:	64 62 a4 02 	mfsr $r6,$ipc
   1004a:	9d b4       	addi333 $r6,$r6,#0x4
   1004c:	64 72 04 02 	mfsr $r7,$ipsw
   10050:	3a 6f 9c 3c 	smw.adm $r6,[$sp],$r7,#0x0    ! {$r6~$r7}
   10054:	64 62 00 02 	mfsr $r6,$psw
   10058:	56 63 20 02 	xori $r6,$r6,#0x2002
   1005c:	64 62 00 03 	mtsr $r6,$psw
   10060:	64 00 00 08 	dsb
   10064:	51 ff ff f8 	addi $sp,$sp,#-8
   10068:	36 ff 9f fe 	fsdi.bi $fd15,[$sp],#-8
   1006c:	36 ef 9f fe 	fsdi.bi $fd14,[$sp],#-8
   10070:	36 df 9f fe 	fsdi.bi $fd13,[$sp],#-8
   10074:	36 cf 9f fe 	fsdi.bi $fd12,[$sp],#-8
   10078:	36 bf 9f fe 	fsdi.bi $fd11,[$sp],#-8
   1007c:	36 2f 9f fe 	fsdi.bi $fd2,[$sp],#-8
   10080:	36 1f 9f fe 	fsdi.bi $fd1,[$sp],#-8
   10084:	36 0f 80 00 	fsdi $fd0,[$sp+#0x0]
	bal syscall_handler
   10088:	49 00 00 50 	jal 10128 <syscall_handler>
	SYSCALL_RESTORE_ALL
   1008c:	34 0f 90 02 	fldi.bi $fd0,[$sp],#0x8
   10090:	34 1f 90 02 	fldi.bi $fd1,[$sp],#0x8
   10094:	34 2f 90 02 	fldi.bi $fd2,[$sp],#0x8
   10098:	34 bf 90 02 	fldi.bi $fd11,[$sp],#0x8
   1009c:	34 cf 90 02 	fldi.bi $fd12,[$sp],#0x8
   100a0:	34 df 90 02 	fldi.bi $fd13,[$sp],#0x8
   100a4:	34 ef 90 02 	fldi.bi $fd14,[$sp],#0x8
   100a8:	34 ff 90 02 	fldi.bi $fd15,[$sp],#0x8
   100ac:	3a 6f 9c 04 	lmw.bim $r6,[$sp],$r7,#0x0    ! {$r6~$r7}
   100b0:	64 62 a4 03 	mtsr $r6,$ipc
   100b4:	64 72 04 03 	mtsr $r7,$ipsw
   100b8:	3a 6f 98 04 	lmw.bim $r6,[$sp],$r6,#0x0    ! {$r6}
   100bc:	3a 6f a4 04 	lmw.bim $r6,[$sp],$r9,#0x0    ! {$r6~$r9}
   100c0:	42 6e 80 21 	mtusr $r6,$ifc_lp
   100c4:	42 7c 80 21 	mtusr $r7,$lb
   100c8:	42 8d 00 21 	mtusr $r8,$le
   100cc:	42 9d 80 21 	mtusr $r9,$lc
   100d0:	3a ff ef 84 	lmw.bim $r15,[$sp],$p1,#0xe    ! {$r15~$p1, $fp, $gp, $lp}
   100d4:	3a 1f a4 04 	lmw.bim $r1,[$sp],$r9,#0x0    ! {$r1~$r9}
	iret
   100d8:	64 00 00 04 	iret

000100dc <_start>:
_start:
	!************************** Begin of do-not-modify **************************
	! Please don't modify this code
	! Initialize the registers used by the compiler

	nds32_init		! NDS32 startup initial macro in <nds32_init.inc>
   100dc:	45 d1 1b 00 	movi $gp,#0x11b00
   100e0:	64 00 80 02 	mfsr $r0,$msc_cfg
   100e4:	46 10 10 00 	sethi $r1,#0x1000
   100e8:	40 20 04 02 	and $r2,$r0,$r1
   100ec:	c2 04       	beqz38 $r2,100f4 <_start+0x18>
   100ee:	84 00       	movi55 $r0,#0x0
   100f0:	42 0e 00 21 	mtusr $r0,$itb
   100f4:	64 08 a0 02 	mfsr $r0,$fucpr
   100f8:	58 00 00 01 	ori $r0,$r0,#0x1
   100fc:	64 08 a0 03 	mtsr $r0,$fucpr
   10100:	64 00 00 08 	dsb
   10104:	6a 00 07 01 	fmfcsr $r0
   10108:	58 00 10 00 	ori $r0,$r0,#0x1000
   1010c:	6a 00 07 09 	fmtcsr $r0
   10110:	64 00 00 08 	dsb
   10114:	45 f1 3f f0 	movi $sp,#0x13ff0

#endif //#ifdef CFG_DEBUG

	!*************************** End of do-not-modify ***************************

	bal __init
   10118:	49 00 00 3f 	jal 10196 <__init>
	bal bootloader_main
   1011c:	49 00 00 f0 	jal 102fc <bootloader_main>
	
	beqz $r0, 1f
   10120:	c0 02       	beqz38 $r0,10124 <_start+0x48>

	jr	$r0
   10122:	dd 00       	jr5 $r0

1:  b   1b
   10124:	d5 00       	j8 10124 <_start+0x48>
   10126:	92 00       	nop16

00010128 <syscall_handler>:
#pragma weak syscall_handler         = Default_Handler

__attribute__((unused))
static void Default_Handler()
{
	while (1) ;
   10128:	d5 00       	j8 10128 <syscall_handler>

0001012a <__c_init>:
}

void __c_init()
{
   1012a:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	extern char _end;
	int size;

	/* Copy data section from ROM to RAM*/
	size = &_edata - &__data_start;
	MEMCPY(&__data_start, &__data_lmastart, size);
   1012c:	44 01 19 00 	movi $r0,#0x11900
   10130:	44 21 19 00 	movi $r2,#0x11900
   10134:	44 11 19 00 	movi $r1,#0x11900
   10138:	8a 40       	sub45 $r2,$r0
   1013a:	49 00 0b 6b 	jal 11810 <memcpy>

	/* Clear bss section */
	size = &_end - &__bss_start;
	MEMSET(&__bss_start, 0, size);
   1013e:	44 01 19 00 	movi $r0,#0x11900
   10142:	44 21 1d 00 	movi $r2,#0x11d00
   10146:	84 20       	movi55 $r1,#0x0
   10148:	8a 40       	sub45 $r2,$r0
   1014a:	49 00 0b 79 	jal 1183c <memset>
   1014e:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

00010150 <__cpu_init>:
{
	unsigned int tmp;

	/* turn on BTB */
	tmp = 0x0;
	__nds32__mtsr(tmp, NDS32_SR_MISC_CTL);
   10150:	84 00       	movi55 $r0,#0x0
   10152:	64 05 e4 03 	mtsr $r0,$misc_ctl

	/* disable all hardware interrupts */
	__nds32__mtsr(0x0, NDS32_SR_INT_MASK);
   10156:	64 03 00 03 	mtsr $r0,$int_mask
	/* INT_MASK2 only exists when IVB.IVIC_VER=1 */
	if (__nds32__mfsr(NDS32_SR_IVB) & (0x1 << 11))
   1015a:	64 12 24 02 	mfsr $r1,$ivb
   1015e:	54 10 88 00 	andi $r1,$r1,#0x800
   10162:	c1 03       	beqz38 $r1,10168 <__cpu_init+0x18>
		__nds32__mtsr(0x0, NDS32_SR_INT_MASK2);
   10164:	64 03 04 03 	mtsr $r0,$int_mask2
	tmp |= (1 << 14);	// set vector size: 16 bytes
#endif
#ifdef CFG_EVIC
	tmp |= (1 << 13);	// set EVIC
#endif
	__nds32__mtsr(tmp, NDS32_SR_IVB);
   10168:	44 01 00 00 	movi $r0,#0x10000
   1016c:	64 02 24 03 	mtsr $r0,$ivb


	/* Set PSW */
	/* set PSW.INTL to 0 and PSW.CPL to 7 to allow any priority */
	tmp = __nds32__mfsr(NDS32_SR_PSW);
   10170:	64 02 00 02 	mfsr $r0,$psw
	tmp &= 0xfffffff9;
   10174:	66 00 00 06 	bitci $r0,$r0,#0x6
	tmp |= 0x70008;
#ifdef CFG_HWZOL
	/* Enable PSW AEN */
	tmp = tmp | 0x2000;
   10178:	44 17 20 08 	movi $r1,#0x72008
   1017c:	fe 0f       	or33 $r0,$r1
#endif
	__nds32__mtsr_dsb(tmp, NDS32_SR_PSW);
   1017e:	64 02 00 03 	mtsr $r0,$psw
   10182:	64 00 00 08 	dsb
	/* Check interrupt priority programmable*
	* IVB.PROG_PRI_LVL
	*      0: Fixed priority       -- no exist ir18 1r19
	*      1: Programmable priority
	*/
	if (__nds32__mfsr(NDS32_SR_IVB) & 0x01) {
   10186:	64 02 24 02 	mfsr $r0,$ivb
   1018a:	96 04       	xlsb33 $r0,$r0
   1018c:	c0 04       	beqz38 $r0,10194 <__cpu_init+0x44>
		/* Set PPL2FIX_EN to 0 to enable Programmable
	 	* Priority Level */
		__nds32__mtsr(0x0, NDS32_SR_INT_CTRL);
   1018e:	84 00       	movi55 $r0,#0x0
   10190:	64 02 28 03 	mtsr $r0,$int_ctrl
   10194:	dd 9e       	ret5 $lp

00010196 <__init>:
	return;
}


void __init()
{
   10196:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
/*----------------------------------------------------------
   !!  Users should NOT add any code before this comment  !!
------------------------------------------------------------*/
	__cpu_init();
   10198:	49 ff ff dc 	jal 10150 <__cpu_init>
	__c_init();     //copy data section, clean bss
   1019c:	49 ff ff c7 	jal 1012a <__c_init>
	 * Check whether the CPU configured with ZOL supported.
	 * The MSC_CFG.MSC_EXT($cr4) indicates MSC_CFG2 register exist
	 * and MSC_CFG2($cr7) bit 5 indicates ZOL supporting.
	 */
#ifdef CFG_HWZOL
	if (!((__nds32__mfsr(NDS32_SR_MSC_CFG) & (3 << 30))
   101a0:	64 00 80 02 	mfsr $r0,$msc_cfg
   101a4:	92 1e       	srli45 $r0,#0x1e
   101a6:	c0 05       	beqz38 $r0,101b0 <__init+0x1a>
	    && (__nds32__mfsr(NDS32_SR_MSC_CFG2) & (1 << 5)))) {
   101a8:	64 00 84 02 	mfsr $r0,$msc_cfg2
   101ac:	96 2e       	bmski33 $r0,#0x5
	 * Check whether the CPU configured with ZOL supported.
	 * The MSC_CFG.MSC_EXT($cr4) indicates MSC_CFG2 register exist
	 * and MSC_CFG2($cr7) bit 5 indicates ZOL supporting.
	 */
#ifdef CFG_HWZOL
	if (!((__nds32__mfsr(NDS32_SR_MSC_CFG) & (3 << 30))
   101ae:	c8 02       	bnez38 $r0,101b2 <__init+0x1c>
	    && (__nds32__mfsr(NDS32_SR_MSC_CFG2) & (1 << 5)))) {
		/* CPU doesn't support ZOL, but build with ZOL supporting. */
		//uart_puts("CPU doesn't support ZOL, but build with ZOL supporting !!\n");
		while(1);
   101b0:	d5 00       	j8 101b0 <__init+0x1a>
   101b2:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000101b4 <cache_enable>:
{

	unsigned int cache_ctl=0, mmu_ctl, icm_cfg, dcm_cfg;

	/* Get ICache ways, sets, line size  */
	icm_cfg = __nds32__mfsr(NDS32_SR_ICM_CFG);
   101b4:	64 00 20 02 	mfsr $r0,$icm_cfg

	if (((icm_cfg & NDS32_ISIZE) >> 6) && ((icm_cfg & NDS32_ISIZE) >> 6) <= 5){
   101b8:	54 00 01 c0 	andi $r0,$r0,#0x1c0
   101bc:	92 06       	srli45 $r0,#0x6
   101be:	8e 01       	subi45 $r0,#0x1
   101c0:	e6 05       	slti45 $r0,#0x5
   101c2:	e8 07       	beqzs8 101d0 <cache_enable+0x1c>
		cache_ctl = __nds32__mfsr(NDS32_SR_CACHE_CTL);
   101c4:	64 05 00 02 	mfsr $r0,$cache_ctl
		cache_ctl |= 0x1;
   101c8:	58 00 00 01 	ori $r0,$r0,#0x1

		/* Enable I Cache */
		__nds32__mtsr(cache_ctl, NDS32_SR_CACHE_CTL);
   101cc:	64 05 00 03 	mtsr $r0,$cache_ctl

	}

	/* Get DCache ways, sets, line size  */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
   101d0:	64 00 40 02 	mfsr $r0,$dcm_cfg

	if (((dcm_cfg & NDS32_DSIZE) >> 6) && ((dcm_cfg & NDS32_DSIZE) >> 6) <= 5){
   101d4:	54 00 01 c0 	andi $r0,$r0,#0x1c0
   101d8:	92 06       	srli45 $r0,#0x6
   101da:	8e 01       	subi45 $r0,#0x1
   101dc:	e6 05       	slti45 $r0,#0x5
   101de:	e8 07       	beqzs8 101ec <cache_enable+0x38>
		cache_ctl = __nds32__mfsr(NDS32_SR_CACHE_CTL);
   101e0:	64 05 00 02 	mfsr $r0,$cache_ctl
		cache_ctl |= 0x2;
   101e4:	58 00 00 02 	ori $r0,$r0,#0x2
		/* Enable D Cache */
		__nds32__mtsr(cache_ctl, NDS32_SR_CACHE_CTL);
   101e8:	64 05 00 03 	mtsr $r0,$cache_ctl
	}

	/* Cacheable/Write-Back for NTC0 */
	mmu_ctl = __nds32__mfsr(NDS32_SR_MMU_CTL);
   101ec:	64 14 00 02 	mfsr $r1,$mmu_ctl
	mmu_ctl &= (~(0x3<<1));
	mmu_ctl |= (0x2 << 1);

	/* Set NTC2(Non-cacheable/Non-coalesable) to PA partition 0*/
	mmu_ctl &= (~(0x3<<5));
	mmu_ctl &= (~(0x3<<15));
   101f0:	44 0e 7f 99 	movi $r0,#-98407
   101f4:	fe 0e       	and33 $r0,$r1
   101f6:	58 00 00 04 	ori $r0,$r0,#0x4

	
	__nds32__mtsr_isb(mmu_ctl, NDS32_SR_MMU_CTL);
   101fa:	64 04 00 03 	mtsr $r0,$mmu_ctl
   101fe:	64 00 00 09 	isb
   10202:	dd 9e       	ret5 $lp

00010204 <cache_disable>:
{
#ifndef __NDS32_ISA_V3M__
	unsigned int dcm_cfg, cache_line, end;

	/* Check if cache available */
	if (!(__nds32__mfsr(NDS32_SR_ICM_CFG) & NDS32_ISIZE) ||
   10204:	64 00 20 02 	mfsr $r0,$icm_cfg
   10208:	54 00 01 c0 	andi $r0,$r0,#0x1c0
   1020c:	c0 2a       	beqz38 $r0,10260 <cache_disable+0x5c>
	    !(__nds32__mfsr(NDS32_SR_CACHE_CTL) & 0x3))
   1020e:	64 05 00 02 	mfsr $r0,$cache_ctl
   10212:	96 0f       	fexti33 $r0,#0x1
{
#ifndef __NDS32_ISA_V3M__
	unsigned int dcm_cfg, cache_line, end;

	/* Check if cache available */
	if (!(__nds32__mfsr(NDS32_SR_ICM_CFG) & NDS32_ISIZE) ||
   10214:	c0 26       	beqz38 $r0,10260 <cache_disable+0x5c>
	    !(__nds32__mfsr(NDS32_SR_CACHE_CTL) & 0x3))
		return;

	/* DCache end = cache line size * cache set * cache way. */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
   10216:	64 10 40 02 	mfsr $r1,$dcm_cfg
	end = cache_line = 1 << (((dcm_cfg & NDS32_DSIZE) >> 6) + 2);
   1021a:	54 00 81 c0 	andi $r0,$r1,#0x1c0
   1021e:	92 06       	srli45 $r0,#0x6
   10220:	8c 02       	addi45 $r0,#0x2
   10222:	84 41       	movi55 $r2,#0x1
   10224:	40 21 00 0c 	sll $r2,$r2,$r0
	end *= (1 << ((dcm_cfg & NDS32_DSET) + 6));
   10228:	54 00 80 07 	andi $r0,$r1,#0x7
	end *= (((dcm_cfg & NDS32_DWAY) >> 3) + 1);
   1022c:	54 10 80 38 	andi $r1,$r1,#0x38
		return;

	/* DCache end = cache line size * cache set * cache way. */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
	end = cache_line = 1 << (((dcm_cfg & NDS32_DSIZE) >> 6) + 2);
	end *= (1 << ((dcm_cfg & NDS32_DSET) + 6));
   10230:	8c 06       	addi45 $r0,#0x6
	end *= (((dcm_cfg & NDS32_DWAY) >> 3) + 1);
   10232:	92 23       	srli45 $r1,#0x3
		return;

	/* DCache end = cache line size * cache set * cache way. */
	dcm_cfg = __nds32__mfsr(NDS32_SR_DCM_CFG);
	end = cache_line = 1 << (((dcm_cfg & NDS32_DSIZE) >> 6) + 2);
	end *= (1 << ((dcm_cfg & NDS32_DSET) + 6));
   10234:	40 01 00 0c 	sll $r0,$r2,$r0
	end *= (((dcm_cfg & NDS32_DWAY) >> 3) + 1);
   10238:	8c 21       	addi45 $r1,#0x1
   1023a:	fe 0c       	mul33 $r0,$r1

	/* Flush DCache */
	do {
		end -= cache_line;
   1023c:	8a 02       	sub45 $r0,$r2
		__nds32__cctlidx_wbinval(NDS32_CCTL_L1D_IX_WB, end);
   1023e:	64 00 00 21 	cctl $r0,l1d_ix_wb
		__nds32__dsb();
   10242:	64 00 00 08 	dsb
	} while (end > 0);
   10246:	c8 fb       	bnez38 $r0,1023c <cache_disable+0x38>

	/* Invalid DCache */
	__nds32__cctl_l1d_invalall();
   10248:	64 00 00 e1 	cctl l1d_invalall
	__nds32__dsb();
   1024c:	64 00 00 08 	dsb

	/* Disable I/D Cache */
	__nds32__mtsr_dsb(__nds32__mfsr(NDS32_SR_CACHE_CTL) & ~0x3, NDS32_SR_CACHE_CTL);
   10250:	64 05 00 02 	mfsr $r0,$cache_ctl
   10254:	66 00 00 03 	bitci $r0,$r0,#0x3
   10258:	64 05 00 03 	mtsr $r0,$cache_ctl
   1025c:	64 00 00 08 	dsb
   10260:	dd 9e       	ret5 $lp

00010262 <cache_wb_range>:

void cache_wb_range(unsigned int *addr, int size)
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);
   10262:	64 20 40 02 	mfsr $r2,$dcm_cfg
   10266:	54 21 01 c0 	andi $r2,$r2,#0x1c0
   1026a:	92 46       	srli45 $r2,#0x6
   1026c:	84 61       	movi55 $r3,#0x1
   1026e:	8c 42       	addi45 $r2,#0x2
   10270:	40 21 88 0c 	sll $r2,$r3,$r2
	while(size > 0){
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_WB, addr);
		__nds32__dsb();
		addr += (dsize>>2);
   10274:	66 31 00 03 	bitci $r3,$r2,#0x3
void cache_wb_range(unsigned int *addr, int size)
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);
	while(size > 0){
   10278:	4e 17 00 09 	blez $r1,1028a <cache_wb_range+0x28>
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_WB, addr);
   1027c:	64 00 01 21 	cctl $r0,l1d_va_wb,1level
		__nds32__dsb();
   10280:	64 00 00 08 	dsb
		addr += (dsize>>2);
   10284:	88 03       	add45 $r0,$r3
   10286:	8a 22       	sub45 $r1,$r2
   10288:	d5 f8       	j8 10278 <cache_wb_range+0x16>
		size -= dsize;
	}
	
}
   1028a:	dd 9e       	ret5 $lp

0001028c <cache_inv_range>:

void cache_inv_range(unsigned int *addr, int size)
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);
   1028c:	64 20 40 02 	mfsr $r2,$dcm_cfg
   10290:	54 21 01 c0 	andi $r2,$r2,#0x1c0
   10294:	92 46       	srli45 $r2,#0x6
   10296:	84 61       	movi55 $r3,#0x1
   10298:	8c 42       	addi45 $r2,#0x2
   1029a:	40 21 88 0c 	sll $r2,$r3,$r2

	while(size > 0){
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_INVAL, addr);
		__nds32__dsb();
		addr += (dsize>>2);
   1029e:	66 31 00 03 	bitci $r3,$r2,#0x3
{
	unsigned int dsize;

	dsize = 1 << (((__nds32__mfsr(NDS32_SR_DCM_CFG) & NDS32_DSIZE) >> 6) + 2);

	while(size > 0){
   102a2:	4e 17 00 09 	blez $r1,102b4 <cache_inv_range+0x28>
		__nds32__cctlva_wbinval_one_lvl(NDS32_CCTL_L1D_VA_INVAL, addr);
   102a6:	64 00 01 01 	cctl $r0,l1d_va_inval,1level
		__nds32__dsb();
   102aa:	64 00 00 08 	dsb
		addr += (dsize>>2);
   102ae:	88 03       	add45 $r0,$r3
   102b0:	8a 22       	sub45 $r1,$r2
   102b2:	d5 f8       	j8 102a2 <cache_inv_range+0x16>
		size -= dsize;
	}
	
}
   102b4:	dd 9e       	ret5 $lp

000102b6 <pattern_test>:
{
	uint32 ret = 0;
	int i;

	dbg("pattern test. addr: 0x%x, size: 0x%x\n", (uint32)dram_addr, size);
	size /= 4;
   102b6:	92 22       	srli45 $r1,#0x2

	for(i=0;i<size;i++){
   102b8:	84 a0       	movi55 $r5,#0x0
   102ba:	44 20 1c 8f 	movi $r2,#0x1c8f
   102be:	d1 07       	beqs38 $r1,102cc <pattern_test+0x16>
   102c0:	42 32 88 24 	mul $r3,$r5,$r2
		*(dram_addr + i) = (i*0x55aa)/3 + i;
   102c4:	38 30 16 0a 	sw $r3,[$r0+($r5<<#0x2)]
	int i;

	dbg("pattern test. addr: 0x%x, size: 0x%x\n", (uint32)dram_addr, size);
	size /= 4;

	for(i=0;i<size;i++){
   102c8:	8c a1       	addi45 $r5,#0x1
   102ca:	d5 fa       	j8 102be <pattern_test+0x8>
}
#endif

//int pattern_test(void)
int pattern_test(uint32 *dram_addr, uint32 size)
{
   102cc:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}

	for(i=0;i<size;i++){
		*(dram_addr + i) = (i*0x55aa)/3 + i;
	}

	*((uint32 *)0xf010006c) = 0xffffffff;
   102ce:	46 2f 01 00 	sethi $r2,#0xf0100
   102d2:	84 7f       	movi55 $r3,#-1
   102d4:	14 31 00 1b 	swi $r3,[$r2+#0x6c]
	for(i=0;i<size;i++){
   102d8:	84 a0       	movi55 $r5,#0x0
   102da:	44 40 1c 8f 	movi $r4,#0x1c8f
   102de:	d1 0d       	beqs38 $r1,102f8 <pattern_test+0x42>
   102e0:	42 32 90 24 	mul $r3,$r5,$r4
		if(*(dram_addr + i) != ((i*0x55aa)/3 + i)){
   102e4:	38 60 16 02 	lw $r6,[$r0+($r5<<#0x2)]
   102e8:	4c 61 80 06 	beq $r6,$r3,102f4 <pattern_test+0x3e>
			*((uint32 *)0xf010006c) = i;
   102ec:	14 51 00 1b 	swi $r5,[$r2+#0x6c]
			ret = 1;
   102f0:	84 01       	movi55 $r0,#0x1
			dbg("ERROR! pattern test. addr: 0x%x, W: 0x%x, R: 0x%x\n", (uint32)dram_addr+i, (i*0x55aa)/3 + i, *(dram_addr + i));
			break;
   102f2:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	for(i=0;i<size;i++){
		*(dram_addr + i) = (i*0x55aa)/3 + i;
	}

	*((uint32 *)0xf010006c) = 0xffffffff;
	for(i=0;i<size;i++){
   102f4:	8c a1       	addi45 $r5,#0x1
   102f6:	d5 f4       	j8 102de <pattern_test+0x28>
#endif

//int pattern_test(void)
int pattern_test(uint32 *dram_addr, uint32 size)
{
	uint32 ret = 0;
   102f8:	84 00       	movi55 $r0,#0x0
			break;
		}
	}

	return ret;
}
   102fa:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000102fc <bootloader_main>:
}

#endif

unsigned int bootloader_main(void)
{
   102fc:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
	unsigned int jump_addr = 0xffffffff;
	uint32 bootmode = 0;

	cache_disable();
   102fe:	49 ff ff 83 	jal 10204 <cache_disable>

	bootmode = *(vuint32 *)(BOOT_MODE_ADDR);
   10302:	46 0f 00 00 	sethi $r0,#0xf0000
	bootmode = (bootmode >> 12)&0x7;

	*(vuint32 *)(MISC_BASE_ADDR + 0x10) = 0x01020302; 	//SDCARD sck in/out
   10306:	46 10 10 20 	sethi $r1,#0x1020
	unsigned int jump_addr = 0xffffffff;
	uint32 bootmode = 0;

	cache_disable();

	bootmode = *(vuint32 *)(BOOT_MODE_ADDR);
   1030a:	04 00 00 17 	lwi $r0,[$r0+#0x5c]
	bootmode = (bootmode >> 12)&0x7;

	*(vuint32 *)(MISC_BASE_ADDR + 0x10) = 0x01020302; 	//SDCARD sck in/out
   1030e:	50 10 83 02 	addi $r1,$r1,#0x302
   10312:	46 0f 01 00 	sethi $r0,#0xf0100
   10316:	a8 44       	swi333 $r1,[$r0+#0x10]
	*(vuint32 *)(MISC_BASE_ADDR + 0x18) = 0x03030302; 	//QSPI sck in/out
   10318:	46 10 30 30 	sethi $r1,#0x3030
   1031c:	50 10 83 02 	addi $r1,$r1,#0x302
   10320:	a8 46       	swi333 $r1,[$r0+#0x18]
	*(vuint32 *)(MISC_BASE_ADDR + 0x60) = 0;			// set to default ( bootrom use this register bit8~15 )
   10322:	84 20       	movi55 $r1,#0x0
   10324:	14 10 00 18 	swi $r1,[$r0+#0x60]

	//====================================
	// set pll
	//====================================
#ifdef CLOCK_INIT
	asic_init();
   10328:	49 00 07 06 	jal 11134 <asic_init>
    SetClockPD();
   1032c:	49 00 09 4d 	jal 115c6 <SetClockPD>
#if defined(DDR2_INIT)
	extern void ddr2_set(void);
	ddr2_set();
#elif defined(DDR3_INIT)
	extern void ddr3_set(void);
	ddr3_set();
   10330:	49 00 09 56 	jal 115dc <ddr3_set>
#if defined(DDR2_INIT)
    ddr_calibration(DDR_CAL_WLEVEL | DDR_CAL_RLEVEL); // ddr calibration
#elif defined(DDR3_INIT)
    // ihkong - 0914
#ifndef DDR_AUTO_LEVELING
	ddr_calibration(DDR_CAL_WLEVEL | DDR_CAL_RLEVEL); // ddr calibration
   10334:	84 03       	movi55 $r0,#0x3
   10336:	49 00 06 e0 	jal 110f6 <ddr_calibration>

#endif // CLOCK_INIT

/////////////////////////////////////////////////////////////////////////////
	    
	cache_enable(); //must do this position.
   1033a:	49 ff ff 3d 	jal 101b4 <cache_enable>
			while(1);
		}
	}
#else

	if(pattern_test((uint32 *)DDR_MEM_BASE, 0x10000)){
   1033e:	46 02 00 00 	sethi $r0,#0x20000
   10342:	44 11 00 00 	movi $r1,#0x10000
   10346:	49 ff ff b8 	jal 102b6 <pattern_test>
   1034a:	c0 02       	beqz38 $r0,1034e <bootloader_main+0x52>
		dbg("Error!!! ddr test fail\n");
		while(1);
   1034c:	d5 00       	j8 1034c <bootloader_main+0x50>
   1034e:	f0 81       	swi37.sp $r0,[+#0x4]
		jump_addr = external_boot(eBOOT_MODE_UART);
	}
#endif

	if(jump_addr == 0xffffffff){	// Boot fail
		cache_disable();
   10350:	49 ff ff 5a 	jal 10204 <cache_disable>
#endif	

	cache_disable();

	return jump_addr;
}
   10354:	f0 01       	lwi37.sp $r0,[+#0x4]
   10356:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

00010358 <spi_initialize>:
sint32 spi_initialize(sint32 ch, uint32 slave, uint32 freq, uint32 clk_mode, uint32 wordlen, SPI_CALLBACK callback)
{
	sint32 ret = 0;
	uint32 div;

	gpSPI[ch]->ctrl = 7;	// Tx/Rx FIFO reset, SPI reset
   10358:	44 51 18 bc 	movi $r5,#0x118bc
   1035c:	38 02 82 02 	lw $r0,[$r5+($r0<<#0x2)]
   10360:	84 a7       	movi55 $r5,#0x7
   10362:	14 50 00 0c 	swi $r5,[$r0+#0x30]
	while(gpSPI[ch]->ctrl & 7);
   10366:	04 50 00 0c 	lwi $r5,[$r0+#0x30]
   1036a:	97 57       	fexti33 $r5,#0x2
   1036c:	cd fd       	bnez38 $r5,10366 <spi_initialize+0xe>
};



sint32 spi_initialize(sint32 ch, uint32 slave, uint32 freq, uint32 clk_mode, uint32 wordlen, SPI_CALLBACK callback)
{
   1036e:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	uint32 div;

	gpSPI[ch]->ctrl = 7;	// Tx/Rx FIFO reset, SPI reset
	while(gpSPI[ch]->ctrl & 7);
	
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );
   10370:	97 8c       	xlsb33 $r6,$r1
   10372:	96 cf       	fexti33 $r3,#0x1
   10374:	8e 81       	subi45 $r4,#0x1
   10376:	40 31 98 44 	or_slli $r3,$r3,$r6,#0x2
   1037a:	97 27       	fexti33 $r4,#0x4
   1037c:	40 41 91 04 	or_slli $r4,$r3,$r4,#0x8

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold
   10380:	44 32 02 00 	movi $r3,#0x20200
	uint32 div;

	gpSPI[ch]->ctrl = 7;	// Tx/Rx FIFO reset, SPI reset
	while(gpSPI[ch]->ctrl & 7);
	
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );
   10384:	a9 04       	swi333 $r4,[$r0+#0x10]

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold
   10386:	14 30 00 0c 	swi $r3,[$r0+#0x30]

	if(!slave){
   1038a:	c9 13       	bnez38 $r1,103b0 <spi_initialize+0x58>
		div = (PCLK / (freq * 2)) - 1;
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
   1038c:	83 80       	mov55 $fp,$r0
   1038e:	b9 10       	lwi37 $r1,[$fp+#0x40]
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold

	if(!slave){
		div = (PCLK / (freq * 2)) - 1;
   10390:	94 91       	slli333 $r2,$r2,#0x1
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
   10392:	66 10 80 ff 	bitci $r1,$r1,#0xff
   10396:	b9 90       	swi37 $r1,[$fp+#0x40]
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold

	if(!slave){
		div = (PCLK / (freq * 2)) - 1;
   10398:	46 10 3b 8b 	sethi $r1,#0x3b8b
   1039c:	50 10 88 7c 	addi $r1,$r1,#0x87c
   103a0:	40 20 88 57 	divr $r2,$r2,$r1,$r2
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
		gpSPI[ch]->timing |= (div & 0xff);
   103a4:	bb 10       	lwi37 $r3,[$fp+#0x40]
	gpSPI[ch]->trans_fmt = ( (((wordlen-1)&0x1f) << 8) | ((slave & 1)<<2) | (clk_mode&3) );

    gpSPI[ch]->ctrl = ( (2 << 16) |	(2 << 8) );	// Tx/Rx FIFO Threshold

	if(!slave){
		div = (PCLK / (freq * 2)) - 1;
   103a6:	8e 41       	subi45 $r2,#0x1
		//gpSPI[ch]->timing = utilPutBits(gpSPI[ch]->timing, 0, 8, div);
		gpSPI[ch]->timing &= (~0xff);
		gpSPI[ch]->timing |= (div & 0xff);
   103a8:	96 90       	zeb33 $r2,$r2
   103aa:	fe 9f       	or33 $r2,$r3
   103ac:	ba 90       	swi37 $r2,[$fp+#0x40]
   103ae:	d5 03       	j8 103b4 <spi_initialize+0x5c>
	}else{
		gpSPI[ch]->trans_ctrl = SPI_TCR_WR;
   103b0:	14 50 00 08 	swi $r5,[$r0+#0x20]
	}
	
	return ret;
}
   103b4:	84 00       	movi55 $r0,#0x0
   103b6:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000103b8 <spi_tx>:


sint32 spi_tx(sint32 ch, const uint8 *dout, uint32 size)
{
   103b8:	fc 61       	push25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}
   103ba:	81 41       	mov55 $r10,$r1

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   103bc:	44 11 18 bc 	movi $r1,#0x118bc
   103c0:	38 70 82 02 	lw $r7,[$r1+($r0<<#0x2)]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   103c4:	9e 11       	subi333 $r0,$r2,#0x1

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   103c6:	a1 bc       	lwi333 $r6,[$r7+#0x10]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   103c8:	54 00 01 ff 	andi $r0,$r0,#0x1ff

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   103cc:	92 c8       	srli45 $r6,#0x8
   103ce:	97 a7       	fexti33 $r6,#0x4
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   103d0:	40 00 30 08 	slli $r0,$r0,#0xc

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   103d4:	8c c8       	addi45 $r6,#0x8
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   103d6:	42 00 60 08 	bset $r0,$r0,#0x18
	gpSPI[ch]->cmd = 0;	// start transfer
   103da:	85 20       	movi55 $r9,#0x0
	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
   103dc:	14 03 80 08 	swi $r0,[$r7+#0x20]
	return ret;
}


sint32 spi_tx(sint32 ch, const uint8 *dout, uint32 size)
{
   103e0:	81 62       	mov55 $r11,$r2

	sint32 len_tx;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   103e2:	92 c3       	srli45 $r6,#0x3
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WONLY | (((size-1)&0x1ff)<<12));
	gpSPI[ch]->cmd = 0;	// start transfer
   103e4:	14 93 80 09 	swi $r9,[$r7+#0x24]
   103e8:	46 c0 08 00 	sethi $r12,#0x800
	
	for(len_tx=0; len_tx < size;){
   103ec:	4c 95 80 12 	beq $r9,$r11,10410 <spi_tx+0x58>
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1) ){	// Tx not full
   103f0:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   103f4:	40 00 30 02 	and $r0,$r0,$r12
   103f8:	c8 fa       	bnez38 $r0,103ec <spi_tx+0x34>
			memcpy(&data, dout, n_bytes);
   103fa:	80 2a       	mov55 $r1,$r10
   103fc:	b0 01       	addri36.sp $r0,#0x4
   103fe:	80 46       	mov55 $r2,$r6
   10400:	49 00 0a 08 	jal 11810 <memcpy>
			gpSPI[ch]->data = data;
   10404:	f0 01       	lwi37.sp $r0,[+#0x4]
   10406:	14 03 80 0b 	swi $r0,[$r7+#0x2c]
			dout += n_bytes;
   1040a:	89 46       	add45 $r10,$r6
			len_tx++;
   1040c:	8d 21       	addi45 $r9,#0x1
   1040e:	d5 ef       	j8 103ec <spi_tx+0x34>
		}
	}

	while(gpSPI[ch]->status & 1);
   10410:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   10414:	96 04       	xlsb33 $r0,$r0
   10416:	c8 fd       	bnez38 $r0,10410 <spi_tx+0x58>

	return ret;

}
   10418:	fc e1       	pop25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}

0001041a <spi_rx>:

sint32 spi_rx(sint32 ch, uint8 *din, uint32 size)
{
   1041a:	fc 41       	push25 $r10,#8    ! {$r6~$r10, $fp, $gp, $lp}
   1041c:	80 81       	mov55 $r4,$r1
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1041e:	44 11 18 bc 	movi $r1,#0x118bc
   10422:	38 70 82 02 	lw $r7,[$r1+($r0<<#0x2)]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   10426:	9e d1       	subi333 $r3,$r2,#0x1
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10428:	a1 bc       	lwi333 $r6,[$r7+#0x10]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   1042a:	54 31 81 ff 	andi $r3,$r3,#0x1ff
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1042e:	92 c8       	srli45 $r6,#0x8
   10430:	97 a7       	fexti33 $r6,#0x4
   10432:	8c c8       	addi45 $r6,#0x8
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   10434:	42 31 e4 08 	bset $r3,$r3,#0x19

	gpSPI[ch]->cmd = 0;	// start transfer
   10438:	85 20       	movi55 $r9,#0x0
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));
   1043a:	14 33 80 08 	swi $r3,[$r7+#0x20]
	return ret;

}

sint32 spi_rx(sint32 ch, uint8 *din, uint32 size)
{
   1043e:	81 42       	mov55 $r10,$r2
	sint32 len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;

	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10440:	92 c3       	srli45 $r6,#0x3
	gpSPI[ch]->trans_ctrl = (SPI_TCR_RONLY | (((size-1)&0x1ff)<<0));

	gpSPI[ch]->cmd = 0;	// start transfer
   10442:	14 93 80 09 	swi $r9,[$r7+#0x24]

	for(len_rx=0; len_rx < size;){
   10446:	4c 95 00 16 	beq $r9,$r10,10472 <spi_rx+0x58>
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   1044a:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   1044e:	54 00 40 00 	andi $r0,$r0,#0x4000
   10452:	c8 fa       	bnez38 $r0,10446 <spi_rx+0x2c>
			val = gpSPI[ch]->data;
   10454:	04 03 80 0b 	lwi $r0,[$r7+#0x2c]
   10458:	b6 1f       	swi450 $r0,[$sp]
			data = (uint8)val;
   1045a:	b4 1f       	lwi450 $r0,[$sp]
			memcpy(din, &data, n_bytes);
   1045c:	b0 41       	addri36.sp $r1,#0x4
	gpSPI[ch]->cmd = 0;	// start transfer

	for(len_rx=0; len_rx < size;){
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
			val = gpSPI[ch]->data;
			data = (uint8)val;
   1045e:	96 00       	zeb33 $r0,$r0
   10460:	f0 81       	swi37.sp $r0,[+#0x4]
			memcpy(din, &data, n_bytes);
   10462:	80 46       	mov55 $r2,$r6
   10464:	80 04       	mov55 $r0,$r4
   10466:	49 00 09 d5 	jal 11810 <memcpy>
   1046a:	80 80       	mov55 $r4,$r0
			din += n_bytes;
   1046c:	88 86       	add45 $r4,$r6
			len_rx++;
   1046e:	8d 21       	addi45 $r9,#0x1
   10470:	d5 eb       	j8 10446 <spi_rx+0x2c>
		}

	}

	while(gpSPI[ch]->status & 1);
   10472:	04 03 80 0d 	lwi $r0,[$r7+#0x34]
   10476:	96 04       	xlsb33 $r0,$r0
   10478:	c8 fd       	bnez38 $r0,10472 <spi_rx+0x58>

	return ret;
}
   1047a:	fc c1       	pop25 $r10,#8    ! {$r6~$r10, $fp, $gp, $lp}

0001047c <spi_xfer>:


sint32 spi_xfer(sint32 ch, const uint8 *dout, uint8 *din, uint32 size)
{
   1047c:	fc 61       	push25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1047e:	44 91 18 bc 	movi $r9,#0x118bc
	return ret;
}


sint32 spi_xfer(sint32 ch, const uint8 *dout, uint8 *din, uint32 size)
{
   10482:	81 60       	mov55 $r11,$r0
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10484:	38 04 82 02 	lw $r0,[$r9+($r0<<#0x2)]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));
   10488:	9f 19       	subi333 $r4,$r3,#0x1
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   1048a:	a1 84       	lwi333 $r6,[$r0+#0x10]
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));
   1048c:	54 42 01 ff 	andi $r4,$r4,#0x1ff
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10490:	92 c8       	srli45 $r6,#0x8
   10492:	97 a7       	fexti33 $r6,#0x4
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));

	gpSPI[ch]->cmd = 0;	// start transfer
   10494:	84 e0       	movi55 $r7,#0x0
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   10496:	8c c8       	addi45 $r6,#0x8
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));
   10498:	40 42 11 84 	or_slli $r4,$r4,$r4,#0xc
   1049c:	83 80       	mov55 $fp,$r0
   1049e:	bc 88       	swi37 $r4,[$fp+#0x20]
	return ret;
}


sint32 spi_xfer(sint32 ch, const uint8 *dout, uint8 *din, uint32 size)
{
   104a0:	81 41       	mov55 $r10,$r1
   104a2:	81 02       	mov55 $r8,$r2
   104a4:	81 83       	mov55 $r12,$r3
	sint32 len_tx, len_rx;
	vuint32 val;
	sint32 n_bytes;
	uint32 data;
	
	n_bytes = (((gpSPI[ch]->trans_fmt>>8)&0x1f)+ 1 + 7 ) / 8;
   104a6:	92 c3       	srli45 $r6,#0x3
	gpSPI[ch]->trans_ctrl = (SPI_TCR_WR | (((size-1)&0x1ff)<<12) | (((size-1)&0x1ff)<<0));

	gpSPI[ch]->cmd = 0;	// start transfer
   104a8:	bf 89       	swi37 $r7,[$fp+#0x24]
	
	for(len_tx=0, len_rx=0; len_rx < size;){
   104aa:	81 a7       	mov55 $r13,$r7
   104ac:	47 c0 08 00 	sethi $fp,#0x800
   104b0:	e2 ec       	slt45 $r7,$r12
   104b2:	e8 32       	beqzs8 10516 <spi_xfer+0x9a>
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1)){	// Tx not full
   104b4:	40 f6 b0 06 	slt $r15,$r13,$r12
   104b8:	e8 18       	beqzs8 104e8 <spi_xfer+0x6c>
   104ba:	38 e4 ae 02 	lw $r14,[$r9+($r11<<#0x2)]
   104be:	04 07 00 0d 	lwi $r0,[$r14+#0x34]
   104c2:	40 00 70 02 	and $r0,$r0,$fp
   104c6:	c8 11       	bnez38 $r0,104e8 <spi_xfer+0x6c>
			if(dout){
   104c8:	4e a2 00 0c 	beqz $r10,104e0 <spi_xfer+0x64>
				memcpy(&data, dout, n_bytes);
   104cc:	80 2a       	mov55 $r1,$r10
   104ce:	b0 01       	addri36.sp $r0,#0x4
   104d0:	80 46       	mov55 $r2,$r6
   104d2:	49 00 09 9f 	jal 11810 <memcpy>
				gpSPI[ch]->data = data;
   104d6:	f0 01       	lwi37.sp $r0,[+#0x4]
   104d8:	14 07 00 0b 	swi $r0,[$r14+#0x2c]
				dout += n_bytes;
   104dc:	89 46       	add45 $r10,$r6
   104de:	d5 03       	j8 104e4 <spi_xfer+0x68>
			}else{
				gpSPI[ch]->data = 0;
   104e0:	14 a7 00 0b 	swi $r10,[$r14+#0x2c]
			}
			len_tx++;
   104e4:	50 d6 80 01 	addi $r13,$r13,#0x1
		}

		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   104e8:	38 14 ae 02 	lw $r1,[$r9+($r11<<#0x2)]
   104ec:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   104f0:	54 00 40 00 	andi $r0,$r0,#0x4000
   104f4:	c8 de       	bnez38 $r0,104b0 <spi_xfer+0x34>
			val = gpSPI[ch]->data;
   104f6:	04 00 80 0b 	lwi $r0,[$r1+#0x2c]
   104fa:	b6 1f       	swi450 $r0,[$sp]
			if (din){
   104fc:	4e 82 00 0b 	beqz $r8,10512 <spi_xfer+0x96>
				data = (uint8)val;
   10500:	b4 1f       	lwi450 $r0,[$sp]
				memcpy(din, &data, n_bytes);
   10502:	b0 41       	addri36.sp $r1,#0x4
		}

		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
			val = gpSPI[ch]->data;
			if (din){
				data = (uint8)val;
   10504:	96 00       	zeb33 $r0,$r0
   10506:	f0 81       	swi37.sp $r0,[+#0x4]
				memcpy(din, &data, n_bytes);
   10508:	80 46       	mov55 $r2,$r6
   1050a:	80 08       	mov55 $r0,$r8
   1050c:	49 00 09 82 	jal 11810 <memcpy>
				din += n_bytes;
   10510:	89 06       	add45 $r8,$r6
			}
			len_rx++;
   10512:	8c e1       	addi45 $r7,#0x1
   10514:	d5 ce       	j8 104b0 <spi_xfer+0x34>
		}

	}

	while(gpSPI[ch]->status & 1);
   10516:	38 14 ae 02 	lw $r1,[$r9+($r11<<#0x2)]
   1051a:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   1051e:	96 04       	xlsb33 $r0,$r0
   10520:	c8 fd       	bnez38 $r0,1051a <spi_xfer+0x9e>

	return ret;
}
   10522:	fc e1       	pop25 $r14,#8    ! {$r6~$r14, $fp, $gp, $lp}

00010524 <spi_slave_tx>:


// support only 8 bit
sint32 spi_slave_tx(sint32 ch, const uint8 *dout, uint32 size)
{
   10524:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
	sint32 ret = 0;

	sint32 len_tx;
	
	for(len_tx=0; len_tx < size;){
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1) ){	// Tx not full
   10526:	44 51 18 bc 	movi $r5,#0x118bc
   1052a:	88 41       	add45 $r2,$r1
   1052c:	46 60 08 00 	sethi $r6,#0x800
{
	sint32 ret = 0;

	sint32 len_tx;
	
	for(len_tx=0; len_tx < size;){
   10530:	4c 11 00 0d 	beq $r1,$r2,1054a <spi_slave_tx+0x26>
		if(len_tx < size && !((gpSPI[ch]->status>>23)&1) ){	// Tx not full
   10534:	38 42 82 02 	lw $r4,[$r5+($r0<<#0x2)]
   10538:	04 32 00 0d 	lwi $r3,[$r4+#0x34]
   1053c:	fe f6       	and33 $r3,$r6
   1053e:	cb f9       	bnez38 $r3,10530 <spi_slave_tx+0xc>
			gpSPI[ch]->data = *dout;
   10540:	08 30 80 01 	lbi.bi $r3,[$r1],#0x1
   10544:	14 32 00 0b 	swi $r3,[$r4+#0x2c]
   10548:	d5 f4       	j8 10530 <spi_slave_tx+0xc>
		}
	}

	return ret;

}
   1054a:	84 00       	movi55 $r0,#0x0
   1054c:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

0001054e <spi_slave_tx_byte>:
void spi_slave_tx_byte(sint32 ch, const uint8 dout)
{
	while((gpSPI[ch]->status>>23)&1);	// tx full
   1054e:	44 21 18 bc 	movi $r2,#0x118bc
   10552:	38 21 02 02 	lw $r2,[$r2+($r0<<#0x2)]
   10556:	46 30 08 00 	sethi $r3,#0x800
   1055a:	04 01 00 0d 	lwi $r0,[$r2+#0x34]
   1055e:	fe 1e       	and33 $r0,$r3
   10560:	c8 fd       	bnez38 $r0,1055a <spi_slave_tx_byte+0xc>
	gpSPI[ch]->data = dout;
   10562:	14 11 00 0b 	swi $r1,[$r2+#0x2c]
   10566:	dd 9e       	ret5 $lp

00010568 <spi_slave_rx>:

}

sint32 spi_slave_rx(sint32 ch, uint8 *din, uint32 size)
{
   10568:	88 41       	add45 $r2,$r1
	sint32 ret = 0;
	sint32 len_rx;

	for(len_rx=0; len_rx < size;){
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   1056a:	44 51 18 bc 	movi $r5,#0x118bc
sint32 spi_slave_rx(sint32 ch, uint8 *din, uint32 size)
{
	sint32 ret = 0;
	sint32 len_rx;

	for(len_rx=0; len_rx < size;){
   1056e:	4c 11 00 0e 	beq $r1,$r2,1058a <spi_slave_rx+0x22>
		if(!((gpSPI[ch]->status>>14)&1)){	// Rx not empty
   10572:	38 42 82 02 	lw $r4,[$r5+($r0<<#0x2)]
   10576:	04 32 00 0d 	lwi $r3,[$r4+#0x34]
   1057a:	54 31 c0 00 	andi $r3,$r3,#0x4000
   1057e:	cb f8       	bnez38 $r3,1056e <spi_slave_rx+0x6>
			*din = gpSPI[ch]->data;
   10580:	04 32 00 0b 	lwi $r3,[$r4+#0x2c]
   10584:	18 30 80 01 	sbi.bi $r3,[$r1],#0x1
   10588:	d5 f3       	j8 1056e <spi_slave_rx+0x6>
		}

	}

	return ret;
}
   1058a:	84 00       	movi55 $r0,#0x0
   1058c:	dd 9e       	ret5 $lp

0001058e <spi_slave_rx_byte>:

uint8 spi_slave_rx_byte(sint32 ch)
{
	uint8 ret;
	
	while((gpSPI[ch]->status>>14)&1);	// rx empty
   1058e:	44 11 18 bc 	movi $r1,#0x118bc
   10592:	38 10 82 02 	lw $r1,[$r1+($r0<<#0x2)]
   10596:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   1059a:	54 00 40 00 	andi $r0,$r0,#0x4000
   1059e:	c8 fc       	bnez38 $r0,10596 <spi_slave_rx_byte+0x8>

	ret = gpSPI[ch]->data;
   105a0:	04 00 80 0b 	lwi $r0,[$r1+#0x2c]
	
	return ret;
}
   105a4:	96 00       	zeb33 $r0,$r0
   105a6:	dd 9e       	ret5 $lp

000105a8 <spi_direct_cs_enable>:


sint32 spi_direct_cs_enable(sint32 ch, uint8 en)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   105a8:	44 41 18 6c 	movi $r4,#0x1186c
   105ac:	40 22 00 60 	add_slli $r2,$r4,$r0,#0x3
   105b0:	a0 91       	lwi333 $r2,[$r2+#0x4]
   105b2:	5a 27 ff 3d 	beqc $r2,#-1,1062c <spi_direct_cs_enable+0x84>
   105b6:	44 31 18 8c 	movi $r3,#0x1188c
	
	if(en){
   105ba:	c1 2b       	beqz38 $r1,10610 <spi_direct_cs_enable+0x68>
		*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) |= (1<<gCS_GPIO[ch].ch);	// gpio output value  set
   105bc:	38 42 03 02 	lw $r4,[$r4+($r0<<#0x3)]
   105c0:	46 10 00 f0 	sethi $r1,#0xf0
   105c4:	58 10 82 00 	ori $r1,$r1,#0x200
   105c8:	88 24       	add45 $r1,$r4
   105ca:	40 10 b0 08 	slli $r1,$r1,#0xc
   105ce:	04 40 80 09 	lwi $r4,[$r1+#0x24]
   105d2:	84 a1       	movi55 $r5,#0x1
   105d4:	40 22 88 0c 	sll $r2,$r5,$r2
   105d8:	ff 17       	or33 $r4,$r2
   105da:	14 40 80 09 	swi $r4,[$r1+#0x24]
		*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x28) |= (1<<gCS_GPIO[ch].ch);	// gpio dir out 
   105de:	04 40 80 0a 	lwi $r4,[$r1+#0x28]
   105e2:	fe a7       	or33 $r2,$r4
   105e4:	14 20 80 0a 	swi $r2,[$r1+#0x28]
		
		//*(vuint32 *)gCS_PinMux[ch].reg &= ~(0xff << gCS_PinMux[ch].offset);
		//*(vuint32 *)gCS_PinMux[ch].reg |= (1 << gCS_PinMux[ch].offset);
		*(vuint32 *)gCS_PinMux[ch].reg &= ~(0x3 << gCS_PinMux[ch].offset);
   105e8:	84 2c       	movi55 $r1,#0xc
   105ea:	42 30 04 73 	maddr32 $r3,$r0,$r1
   105ee:	84 43       	movi55 $r2,#0x3
   105f0:	80 23       	mov55 $r1,$r3
   105f2:	b4 63       	lwi450 $r3,[$r3]
   105f4:	a0 09       	lwi333 $r0,[$r1+#0x4]
   105f6:	b4 83       	lwi450 $r4,[$r3]
   105f8:	40 21 00 0c 	sll $r2,$r2,$r0
   105fc:	40 22 08 12 	bitc $r2,$r4,$r2
   10600:	b6 43       	swi450 $r2,[$r3]
		*(vuint32 *)gCS_PinMux[ch].reg |= (gCS_PinMux[ch].val << gCS_PinMux[ch].offset);
   10602:	a0 4a       	lwi333 $r1,[$r1+#0x8]
   10604:	b4 43       	lwi450 $r2,[$r3]
   10606:	40 10 80 0c 	sll $r1,$r1,$r0
   1060a:	fe 57       	or33 $r1,$r2
   1060c:	b6 23       	swi450 $r1,[$r3]
   1060e:	d5 0d       	j8 10628 <spi_direct_cs_enable+0x80>

	}else{
		//*(vuint32 *)gCS_PinMux[ch].reg &= ~(0xff << gCS_PinMux[ch].offset);
		*(vuint32 *)gCS_PinMux[ch].reg &= ~(0x3 << gCS_PinMux[ch].offset);
   10610:	84 2c       	movi55 $r1,#0xc
   10612:	42 30 04 73 	maddr32 $r3,$r0,$r1
   10616:	b4 43       	lwi450 $r2,[$r3]
   10618:	a0 19       	lwi333 $r0,[$r3+#0x4]
   1061a:	b4 62       	lwi450 $r3,[$r2]
   1061c:	84 23       	movi55 $r1,#0x3
   1061e:	40 00 80 0c 	sll $r0,$r1,$r0
   10622:	40 01 80 12 	bitc $r0,$r3,$r0
   10626:	b6 02       	swi450 $r0,[$r2]
		
	}

	return 1;
   10628:	84 01       	movi55 $r0,#0x1
   1062a:	dd 9e       	ret5 $lp
}


sint32 spi_direct_cs_enable(sint32 ch, uint8 en)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   1062c:	80 02       	mov55 $r0,$r2
		
	}

	return 1;

}
   1062e:	dd 9e       	ret5 $lp

00010630 <spi_cs_activate>:

sint32 spi_cs_activate(sint32 ch)
{

	if(gCS_GPIO[ch].ch == -1)return -1;
   10630:	44 21 18 6c 	movi $r2,#0x1186c
   10634:	40 11 00 60 	add_slli $r1,$r2,$r0,#0x3
   10638:	a0 49       	lwi333 $r1,[$r1+#0x4]
   1063a:	5a 17 ff 15 	beqc $r1,#-1,10664 <spi_cs_activate+0x34>

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) &= (~(1<<gCS_GPIO[ch].ch));	// gpio output value  set 0
   1063e:	38 01 03 02 	lw $r0,[$r2+($r0<<#0x3)]
   10642:	46 30 00 f0 	sethi $r3,#0xf0
   10646:	58 31 82 00 	ori $r3,$r3,#0x200
   1064a:	88 60       	add45 $r3,$r0
   1064c:	40 31 b0 08 	slli $r3,$r3,#0xc
   10650:	04 41 80 09 	lwi $r4,[$r3+#0x24]
   10654:	84 01       	movi55 $r0,#0x1
   10656:	40 20 04 0c 	sll $r2,$r0,$r1
   1065a:	40 22 08 12 	bitc $r2,$r4,$r2
   1065e:	14 21 80 09 	swi $r2,[$r3+#0x24]

	return 1;
   10662:	dd 9e       	ret5 $lp
}

sint32 spi_cs_activate(sint32 ch)
{

	if(gCS_GPIO[ch].ch == -1)return -1;
   10664:	80 01       	mov55 $r0,$r1

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) &= (~(1<<gCS_GPIO[ch].ch));	// gpio output value  set 0

	return 1;
}
   10666:	dd 9e       	ret5 $lp

00010668 <spi_cs_deactivate>:

sint32 spi_cs_deactivate(sint32 ch)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   10668:	44 21 18 6c 	movi $r2,#0x1186c
   1066c:	40 11 00 60 	add_slli $r1,$r2,$r0,#0x3
   10670:	a0 49       	lwi333 $r1,[$r1+#0x4]
   10672:	5a 17 ff 14 	beqc $r1,#-1,1069a <spi_cs_deactivate+0x32>

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) |= (1<<gCS_GPIO[ch].ch);	// gpio output value  set 1
   10676:	38 01 03 02 	lw $r0,[$r2+($r0<<#0x3)]
   1067a:	46 30 00 f0 	sethi $r3,#0xf0
   1067e:	58 31 82 00 	ori $r3,$r3,#0x200
   10682:	88 60       	add45 $r3,$r0
   10684:	40 31 b0 08 	slli $r3,$r3,#0xc
   10688:	04 41 80 09 	lwi $r4,[$r3+#0x24]
   1068c:	84 01       	movi55 $r0,#0x1
   1068e:	40 20 04 0c 	sll $r2,$r0,$r1
   10692:	fe a7       	or33 $r2,$r4
   10694:	14 21 80 09 	swi $r2,[$r3+#0x24]

	return 1;
   10698:	dd 9e       	ret5 $lp
	return 1;
}

sint32 spi_cs_deactivate(sint32 ch)
{
	if(gCS_GPIO[ch].ch == -1)return -1;
   1069a:	80 01       	mov55 $r0,$r1

	*(vuint32 *)(GPIO0_BASE_ADDR + 0x1000*gCS_GPIO[ch].group + 0x24) |= (1<<gCS_GPIO[ch].ch);	// gpio output value  set 1

	return 1;
}
   1069c:	dd 9e       	ret5 $lp

0001069e <spi_wait>:

void spi_wait(sint32 ch)
{
	while(gpSPI[ch]->status & 1);
   1069e:	44 11 18 bc 	movi $r1,#0x118bc
   106a2:	38 10 82 02 	lw $r1,[$r1+($r0<<#0x2)]
   106a6:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
   106aa:	96 04       	xlsb33 $r0,$r0
   106ac:	c8 fd       	bnez38 $r0,106a6 <spi_wait+0x8>
}
   106ae:	dd 9e       	ret5 $lp

000106b0 <uart_init>:
void uart_init(uint32 baudrate, uint32 databit, uint32 stopbit, uint32 parity)
{
	uint16 	div = 0;

	//div = UART_CLK / (18 * baudrate);
	div = UART_CLK / (16 * baudrate);
   106b0:	46 40 19 bf 	sethi $r4,#0x19bf
   106b4:	50 42 0c c0 	addi $r4,$r4,#0xcc0
   106b8:	94 04       	slli333 $r0,$r0,#0x4
   106ba:	40 02 00 17 	divr $r0,$r0,$r4,$r0

	// Set DLAB to 1
	gpUart->lcr |= (1<<7);
   106be:	46 4f 0d 00 	sethi $r4,#0xf0d00
   106c2:	04 52 00 0b 	lwi $r5,[$r4+#0x2c]
   106c6:	fe 9f       	or33 $r2,$r3
   106c8:	58 52 80 80 	ori $r5,$r5,#0x80
   106cc:	14 52 00 0b 	swi $r5,[$r4+#0x2c]

	// Set OSCR (default value)
	gpUart->oscr  = 16; 
   106d0:	fa a0       	movpi45 $r5,#0x10
   106d2:	a9 65       	swi333 $r5,[$r4+#0x14]
	//gpUart->oscr  = 18; // minimize error ratio at 27MHz, 115200baud
	
	// Set DLL for baudrate
	gpUart->dll = ((div >> 0) & 0xff);
   106d4:	97 40       	zeb33 $r5,$r0
	gpUart->dlm = ((div >> 8) & 0xff);
   106d6:	96 01       	zeh33 $r0,$r0
   106d8:	92 08       	srli45 $r0,#0x8
	// Set OSCR (default value)
	gpUart->oscr  = 16; 
	//gpUart->oscr  = 18; // minimize error ratio at 27MHz, 115200baud
	
	// Set DLL for baudrate
	gpUart->dll = ((div >> 0) & 0xff);
   106da:	14 52 00 08 	swi $r5,[$r4+#0x20]
	gpUart->dlm = ((div >> 8) & 0xff);
   106de:	14 02 00 09 	swi $r0,[$r4+#0x24]

	// Set DLAB to 0
	gpUart->lcr &= ~(1<<7);
   106e2:	04 02 00 0b 	lwi $r0,[$r4+#0x2c]

	// LCR: data bit, stop bit, parity
	gpUart->lcr = (databit | stopbit | parity);
   106e6:	fe 57       	or33 $r1,$r2
	// Set DLL for baudrate
	gpUart->dll = ((div >> 0) & 0xff);
	gpUart->dlm = ((div >> 8) & 0xff);

	// Set DLAB to 0
	gpUart->lcr &= ~(1<<7);
   106e8:	66 00 00 80 	bitci $r0,$r0,#0x80
   106ec:	14 02 00 0b 	swi $r0,[$r4+#0x2c]

	// LCR: data bit, stop bit, parity
	gpUart->lcr = (databit | stopbit | parity);
   106f0:	14 12 00 0b 	swi $r1,[$r4+#0x2c]
   106f4:	dd 9e       	ret5 $lp

000106f6 <uart_outbyte>:
	return (gpUart->rbr & 0xff);
}

static uint8 uart_get_txEmpty (void)
{
	return ((gpUart->lsr>>5)&1);
   106f6:	46 2f 0d 00 	sethi $r2,#0xf0d00
   106fa:	04 11 00 0d 	lwi $r1,[$r2+#0x34]
   106fe:	96 6e       	bmski33 $r1,#0x5
{
	uint32 reg = 0;

	do {
		reg = uart_get_txEmpty();
	} while(!reg);
   10700:	c1 fd       	beqz38 $r1,106fa <uart_outbyte+0x4>
	return ((gpUart->lsr>>5)&1);
}

static void uart_set_txData (uint8 data)
{
	gpUart->thr = data;
   10702:	46 1f 0d 00 	sethi $r1,#0xf0d00
   10706:	14 00 80 08 	swi $r0,[$r1+#0x20]
   1070a:	dd 9e       	ret5 $lp

0001070c <uart_inbyte>:
/*---------------------------------------------------------------------------*/
static UART_REG_T *gpUart = UART0_CTRL_REG;

static uint8 uart_get_rxReady (void)
{
	return (gpUart->lsr & 1);
   1070c:	46 1f 0d 00 	sethi $r1,#0xf0d00
   10710:	04 00 80 0d 	lwi $r0,[$r1+#0x34]
	uart_set_txData(c);
}

uint8 uart_inbyte(void)
{
	while(!uart_get_rxReady());
   10714:	96 04       	xlsb33 $r0,$r0
   10716:	c0 fd       	beqz38 $r0,10710 <uart_inbyte+0x4>
	return (gpUart->lsr & 1);
}

static uint8 uart_get_rxData (void)
{
	return (gpUart->rbr & 0xff);
   10718:	46 0f 0d 00 	sethi $r0,#0xf0d00
   1071c:	04 00 00 08 	lwi $r0,[$r0+#0x20]
	while(!uart_get_rxReady());

	//if(gpUart->lsr & 2)dbg("rx buffer overrun\n");

	return uart_get_rxData();
}
   10720:	96 00       	zeb33 $r0,$r0
   10722:	dd 9e       	ret5 $lp

00010724 <find_center>:
    //(*(volatile unsigned int *) 0x80000080 = 0xdeaddead);
}


static int find_center(unsigned int table_array[], int number)
{
   10724:	fc 20       	push25 $r8,#0    ! {$r6~$r8, $fp, $gp, $lp}
    int i;

    int wmax_start = 0;
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;
   10726:	84 40       	movi55 $r2,#0x0
    int cont_pass = 1;
    int i;

    int wmax_start = 0;
    int wmax_num = 0;
    int w_start = 0;
   10728:	80 c2       	mov55 $r6,$r2
    int final_center = -1;
    int cont_pass = 1;
    int i;

    int wmax_start = 0;
    int wmax_num = 0;
   1072a:	80 82       	mov55 $r4,$r2
{
    int final_center = -1;
    int cont_pass = 1;
    int i;

    int wmax_start = 0;
   1072c:	80 e2       	mov55 $r7,$r2
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;

    cont_pass = 0;
    for(i=0;i<number;i++){
   1072e:	80 a2       	mov55 $r5,$r2
    int wmax_start = 0;
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;

    cont_pass = 0;
   10730:	80 62       	mov55 $r3,$r2
    for(i=0;i<number;i++){
   10732:	e0 a1       	slts45 $r5,$r1
   10734:	e8 14       	beqzs8 1075c <find_center+0x38>
    	if(table_array[i] == NUM_PATTERN){
   10736:	39 00 16 02 	lw $r16,[$r0+($r5<<#0x2)]
   1073a:	5b 08 08 09 	bnec $r16,#0x8,1074c <find_center+0x28>
    		if(cont_pass == 0){
   1073e:	40 21 8c 1a 	cmovz $r2,$r3,$r3
   10742:	40 62 8c 1a 	cmovz $r6,$r5,$r3
    			w_start = i;
    			w_num = 0;
    		}

    		w_num++;
   10746:	8c 41       	addi45 $r2,#0x1
    		cont_pass = 1;
   10748:	84 61       	movi55 $r3,#0x1
   1074a:	d5 07       	j8 10758 <find_center+0x34>
    	}else{
    		if(w_num > wmax_num){
   1074c:	e0 82       	slts45 $r4,$r2
   1074e:	e8 03       	beqzs8 10754 <find_center+0x30>
   10750:	80 82       	mov55 $r4,$r2
   10752:	80 e6       	mov55 $r7,$r6
    			wmax_start = w_start;
    			wmax_num = w_num;
    		}
    		w_num = 0;
   10754:	84 40       	movi55 $r2,#0x0
    		cont_pass = 0;
   10756:	80 62       	mov55 $r3,$r2
    int wmax_num = 0;
    int w_start = 0;
    int w_num = 0;

    cont_pass = 0;
    for(i=0;i<number;i++){
   10758:	8c a1       	addi45 $r5,#0x1
   1075a:	d5 ec       	j8 10732 <find_center+0xe>
    		w_num = 0;
    		cont_pass = 0;
    	}

    }
    if(cont_pass){
   1075c:	c3 03       	beqz38 $r3,10762 <find_center+0x3e>
		if(w_num > wmax_num){
   1075e:	e0 82       	slts45 $r4,$r2
   10760:	e9 04       	bnezs8 10768 <find_center+0x44>
			wmax_start = w_start;
			wmax_num = w_num;
		}
    }

    if(wmax_num > 0){
   10762:	c4 08       	beqz38 $r4,10772 <find_center+0x4e>
   10764:	80 44       	mov55 $r2,$r4
   10766:	d5 02       	j8 1076a <find_center+0x46>
   10768:	80 e6       	mov55 $r7,$r6
    	final_center = wmax_start + (wmax_num-1)/2;
   1076a:	8e 41       	subi45 $r2,#0x1
   1076c:	90 41       	srai45 $r2,#0x1
   1076e:	98 3a       	add333 $r0,$r7,$r2
   10770:	fc a0       	pop25 $r8,#0    ! {$r6~$r8, $fp, $gp, $lp}
    }else{
    	final_center = -1;
   10772:	84 1f       	movi55 $r0,#-1
    {
        fail();
    }

    return final_center;
}
   10774:	fc a0       	pop25 $r8,#0    ! {$r6~$r8, $fp, $gp, $lp}

00010776 <Write_Read_compare>:

static int Write_Read_compare(int byte_mode, int bit_mode)
{
   10776:	fc 04       	push25 $r6,#32    ! {$r6, $fp, $gp, $lp}
	unsigned int pattern[NUM_PATTERN] = {0x55555555, 0xAAAAAAAA, 0x44444444, 0xDDDDDDDD, 0x11111111, 0xEEEEEEEE, 0x0F0F0F0F, 0xF0F0F0F0};
   10778:	44 31 18 cc 	movi $r3,#0x118cc
   1077c:	3b 01 dc 00 	lmw.bi $r16,[$r3],$r23,#0x0    ! {$r16~$r23}
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
   10780:	e4 04       	sltsi45 $r0,#0x4
    return final_center;
}

static int Write_Read_compare(int byte_mode, int bit_mode)
{
	unsigned int pattern[NUM_PATTERN] = {0x55555555, 0xAAAAAAAA, 0x44444444, 0xDDDDDDDD, 0x11111111, 0xEEEEEEEE, 0x0F0F0F0F, 0xF0F0F0F0};
   10782:	80 5f       	mov55 $r2,$sp
   10784:	3b 0f dc 20 	smw.bi $r16,[$sp],$r23,#0x0    ! {$r16~$r23}
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
   10788:	e8 1b       	beqzs8 107be <Write_Read_compare+0x48>
   1078a:	46 32 00 00 	sethi $r3,#0x20000
   1078e:	88 03       	add45 $r0,$r3
		// Write
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
   10790:	90 23       	srai45 $r1,#0x3
   10792:	80 80       	mov55 $r4,$r0
   10794:	84 60       	movi55 $r3,#0x0
   10796:	38 51 0e 00 	lb $r5,[$r2+($r3<<#0x2)]
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   1079a:	8c 61       	addi45 $r3,#0x1
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
   1079c:	38 52 04 0c 	sb.bi $r5,[$r4],$r1<<#0x0
	int pass = 0;
	int i;

	if(byte_mode < 4){							// byte 0, 1, 2, 3
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107a0:	5a 38 08 fb 	bnec $r3,#0x8,10796 <Write_Read_compare+0x20>
   107a4:	84 80       	movi55 $r4,#0x0
   107a6:	80 64       	mov55 $r3,$r4
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
   107a8:	a7 80       	lbi333 $r6,[$r0+#0x0]
   107aa:	38 51 12 00 	lb $r5,[$r2+($r4<<#0x2)]
   107ae:	4c 62 c0 03 	bne $r6,$r5,107b4 <Write_Read_compare+0x3e>
   107b2:	8c 61       	addi45 $r3,#0x1
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) = (volatile unsigned char)(pattern[i]&0xff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
   107b4:	8c 81       	addi45 $r4,#0x1
   107b6:	88 01       	add45 $r0,$r1
   107b8:	5a 48 08 f8 	bnec $r4,#0x8,107a8 <Write_Read_compare+0x32>
   107bc:	d5 39       	j8 1082e <Write_Read_compare+0xb8>
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
   107be:	5a 08 04 1c 	bnec $r0,#0x4,107f6 <Write_Read_compare+0x80>
		// Write
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
   107c2:	90 23       	srai45 $r1,#0x3
   107c4:	46 32 00 00 	sethi $r3,#0x20000
   107c8:	84 00       	movi55 $r0,#0x0
   107ca:	38 41 02 01 	lh $r4,[$r2+($r0<<#0x2)]
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107ce:	8c 01       	addi45 $r0,#0x1
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
   107d0:	38 41 84 0d 	sh.bi $r4,[$r3],$r1<<#0x0
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   107d4:	5a 08 08 fb 	bnec $r0,#0x8,107ca <Write_Read_compare+0x54>
   107d8:	84 00       	movi55 $r0,#0x0
   107da:	46 42 00 00 	sethi $r4,#0x20000
   107de:	80 60       	mov55 $r3,$r0
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) == (volatile unsigned short)(pattern[i]&0xffff) )pass++;
   107e0:	a5 a0       	lhi333 $r6,[$r4+#0x0]
   107e2:	38 51 02 01 	lh $r5,[$r2+($r0<<#0x2)]
   107e6:	4c 62 c0 03 	bne $r6,$r5,107ec <Write_Read_compare+0x76>
   107ea:	8c 61       	addi45 $r3,#0x1
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) = (volatile unsigned short)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
   107ec:	8c 01       	addi45 $r0,#0x1
   107ee:	88 81       	add45 $r4,$r1
   107f0:	5a 08 08 f8 	bnec $r0,#0x8,107e0 <Write_Read_compare+0x6a>
   107f4:	d5 1d       	j8 1082e <Write_Read_compare+0xb8>
   107f6:	46 11 ff ff 	sethi $r1,#0x1ffff
   107fa:	50 10 8f fa 	addi $r1,$r1,#0xffa
   107fe:	88 20       	add45 $r1,$r0

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned char *) (DDR_MEM_BASE+byte_mode+i*(bit_mode>>3)) == (volatile unsigned char)(pattern[i]&0xff) )pass++;
		}
	}else if(byte_mode == 4 && byte_mode < 6){	// short 0, 1
   10800:	84 60       	movi55 $r3,#0x0
		}

	}else{										// word 0
		// Write
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
   10802:	38 41 0e 01 	lh $r4,[$r2+($r3<<#0x2)]
			if(*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) == (volatile unsigned short)(pattern[i]&0xffff) )pass++;
		}

	}else{										// word 0
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   10806:	8c 61       	addi45 $r3,#0x1
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
   10808:	ab 09       	swi333.bi $r4,[$r1],#0x4
			if(*(volatile unsigned short *) (DDR_MEM_BASE+(byte_mode-4)*2+i*(bit_mode>>3)) == (volatile unsigned short)(pattern[i]&0xffff) )pass++;
		}

	}else{										// word 0
		// Write
		for(i=0;i<NUM_PATTERN;i++){
   1080a:	5a 38 08 fc 	bnec $r3,#0x8,10802 <Write_Read_compare+0x8c>
   1080e:	46 41 ff ff 	sethi $r4,#0x1ffff
   10812:	84 20       	movi55 $r1,#0x0
   10814:	50 42 0f fa 	addi $r4,$r4,#0xffa
   10818:	80 61       	mov55 $r3,$r1
   1081a:	88 04       	add45 $r0,$r4
   1081c:	99 01       	add333 $r4,$r0,$r1
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
			if(*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) == (volatile unsigned int)(pattern[i]&0xffff) )pass++;
   1081e:	b4 a4       	lwi450 $r5,[$r4]
   10820:	38 41 04 01 	lh $r4,[$r2+($r1<<#0x0)]
   10824:	dc 02       	bnes38 $r4,10828 <Write_Read_compare+0xb2>
   10826:	8c 61       	addi45 $r3,#0x1
   10828:	8c 24       	addi45 $r1,#0x4
		for(i=0;i<NUM_PATTERN;i++){
			*(volatile unsigned int *) (DDR_MEM_BASE+(byte_mode-6)+i*4) = (volatile unsigned int)(pattern[i]&0xffff);
		}

		// Read & Compare
		for(i=0;i<NUM_PATTERN;i++){
   1082a:	5a 18 20 f9 	bnec $r1,#0x20,1081c <Write_Read_compare+0xa6>
		}

	}

	return pass;
}
   1082e:	80 03       	mov55 $r0,$r3
   10830:	fc 84       	pop25 $r6,#32    ! {$r6, $fp, $gp, $lp}

00010832 <do_calibration_DQ_DQS_READ>:
#endif

}

static void do_calibration_DQ_DQS_READ()
{
   10832:	fc 65       	push25 $r14,#40    ! {$r6~$r14, $fp, $gp, $lp}
   10834:	36 3f 80 00 	fsdi $fd3,[$sp+#0x0]
   10838:	36 4f 80 02 	fsdi $fd4,[$sp+#0x8]
   1083c:	36 5f 80 04 	fsdi $fd5,[$sp+#0x10]
   10840:	36 6f 80 06 	fsdi $fd6,[$sp+#0x18]
   10844:	36 7f 80 08 	fsdi $fd7,[$sp+#0x20]
   10848:	51 ff fd b0 	addi $sp,$sp,#-592
    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   1084c:	46 cf 05 00 	sethi $r12,#0xf0500
    unsigned int DQS_RD_FALL_B3_result;


    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10850:	85 20       	movi55 $r9,#0x0

        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   10852:	50 b6 00 24 	addi $r11,$r12,#0x24
                LOOPDELAY_10USEC(1); // wait 10us
   10856:	46 6f 00 00 	sethi $r6,#0xf0000

    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
   1085a:	f0 02       	lwi37.sp $r0,[+#0x8]
   1085c:	44 00 11 11 	movi $r0,#0x1111
   10860:	42 04 80 24 	mul $r0,$r9,$r0
   10864:	f0 82       	swi37.sp $r0,[+#0x8]
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10866:	f0 02       	lwi37.sp $r0,[+#0x8]
   10868:	14 06 00 1b 	swi $r0,[$r12+#0x6c]
        if (DQSDLSEL_count == 0) {
   1086c:	4e 93 00 64 	bnez $r9,10934 <do_calibration_DQ_DQS_READ+0x102>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   10870:	50 af 80 50 	addi $r10,$sp,#0x50
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
   10874:	f0 01       	lwi37.sp $r0,[+#0x4]
   10876:	14 9f 80 01 	swi $r9,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   1087a:	f0 01       	lwi37.sp $r0,[+#0x4]
   1087c:	b6 0b       	swi450 $r0,[$r11]
   1087e:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10880:	b4 06       	lwi450 $r0,[$r6]
   10882:	f0 84       	swi37.sp $r0,[+#0x10]
   10884:	f0 04       	lwi37.sp $r0,[+#0x10]
   10886:	8e e1       	subi45 $r7,#0x1
   10888:	b6 06       	swi450 $r0,[$r6]
   1088a:	cf fb       	bnez38 $r7,10880 <do_calibration_DQ_DQS_READ+0x4e>

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   1088c:	80 07       	mov55 $r0,$r7
   1088e:	fa 30       	movpi45 $r1,#0x20
   10890:	49 ff ff 73 	jal 10776 <Write_Read_compare>
   10894:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   10898:	8d 21       	addi45 $r9,#0x1
   1089a:	5a 98 08 ed 	bnec $r9,#0x8,10874 <do_calibration_DQ_DQS_READ+0x42>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   1089e:	50 af 80 70 	addi $r10,$sp,#0x70

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
   108a2:	f0 01       	lwi37.sp $r0,[+#0x4]
   108a4:	40 03 a0 08 	slli $r0,$r7,#0x8
   108a8:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   108aa:	f0 01       	lwi37.sp $r0,[+#0x4]
   108ac:	b6 0b       	swi450 $r0,[$r11]
   108ae:	85 2f       	movi55 $r9,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   108b0:	b4 06       	lwi450 $r0,[$r6]
   108b2:	f0 85       	swi37.sp $r0,[+#0x14]
   108b4:	f0 05       	lwi37.sp $r0,[+#0x14]
   108b6:	8f 21       	subi45 $r9,#0x1
   108b8:	b6 06       	swi450 $r0,[$r6]
   108ba:	4e 93 ff fb 	bnez $r9,108b0 <do_calibration_DQ_DQS_READ+0x7e>

                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   108be:	84 01       	movi55 $r0,#0x1
   108c0:	fa 30       	movpi45 $r1,#0x20
   108c2:	49 ff ff 5a 	jal 10776 <Write_Read_compare>
   108c6:	38 05 1e 0a 	sw $r0,[$r10+($r7<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   108ca:	8c e1       	addi45 $r7,#0x1
   108cc:	5a 78 08 eb 	bnec $r7,#0x8,108a2 <do_calibration_DQ_DQS_READ+0x70>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   108d0:	50 af 80 90 	addi $r10,$sp,#0x90
                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
   108d4:	f0 01       	lwi37.sp $r0,[+#0x4]
   108d6:	40 04 c0 08 	slli $r0,$r9,#0x10
   108da:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   108dc:	f0 01       	lwi37.sp $r0,[+#0x4]
   108de:	b6 0b       	swi450 $r0,[$r11]
   108e0:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   108e2:	b4 06       	lwi450 $r0,[$r6]
   108e4:	f0 86       	swi37.sp $r0,[+#0x18]
   108e6:	f0 06       	lwi37.sp $r0,[+#0x18]
   108e8:	8e e1       	subi45 $r7,#0x1
   108ea:	b6 06       	swi450 $r0,[$r6]
   108ec:	cf fb       	bnez38 $r7,108e2 <do_calibration_DQ_DQS_READ+0xb0>

                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   108ee:	84 02       	movi55 $r0,#0x2
   108f0:	fa 30       	movpi45 $r1,#0x20
   108f2:	49 ff ff 42 	jal 10776 <Write_Read_compare>
   108f6:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]

                DQ_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   108fa:	8d 21       	addi45 $r9,#0x1
   108fc:	5a 98 08 ec 	bnec $r9,#0x8,108d4 <do_calibration_DQ_DQS_READ+0xa2>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   10900:	50 9f 80 b0 	addi $r9,$sp,#0xb0
                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
   10904:	f0 01       	lwi37.sp $r0,[+#0x4]
   10906:	40 03 e0 08 	slli $r0,$r7,#0x18
   1090a:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   1090c:	f0 01       	lwi37.sp $r0,[+#0x4]
   1090e:	b6 0b       	swi450 $r0,[$r11]
   10910:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10912:	b4 26       	lwi450 $r1,[$r6]
   10914:	f1 87       	swi37.sp $r1,[+#0x1c]
   10916:	f1 07       	lwi37.sp $r1,[+#0x1c]
   10918:	8e 01       	subi45 $r0,#0x1
   1091a:	b6 26       	swi450 $r1,[$r6]
   1091c:	c8 fb       	bnez38 $r0,10912 <do_calibration_DQ_DQS_READ+0xe0>

                DQ_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   1091e:	84 03       	movi55 $r0,#0x3
   10920:	fa 30       	movpi45 $r1,#0x20
   10922:	49 ff ff 2a 	jal 10776 <Write_Read_compare>
   10926:	38 04 9e 0a 	sw $r0,[$r9+($r7<<#0x2)]

                DQ_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   1092a:	8c e1       	addi45 $r7,#0x1
   1092c:	5a 78 08 ec 	bnec $r7,#0x8,10904 <do_calibration_DQ_DQS_READ+0xd2>
   10930:	85 21       	movi55 $r9,#0x1
   10932:	d5 94       	j8 1085a <do_calibration_DQ_DQS_READ+0x28>
   10934:	85 40       	movi55 $r10,#0x0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   10936:	50 df 80 d0 	addi $r13,$sp,#0xd0
        }

        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+DLSEL_RD_count;
   1093a:	f0 01       	lwi37.sp $r0,[+#0x4]
   1093c:	14 af 80 01 	swi $r10,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   10940:	f0 01       	lwi37.sp $r0,[+#0x4]
   10942:	b6 0b       	swi450 $r0,[$r11]
   10944:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10946:	b4 06       	lwi450 $r0,[$r6]
   10948:	f0 88       	swi37.sp $r0,[+#0x20]
   1094a:	f0 08       	lwi37.sp $r0,[+#0x20]
   1094c:	8e e1       	subi45 $r7,#0x1
   1094e:	b6 06       	swi450 $r0,[$r6]
   10950:	cf fb       	bnez38 $r7,10946 <do_calibration_DQ_DQS_READ+0x114>

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
   10952:	80 07       	mov55 $r0,$r7
   10954:	fa 30       	movpi45 $r1,#0x20
   10956:	49 ff ff 10 	jal 10776 <Write_Read_compare>
   1095a:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]
            }
        }

        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   1095e:	8d 41       	addi45 $r10,#0x1
   10960:	5a a8 08 ed 	bnec $r10,#0x8,1093a <do_calibration_DQ_DQS_READ+0x108>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   10964:	50 df 80 f0 	addi $r13,$sp,#0xf0

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<8);
   10968:	f0 01       	lwi37.sp $r0,[+#0x4]
   1096a:	40 03 a0 08 	slli $r0,$r7,#0x8
   1096e:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   10970:	f0 01       	lwi37.sp $r0,[+#0x4]
   10972:	b6 0b       	swi450 $r0,[$r11]
   10974:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10976:	b4 06       	lwi450 $r0,[$r6]
   10978:	f0 89       	swi37.sp $r0,[+#0x24]
   1097a:	f0 09       	lwi37.sp $r0,[+#0x24]
   1097c:	8f 41       	subi45 $r10,#0x1
   1097e:	b6 06       	swi450 $r0,[$r6]
   10980:	4e a3 ff fb 	bnez $r10,10976 <do_calibration_DQ_DQS_READ+0x144>

                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
   10984:	84 01       	movi55 $r0,#0x1
   10986:	fa 30       	movpi45 $r1,#0x20
   10988:	49 ff fe f7 	jal 10776 <Write_Read_compare>
   1098c:	38 06 9e 0a 	sw $r0,[$r13+($r7<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B0_table[DLSEL_RD_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   10990:	8c e1       	addi45 $r7,#0x1
   10992:	5a 78 08 eb 	bnec $r7,#0x8,10968 <do_calibration_DQ_DQS_READ+0x136>
   10996:	80 ea       	mov55 $r7,$r10
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   10998:	50 df 81 10 	addi $r13,$sp,#0x110
                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<16);
   1099c:	f0 01       	lwi37.sp $r0,[+#0x4]
   1099e:	40 03 c0 08 	slli $r0,$r7,#0x10
   109a2:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   109a4:	f0 01       	lwi37.sp $r0,[+#0x4]
   109a6:	b6 0b       	swi450 $r0,[$r11]
   109a8:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   109aa:	b4 06       	lwi450 $r0,[$r6]
   109ac:	f0 8a       	swi37.sp $r0,[+#0x28]
   109ae:	f0 0a       	lwi37.sp $r0,[+#0x28]
   109b0:	8f 41       	subi45 $r10,#0x1
   109b2:	b6 06       	swi450 $r0,[$r6]
   109b4:	4e a3 ff fb 	bnez $r10,109aa <do_calibration_DQ_DQS_READ+0x178>

                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
   109b8:	84 02       	movi55 $r0,#0x2
   109ba:	fa 30       	movpi45 $r1,#0x20
   109bc:	49 ff fe dd 	jal 10776 <Write_Read_compare>
   109c0:	38 06 9e 0a 	sw $r0,[$r13+($r7<<#0x2)]

                DQS_RD_B1_table[DLSEL_RD_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   109c4:	8c e1       	addi45 $r7,#0x1
   109c6:	5a 78 08 eb 	bnec $r7,#0x8,1099c <do_calibration_DQ_DQS_READ+0x16a>
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   109ca:	50 df 81 30 	addi $r13,$sp,#0x130
                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
                reg24_value = (reg24_value & 0x0000000)+(DLSEL_RD_count<<24);
   109ce:	f0 01       	lwi37.sp $r0,[+#0x4]
   109d0:	40 05 60 08 	slli $r0,$r10,#0x18
   109d4:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   109d6:	f0 01       	lwi37.sp $r0,[+#0x4]
   109d8:	b6 0b       	swi450 $r0,[$r11]
   109da:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   109dc:	b4 06       	lwi450 $r0,[$r6]
   109de:	f0 8b       	swi37.sp $r0,[+#0x2c]
   109e0:	f0 0b       	lwi37.sp $r0,[+#0x2c]
   109e2:	8e e1       	subi45 $r7,#0x1
   109e4:	b6 06       	swi450 $r0,[$r6]
   109e6:	cf fb       	bnez38 $r7,109dc <do_calibration_DQ_DQS_READ+0x1aa>

                DQS_RD_B3_table[DLSEL_RD_count] = Write_Read_compare(3, ddr_bus_bit);
   109e8:	84 03       	movi55 $r0,#0x3
   109ea:	fa 30       	movpi45 $r1,#0x20
   109ec:	49 ff fe c5 	jal 10776 <Write_Read_compare>
   109f0:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]

                DQS_RD_B2_table[DLSEL_RD_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_count = 0; DLSEL_RD_count < 8; DLSEL_RD_count++) {
   109f4:	8d 41       	addi45 $r10,#0x1
   109f6:	5a a8 08 ec 	bnec $r10,#0x8,109ce <do_calibration_DQ_DQS_READ+0x19c>
    unsigned int DQS_RD_FALL_B3_result;


    //:step 3 read eye traning
    // RD
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   109fa:	5a 98 01 9b 	bnec $r9,#0x1,10930 <do_calibration_DQ_DQS_READ+0xfe>

    // RD FALL
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   109fe:	46 cf 05 00 	sethi $r12,#0xf0500
        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a02:	50 b6 01 30 	addi $r11,$r12,#0x130
                LOOPDELAY_10USEC(1); // wait 10us
   10a06:	46 9f 00 00 	sethi $r9,#0xf0000
    }

    // RD FALL
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
   10a0a:	f0 02       	lwi37.sp $r0,[+#0x8]
   10a0c:	44 00 11 11 	movi $r0,#0x1111
   10a10:	fe 3c       	mul33 $r0,$r7
   10a12:	f0 82       	swi37.sp $r0,[+#0x8]
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10a14:	f0 02       	lwi37.sp $r0,[+#0x8]
   10a16:	14 06 00 1b 	swi $r0,[$r12+#0x6c]
        if (DQSDLSEL_count == 0) {
   10a1a:	cf 61       	bnez38 $r7,10adc <do_calibration_DQ_DQS_READ+0x2aa>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10a1c:	50 af 81 50 	addi $r10,$sp,#0x150
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
   10a20:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a22:	f7 83       	swi37.sp $r7,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a24:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a26:	b6 0b       	swi450 $r0,[$r11]
   10a28:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10a2a:	b4 09       	lwi450 $r0,[$r9]
   10a2c:	f0 8c       	swi37.sp $r0,[+#0x30]
   10a2e:	f0 0c       	lwi37.sp $r0,[+#0x30]
   10a30:	8e c1       	subi45 $r6,#0x1
   10a32:	b6 09       	swi450 $r0,[$r9]
   10a34:	ce fb       	bnez38 $r6,10a2a <do_calibration_DQ_DQS_READ+0x1f8>

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10a36:	80 06       	mov55 $r0,$r6
   10a38:	fa 30       	movpi45 $r1,#0x20
   10a3a:	49 ff fe 9e 	jal 10776 <Write_Read_compare>
   10a3e:	38 05 1e 0a 	sw $r0,[$r10+($r7<<#0x2)]
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x1111);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10a42:	8c e1       	addi45 $r7,#0x1
   10a44:	5a 78 08 ee 	bnec $r7,#0x8,10a20 <do_calibration_DQ_DQS_READ+0x1ee>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10a48:	50 af 81 70 	addi $r10,$sp,#0x170

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
   10a4c:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a4e:	40 03 20 08 	slli $r0,$r6,#0x8
   10a52:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a54:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a56:	b6 0b       	swi450 $r0,[$r11]
   10a58:	84 ef       	movi55 $r7,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10a5a:	b4 09       	lwi450 $r0,[$r9]
   10a5c:	f0 8d       	swi37.sp $r0,[+#0x34]
   10a5e:	f0 0d       	lwi37.sp $r0,[+#0x34]
   10a60:	8e e1       	subi45 $r7,#0x1
   10a62:	b6 09       	swi450 $r0,[$r9]
   10a64:	cf fb       	bnez38 $r7,10a5a <do_calibration_DQ_DQS_READ+0x228>

                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10a66:	84 01       	movi55 $r0,#0x1
   10a68:	fa 30       	movpi45 $r1,#0x20
   10a6a:	49 ff fe 86 	jal 10776 <Write_Read_compare>
   10a6e:	38 05 1a 0a 	sw $r0,[$r10+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10a72:	8c c1       	addi45 $r6,#0x1
   10a74:	5a 68 08 ec 	bnec $r6,#0x8,10a4c <do_calibration_DQ_DQS_READ+0x21a>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10a78:	50 af 81 90 	addi $r10,$sp,#0x190
                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
   10a7c:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a7e:	40 03 c0 08 	slli $r0,$r7,#0x10
   10a82:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10a84:	f0 03       	lwi37.sp $r0,[+#0xc]
   10a86:	b6 0b       	swi450 $r0,[$r11]
   10a88:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10a8a:	b4 09       	lwi450 $r0,[$r9]
   10a8c:	f0 8e       	swi37.sp $r0,[+#0x38]
   10a8e:	f0 0e       	lwi37.sp $r0,[+#0x38]
   10a90:	8e c1       	subi45 $r6,#0x1
   10a92:	b6 09       	swi450 $r0,[$r9]
   10a94:	ce fb       	bnez38 $r6,10a8a <do_calibration_DQ_DQS_READ+0x258>

                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10a96:	84 02       	movi55 $r0,#0x2
   10a98:	fa 30       	movpi45 $r1,#0x20
   10a9a:	49 ff fe 6e 	jal 10776 <Write_Read_compare>
   10a9e:	38 05 1e 0a 	sw $r0,[$r10+($r7<<#0x2)]

                DQ_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10aa2:	8c e1       	addi45 $r7,#0x1
   10aa4:	5a 78 08 ec 	bnec $r7,#0x8,10a7c <do_calibration_DQ_DQS_READ+0x24a>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10aa8:	50 7f 81 b0 	addi $r7,$sp,#0x1b0
                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
   10aac:	f0 03       	lwi37.sp $r0,[+#0xc]
   10aae:	40 03 60 08 	slli $r0,$r6,#0x18
   10ab2:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10ab4:	f0 03       	lwi37.sp $r0,[+#0xc]
   10ab6:	b6 0b       	swi450 $r0,[$r11]
   10ab8:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10aba:	b4 29       	lwi450 $r1,[$r9]
   10abc:	f1 8f       	swi37.sp $r1,[+#0x3c]
   10abe:	f1 0f       	lwi37.sp $r1,[+#0x3c]
   10ac0:	8e 01       	subi45 $r0,#0x1
   10ac2:	b6 29       	swi450 $r1,[$r9]
   10ac4:	c8 fb       	bnez38 $r0,10aba <do_calibration_DQ_DQS_READ+0x288>

                DQ_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10ac6:	84 03       	movi55 $r0,#0x3
   10ac8:	fa 30       	movpi45 $r1,#0x20
   10aca:	49 ff fe 56 	jal 10776 <Write_Read_compare>
   10ace:	38 03 9a 0a 	sw $r0,[$r7+($r6<<#0x2)]

                DQ_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10ad2:	8c c1       	addi45 $r6,#0x1
   10ad4:	5a 68 08 ec 	bnec $r6,#0x8,10aac <do_calibration_DQ_DQS_READ+0x27a>
   10ad8:	84 e1       	movi55 $r7,#0x1
   10ada:	d5 98       	j8 10a0a <do_calibration_DQ_DQS_READ+0x1d8>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10adc:	50 0f 81 d0 	addi $r0,$sp,#0x1d0
   10ae0:	6a 07 00 09 	fmtsr $r0,$fs14
   10ae4:	85 40       	movi55 $r10,#0x0

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+DLSEL_RD_FALL_count;
   10ae6:	f0 03       	lwi37.sp $r0,[+#0xc]
   10ae8:	14 af 80 03 	swi $r10,[$sp+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10aec:	f0 03       	lwi37.sp $r0,[+#0xc]
   10aee:	b6 0b       	swi450 $r0,[$r11]
   10af0:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10af2:	b4 09       	lwi450 $r0,[$r9]
   10af4:	f0 90       	swi37.sp $r0,[+#0x40]
   10af6:	f0 10       	lwi37.sp $r0,[+#0x40]
   10af8:	8e c1       	subi45 $r6,#0x1
   10afa:	b6 09       	swi450 $r0,[$r9]
   10afc:	ce fb       	bnez38 $r6,10af2 <do_calibration_DQ_DQS_READ+0x2c0>

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
   10afe:	fa 30       	movpi45 $r1,#0x20
   10b00:	80 06       	mov55 $r0,$r6
   10b02:	49 ff fe 3a 	jal 10776 <Write_Read_compare>
   10b06:	6a 17 00 01 	fmfsr $r1,$fs14
   10b0a:	38 00 aa 0a 	sw $r0,[$r1+($r10<<#0x2)]
            }

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10b0e:	8d 41       	addi45 $r10,#0x1
   10b10:	5a a8 08 eb 	bnec $r10,#0x8,10ae6 <do_calibration_DQ_DQS_READ+0x2b4>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10b14:	50 0f 81 f0 	addi $r0,$sp,#0x1f0
   10b18:	6a 07 80 09 	fmtsr $r0,$fs15

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<8);
   10b1c:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b1e:	40 03 20 08 	slli $r0,$r6,#0x8
   10b22:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10b24:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b26:	b6 0b       	swi450 $r0,[$r11]
   10b28:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10b2a:	b4 09       	lwi450 $r0,[$r9]
   10b2c:	f0 91       	swi37.sp $r0,[+#0x44]
   10b2e:	f0 11       	lwi37.sp $r0,[+#0x44]
   10b30:	8f 41       	subi45 $r10,#0x1
   10b32:	b6 09       	swi450 $r0,[$r9]
   10b34:	4e a3 ff fb 	bnez $r10,10b2a <do_calibration_DQ_DQS_READ+0x2f8>

                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
   10b38:	fa 30       	movpi45 $r1,#0x20
   10b3a:	84 01       	movi55 $r0,#0x1
   10b3c:	49 ff fe 1d 	jal 10776 <Write_Read_compare>
   10b40:	6a 17 80 01 	fmfsr $r1,$fs15
   10b44:	38 00 9a 0a 	sw $r0,[$r1+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B0_table[DLSEL_RD_FALL_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10b48:	8c c1       	addi45 $r6,#0x1
   10b4a:	5a 68 08 e9 	bnec $r6,#0x8,10b1c <do_calibration_DQ_DQS_READ+0x2ea>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10b4e:	50 0f 82 10 	addi $r0,$sp,#0x210
   10b52:	6a 06 80 09 	fmtsr $r0,$fs13
                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<16);
   10b56:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b58:	40 05 40 08 	slli $r0,$r10,#0x10
   10b5c:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10b5e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b60:	b6 0b       	swi450 $r0,[$r11]
   10b62:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10b64:	b4 09       	lwi450 $r0,[$r9]
   10b66:	f0 92       	swi37.sp $r0,[+#0x48]
   10b68:	f0 12       	lwi37.sp $r0,[+#0x48]
   10b6a:	8e c1       	subi45 $r6,#0x1
   10b6c:	b6 09       	swi450 $r0,[$r9]
   10b6e:	ce fb       	bnez38 $r6,10b64 <do_calibration_DQ_DQS_READ+0x332>

                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
   10b70:	fa 30       	movpi45 $r1,#0x20
   10b72:	84 02       	movi55 $r0,#0x2
   10b74:	49 ff fe 01 	jal 10776 <Write_Read_compare>
   10b78:	6a 16 80 01 	fmfsr $r1,$fs13
   10b7c:	38 00 aa 0a 	sw $r0,[$r1+($r10<<#0x2)]

                DQS_RD_FALL_B1_table[DLSEL_RD_FALL_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10b80:	8d 41       	addi45 $r10,#0x1
   10b82:	5a a8 08 ea 	bnec $r10,#0x8,10b56 <do_calibration_DQ_DQS_READ+0x324>
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10b86:	50 0f 82 30 	addi $r0,$sp,#0x230
   10b8a:	6a 06 00 09 	fmtsr $r0,$fs12
                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
                reg130_value = (reg130_value & 0x0000000)+(DLSEL_RD_FALL_count<<24);
   10b8e:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b90:	40 03 60 08 	slli $r0,$r6,#0x18
   10b94:	f0 83       	swi37.sp $r0,[+#0xc]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = reg130_value;
   10b96:	f0 03       	lwi37.sp $r0,[+#0xc]
   10b98:	b6 0b       	swi450 $r0,[$r11]
   10b9a:	84 2f       	movi55 $r1,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10b9c:	b4 09       	lwi450 $r0,[$r9]
   10b9e:	f0 93       	swi37.sp $r0,[+#0x4c]
   10ba0:	f0 13       	lwi37.sp $r0,[+#0x4c]
   10ba2:	8e 21       	subi45 $r1,#0x1
   10ba4:	b6 09       	swi450 $r0,[$r9]
   10ba6:	c9 fb       	bnez38 $r1,10b9c <do_calibration_DQ_DQS_READ+0x36a>

                DQS_RD_FALL_B3_table[DLSEL_RD_FALL_count] = Write_Read_compare(3, ddr_bus_bit);
   10ba8:	fa 30       	movpi45 $r1,#0x20
   10baa:	84 03       	movi55 $r0,#0x3
   10bac:	49 ff fd e5 	jal 10776 <Write_Read_compare>
   10bb0:	6a 16 00 01 	fmfsr $r1,$fs12
   10bb4:	38 00 9a 0a 	sw $r0,[$r1+($r6<<#0x2)]

                DQS_RD_FALL_B2_table[DLSEL_RD_FALL_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_RD_FALL_count = 0; DLSEL_RD_FALL_count < 8; DLSEL_RD_FALL_count++) {
   10bb8:	8c c1       	addi45 $r6,#0x1
   10bba:	5a 68 08 ea 	bnec $r6,#0x8,10b8e <do_calibration_DQ_DQS_READ+0x35c>
            }
        }
    }

    // RD FALL
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10bbe:	5a 78 01 8d 	bnec $r7,#0x1,10ad8 <do_calibration_DQ_DQS_READ+0x2a6>
        }

    }

    // select middle value of passed read DQ/DQS value
    DQ_RD_B0_result = find_center(DQ_RD_B0_table, 8);
   10bc2:	80 26       	mov55 $r1,$r6
   10bc4:	b0 14       	addri36.sp $r0,#0x50
   10bc6:	49 ff fd af 	jal 10724 <find_center>
   10bca:	6a 04 80 09 	fmtsr $r0,$fs9
    DQ_RD_B1_result = find_center(DQ_RD_B1_table, 8);
   10bce:	80 26       	mov55 $r1,$r6
   10bd0:	b0 1c       	addri36.sp $r0,#0x70
   10bd2:	49 ff fd a9 	jal 10724 <find_center>
   10bd6:	6a 04 00 09 	fmtsr $r0,$fs8
    DQ_RD_B2_result = find_center(DQ_RD_B2_table, 8);
   10bda:	80 26       	mov55 $r1,$r6
   10bdc:	b0 24       	addri36.sp $r0,#0x90
   10bde:	49 ff fd a3 	jal 10724 <find_center>
   10be2:	6a 05 80 09 	fmtsr $r0,$fs11
    DQ_RD_B3_result = find_center(DQ_RD_B3_table, 8);
   10be6:	80 26       	mov55 $r1,$r6
   10be8:	b0 2c       	addri36.sp $r0,#0xb0
   10bea:	49 ff fd 9d 	jal 10724 <find_center>
   10bee:	6a 05 00 09 	fmtsr $r0,$fs10
    DQ_RD_FALL_B0_result = find_center(DQ_RD_FALL_B0_table, 8);
   10bf2:	80 26       	mov55 $r1,$r6
   10bf4:	50 0f 81 50 	addi $r0,$sp,#0x150
   10bf8:	49 ff fd 96 	jal 10724 <find_center>
   10bfc:	83 80       	mov55 $fp,$r0
    DQ_RD_FALL_B1_result = find_center(DQ_RD_FALL_B1_table, 8);
   10bfe:	80 26       	mov55 $r1,$r6
   10c00:	50 0f 81 70 	addi $r0,$sp,#0x170
   10c04:	49 ff fd 90 	jal 10724 <find_center>
   10c08:	81 00       	mov55 $r8,$r0
    DQ_RD_FALL_B2_result = find_center(DQ_RD_FALL_B2_table, 8);
   10c0a:	80 26       	mov55 $r1,$r6
   10c0c:	50 0f 81 90 	addi $r0,$sp,#0x190
   10c10:	49 ff fd 8a 	jal 10724 <find_center>
   10c14:	6a 03 80 09 	fmtsr $r0,$fs7
    DQ_RD_FALL_B3_result = find_center(DQ_RD_FALL_B3_table, 8);
   10c18:	80 26       	mov55 $r1,$r6
   10c1a:	50 0f 81 b0 	addi $r0,$sp,#0x1b0
   10c1e:	49 ff fd 83 	jal 10724 <find_center>
   10c22:	6a 03 00 09 	fmtsr $r0,$fs6

    DQS_RD_B0_result = find_center(DQS_RD_B0_table, 8);
   10c26:	80 26       	mov55 $r1,$r6
   10c28:	b0 34       	addri36.sp $r0,#0xd0
   10c2a:	49 ff fd 7d 	jal 10724 <find_center>
   10c2e:	81 80       	mov55 $r12,$r0
    DQS_RD_B1_result = find_center(DQS_RD_B1_table, 8);
   10c30:	80 26       	mov55 $r1,$r6
   10c32:	b0 3c       	addri36.sp $r0,#0xf0
   10c34:	49 ff fd 78 	jal 10724 <find_center>
   10c38:	81 60       	mov55 $r11,$r0
    DQS_RD_B2_result = find_center(DQS_RD_B2_table, 8);
   10c3a:	80 26       	mov55 $r1,$r6
   10c3c:	50 0f 81 10 	addi $r0,$sp,#0x110
   10c40:	49 ff fd 72 	jal 10724 <find_center>
   10c44:	81 c0       	mov55 $r14,$r0
    DQS_RD_B3_result = find_center(DQS_RD_B3_table, 8);
   10c46:	80 26       	mov55 $r1,$r6
   10c48:	50 0f 81 30 	addi $r0,$sp,#0x130
   10c4c:	49 ff fd 6c 	jal 10724 <find_center>
   10c50:	81 a0       	mov55 $r13,$r0
    DQS_RD_FALL_B0_result = find_center(DQS_RD_FALL_B0_table, 8);
   10c52:	6a 07 00 01 	fmfsr $r0,$fs14
   10c56:	80 26       	mov55 $r1,$r6
   10c58:	49 ff fd 66 	jal 10724 <find_center>
   10c5c:	81 40       	mov55 $r10,$r0
    DQS_RD_FALL_B1_result = find_center(DQS_RD_FALL_B1_table, 8);
   10c5e:	6a 07 80 01 	fmfsr $r0,$fs15
   10c62:	80 26       	mov55 $r1,$r6
   10c64:	49 ff fd 60 	jal 10724 <find_center>
   10c68:	81 20       	mov55 $r9,$r0
    DQS_RD_FALL_B2_result = find_center(DQS_RD_FALL_B2_table, 8);
   10c6a:	6a 06 80 01 	fmfsr $r0,$fs13
   10c6e:	80 26       	mov55 $r1,$r6
   10c70:	49 ff fd 5a 	jal 10724 <find_center>
   10c74:	80 e0       	mov55 $r7,$r0
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);
   10c76:	6a 06 00 01 	fmfsr $r0,$fs12
   10c7a:	80 26       	mov55 $r1,$r6
   10c7c:	49 ff fd 54 	jal 10724 <find_center>


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
   10c80:	6a 15 80 01 	fmfsr $r1,$fs11
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQ_RD_FALL_B3_result << 24)
        | (DQ_RD_FALL_B2_result << 16) 
   10c84:	6a 33 00 01 	fmfsr $r3,$fs6
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
   10c88:	40 20 c0 08 	slli $r2,$r1,#0x10
   10c8c:	6a 15 00 01 	fmfsr $r1,$fs10
        | (DQ_RD_FALL_B0_result);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
   10c90:	40 e7 40 08 	slli $r14,$r14,#0x10
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
   10c94:	40 21 07 04 	or_slli $r2,$r2,$r1,#0x18
   10c98:	6a 14 80 01 	fmfsr $r1,$fs9
        | (DQ_RD_FALL_B0_result);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
   10c9c:	40 d7 37 04 	or_slli $r13,$r14,$r13,#0x18
   10ca0:	fe 8f       	or33 $r2,$r1

    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
        | (DQ_RD_B1_result << 8) 
        | (DQ_RD_B0_result);
   10ca2:	6a 14 00 01 	fmfsr $r1,$fs8
   10ca6:	40 c6 b0 04 	or $r12,$r13,$r12
   10caa:	40 21 05 04 	or_slli $r2,$r2,$r1,#0x8
    DQS_RD_FALL_B1_result = find_center(DQS_RD_FALL_B1_table, 8);
    DQS_RD_FALL_B2_result = find_center(DQS_RD_FALL_B2_table, 8);
    DQS_RD_FALL_B3_result = find_center(DQS_RD_FALL_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
   10cae:	46 1f 05 00 	sethi $r1,#0xf0500
   10cb2:	14 20 80 09 	swi $r2,[$r1+#0x24]
        (DQ_RD_B3_result << 24)
        | (DQ_RD_B2_result << 16)
        | (DQ_RD_B1_result << 8) 
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10cb6:	f2 02       	lwi37.sp $r2,[+#0x8]
   10cb8:	14 20 80 1b 	swi $r2,[$r1+#0x6c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQ_RD_FALL_B3_result << 24)
        | (DQ_RD_FALL_B2_result << 16) 
   10cbc:	6a 23 80 01 	fmfsr $r2,$fs7

    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
        | (DQS_RD_B1_result << 8)  
        | (DQS_RD_B0_result);
   10cc0:	40 b6 2d 04 	or_slli $r11,$r12,$r11,#0x8
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQ_RD_FALL_B3_result << 24)
        | (DQ_RD_FALL_B2_result << 16) 
   10cc4:	40 21 40 08 	slli $r2,$r2,#0x10
   10cc8:	40 21 0f 04 	or_slli $r2,$r2,$r3,#0x18
   10ccc:	41 c1 70 04 	or $fp,$r2,$fp
        | (DQ_RD_FALL_B1_result << 8)  
        | (DQ_RD_FALL_B0_result);
   10cd0:	40 8e 21 04 	or_slli $r8,$fp,$r8,#0x8
        | (DQ_RD_B2_result << 16)
        | (DQ_RD_B1_result << 8) 
        | (DQ_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
   10cd4:	14 80 80 4c 	swi $r8,[$r1+#0x130]
        | (DQ_RD_FALL_B2_result << 16) 
        | (DQ_RD_FALL_B1_result << 8)  
        | (DQ_RD_FALL_B0_result);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = 
   10cd8:	14 b0 80 09 	swi $r11,[$r1+#0x24]
        (DQS_RD_B3_result << 24)
        | (DQS_RD_B2_result << 16) 
        | (DQS_RD_B1_result << 8)  
        | (DQS_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10cdc:	f2 02       	lwi37.sp $r2,[+#0x8]
   10cde:	14 20 80 1b 	swi $r2,[$r1+#0x6c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
        (DQS_RD_FALL_B3_result << 24)
        | (DQS_RD_FALL_B2_result << 16) 
   10ce2:	40 23 c0 08 	slli $r2,$r7,#0x10
   10ce6:	40 01 03 04 	or_slli $r0,$r2,$r0,#0x18
   10cea:	40 20 28 04 	or $r2,$r0,$r10
        | (DQS_RD_FALL_B1_result << 8)  
        | (DQS_RD_FALL_B0_result);
   10cee:	40 91 25 04 	or_slli $r9,$r2,$r9,#0x8
        | (DQS_RD_B2_result << 16) 
        | (DQS_RD_B1_result << 8)  
        | (DQS_RD_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x130) = 
   10cf2:	14 90 80 4c 	swi $r9,[$r1+#0x130]
    //    }
    //}
    //DQS_RD_FALL_B3_result = final_center;


}
   10cf6:	51 ff 82 50 	addi $sp,$sp,#0x250
   10cfa:	34 3f 80 00 	fldi $fd3,[$sp+#0x0]
   10cfe:	34 4f 80 02 	fldi $fd4,[$sp+#0x8]
   10d02:	34 5f 80 04 	fldi $fd5,[$sp+#0x10]
   10d06:	34 6f 80 06 	fldi $fd6,[$sp+#0x18]
   10d0a:	34 7f 80 08 	fldi $fd7,[$sp+#0x20]
   10d0e:	fc e5       	pop25 $r14,#40    ! {$r6~$r14, $fp, $gp, $lp}

00010d10 <do_calibration_DQ_DQS_WRITE>:




static void do_calibration_DQ_DQS_WRITE()
{
   10d10:	fc 60       	push25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}
   10d12:	ee d8       	addi10.sp #-296

    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10d14:	46 cf 05 00 	sethi $r12,#0xf0500
    unsigned int DQS_WR_B2_result;
    unsigned int DQS_WR_B3_result;


    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10d18:	85 20       	movi55 $r9,#0x0
        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10d1a:	50 b6 00 78 	addi $r11,$r12,#0x78
                LOOPDELAY_10USEC(1); // wait 10us
   10d1e:	46 7f 00 00 	sethi $r7,#0xf0000


    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
   10d22:	b4 1f       	lwi450 $r0,[$sp]
   10d24:	44 00 22 22 	movi $r0,#0x2222
   10d28:	42 04 80 24 	mul $r0,$r9,$r0
   10d2c:	b6 1f       	swi450 $r0,[$sp]
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10d2e:	b4 1f       	lwi450 $r0,[$sp]
   10d30:	14 06 00 1b 	swi $r0,[$r12+#0x6c]
        if (DQSDLSEL_count == 0) {
   10d34:	4e 93 00 64 	bnez $r9,10dfc <do_calibration_DQ_DQS_WRITE+0xec>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10d38:	50 af 80 28 	addi $r10,$sp,#0x28
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
   10d3c:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d3e:	14 9f 80 01 	swi $r9,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10d42:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d44:	b6 0b       	swi450 $r0,[$r11]
   10d46:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10d48:	b4 07       	lwi450 $r0,[$r7]
   10d4a:	f0 82       	swi37.sp $r0,[+#0x8]
   10d4c:	f0 02       	lwi37.sp $r0,[+#0x8]
   10d4e:	8e c1       	subi45 $r6,#0x1
   10d50:	b6 07       	swi450 $r0,[$r7]
   10d52:	ce fb       	bnez38 $r6,10d48 <do_calibration_DQ_DQS_WRITE+0x38>

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10d54:	80 06       	mov55 $r0,$r6
   10d56:	fa 30       	movpi45 $r1,#0x20
   10d58:	49 ff fd 0f 	jal 10776 <Write_Read_compare>
   10d5c:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]
        // DQ / DQS select
        reg6C_value = (reg6C_value & 0x0000000)+(DQSDLSEL_count*0x2222);
        *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
        if (DQSDLSEL_count == 0) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10d60:	8d 21       	addi45 $r9,#0x1
   10d62:	5a 98 08 ed 	bnec $r9,#0x8,10d3c <do_calibration_DQ_DQS_WRITE+0x2c>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10d66:	50 af 80 48 	addi $r10,$sp,#0x48

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
   10d6a:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d6c:	40 03 20 08 	slli $r0,$r6,#0x8
   10d70:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10d72:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d74:	b6 0b       	swi450 $r0,[$r11]
   10d76:	85 2f       	movi55 $r9,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10d78:	b4 07       	lwi450 $r0,[$r7]
   10d7a:	f0 83       	swi37.sp $r0,[+#0xc]
   10d7c:	f0 03       	lwi37.sp $r0,[+#0xc]
   10d7e:	8f 21       	subi45 $r9,#0x1
   10d80:	b6 07       	swi450 $r0,[$r7]
   10d82:	4e 93 ff fb 	bnez $r9,10d78 <do_calibration_DQ_DQS_WRITE+0x68>

                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10d86:	84 01       	movi55 $r0,#0x1
   10d88:	fa 30       	movpi45 $r1,#0x20
   10d8a:	49 ff fc f6 	jal 10776 <Write_Read_compare>
   10d8e:	38 05 1a 0a 	sw $r0,[$r10+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10d92:	8c c1       	addi45 $r6,#0x1
   10d94:	5a 68 08 eb 	bnec $r6,#0x8,10d6a <do_calibration_DQ_DQS_WRITE+0x5a>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10d98:	50 af 80 68 	addi $r10,$sp,#0x68
                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
   10d9c:	f0 01       	lwi37.sp $r0,[+#0x4]
   10d9e:	40 04 c0 08 	slli $r0,$r9,#0x10
   10da2:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10da4:	f0 01       	lwi37.sp $r0,[+#0x4]
   10da6:	b6 0b       	swi450 $r0,[$r11]
   10da8:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10daa:	b4 07       	lwi450 $r0,[$r7]
   10dac:	f0 84       	swi37.sp $r0,[+#0x10]
   10dae:	f0 04       	lwi37.sp $r0,[+#0x10]
   10db0:	8e c1       	subi45 $r6,#0x1
   10db2:	b6 07       	swi450 $r0,[$r7]
   10db4:	ce fb       	bnez38 $r6,10daa <do_calibration_DQ_DQS_WRITE+0x9a>

                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10db6:	84 02       	movi55 $r0,#0x2
   10db8:	fa 30       	movpi45 $r1,#0x20
   10dba:	49 ff fc de 	jal 10776 <Write_Read_compare>
   10dbe:	38 05 26 0a 	sw $r0,[$r10+($r9<<#0x2)]

                DQ_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10dc2:	8d 21       	addi45 $r9,#0x1
   10dc4:	5a 98 08 ec 	bnec $r9,#0x8,10d9c <do_calibration_DQ_DQS_WRITE+0x8c>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQ_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10dc8:	50 9f 80 88 	addi $r9,$sp,#0x88
                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
   10dcc:	f0 01       	lwi37.sp $r0,[+#0x4]
   10dce:	40 03 60 08 	slli $r0,$r6,#0x18
   10dd2:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10dd4:	f0 01       	lwi37.sp $r0,[+#0x4]
   10dd6:	b6 0b       	swi450 $r0,[$r11]
   10dd8:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10dda:	b4 27       	lwi450 $r1,[$r7]
   10ddc:	f1 85       	swi37.sp $r1,[+#0x14]
   10dde:	f1 05       	lwi37.sp $r1,[+#0x14]
   10de0:	8e 01       	subi45 $r0,#0x1
   10de2:	b6 27       	swi450 $r1,[$r7]
   10de4:	c8 fb       	bnez38 $r0,10dda <do_calibration_DQ_DQS_WRITE+0xca>

                DQ_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10de6:	84 03       	movi55 $r0,#0x3
   10de8:	fa 30       	movpi45 $r1,#0x20
   10dea:	49 ff fc c6 	jal 10776 <Write_Read_compare>
   10dee:	38 04 9a 0a 	sw $r0,[$r9+($r6<<#0x2)]

                DQ_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10df2:	8c c1       	addi45 $r6,#0x1
   10df4:	5a 68 08 ec 	bnec $r6,#0x8,10dcc <do_calibration_DQ_DQS_WRITE+0xbc>
   10df8:	85 21       	movi55 $r9,#0x1
   10dfa:	d5 94       	j8 10d22 <do_calibration_DQ_DQS_WRITE+0x12>
   10dfc:	85 40       	movi55 $r10,#0x0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10dfe:	50 df 80 a8 	addi $r13,$sp,#0xa8

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+DLSEL_WR_count;
   10e02:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e04:	14 af 80 01 	swi $r10,[$sp+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e08:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e0a:	b6 0b       	swi450 $r0,[$r11]
   10e0c:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10e0e:	b4 07       	lwi450 $r0,[$r7]
   10e10:	f0 86       	swi37.sp $r0,[+#0x18]
   10e12:	f0 06       	lwi37.sp $r0,[+#0x18]
   10e14:	8e c1       	subi45 $r6,#0x1
   10e16:	b6 07       	swi450 $r0,[$r7]
   10e18:	ce fb       	bnez38 $r6,10e0e <do_calibration_DQ_DQS_WRITE+0xfe>

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
   10e1a:	80 06       	mov55 $r0,$r6
   10e1c:	fa 30       	movpi45 $r1,#0x20
   10e1e:	49 ff fc ac 	jal 10776 <Write_Read_compare>
   10e22:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]
            }

        }
        if (DQSDLSEL_count == 1) {
            // byte 0
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10e26:	8d 41       	addi45 $r10,#0x1
   10e28:	5a a8 08 ed 	bnec $r10,#0x8,10e02 <do_calibration_DQ_DQS_WRITE+0xf2>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10e2c:	50 df 80 c8 	addi $r13,$sp,#0xc8

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<8);
   10e30:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e32:	40 03 20 08 	slli $r0,$r6,#0x8
   10e36:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e38:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e3a:	b6 0b       	swi450 $r0,[$r11]
   10e3c:	85 4f       	movi55 $r10,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10e3e:	b4 07       	lwi450 $r0,[$r7]
   10e40:	f0 87       	swi37.sp $r0,[+#0x1c]
   10e42:	f0 07       	lwi37.sp $r0,[+#0x1c]
   10e44:	8f 41       	subi45 $r10,#0x1
   10e46:	b6 07       	swi450 $r0,[$r7]
   10e48:	4e a3 ff fb 	bnez $r10,10e3e <do_calibration_DQ_DQS_WRITE+0x12e>

                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
   10e4c:	84 01       	movi55 $r0,#0x1
   10e4e:	fa 30       	movpi45 $r1,#0x20
   10e50:	49 ff fc 93 	jal 10776 <Write_Read_compare>
   10e54:	38 06 9a 0a 	sw $r0,[$r13+($r6<<#0x2)]
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B0_table[DLSEL_WR_count] = Write_Read_compare(0, ddr_bus_bit);
            }
            // byte 1
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10e58:	8c c1       	addi45 $r6,#0x1
   10e5a:	5a 68 08 eb 	bnec $r6,#0x8,10e30 <do_calibration_DQ_DQS_WRITE+0x120>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10e5e:	50 df 80 e8 	addi $r13,$sp,#0xe8
                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<16);
   10e62:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e64:	40 05 40 08 	slli $r0,$r10,#0x10
   10e68:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e6a:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e6c:	b6 0b       	swi450 $r0,[$r11]
   10e6e:	84 cf       	movi55 $r6,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10e70:	b4 07       	lwi450 $r0,[$r7]
   10e72:	f0 88       	swi37.sp $r0,[+#0x20]
   10e74:	f0 08       	lwi37.sp $r0,[+#0x20]
   10e76:	8e c1       	subi45 $r6,#0x1
   10e78:	b6 07       	swi450 $r0,[$r7]
   10e7a:	ce fb       	bnez38 $r6,10e70 <do_calibration_DQ_DQS_WRITE+0x160>

                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
   10e7c:	84 02       	movi55 $r0,#0x2
   10e7e:	fa 30       	movpi45 $r1,#0x20
   10e80:	49 ff fc 7b 	jal 10776 <Write_Read_compare>
   10e84:	38 06 aa 0a 	sw $r0,[$r13+($r10<<#0x2)]

                DQS_WR_B1_table[DLSEL_WR_count] = Write_Read_compare(1, ddr_bus_bit);
            }

            // byte 2
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10e88:	8d 41       	addi45 $r10,#0x1
   10e8a:	5a a8 08 ec 	bnec $r10,#0x8,10e62 <do_calibration_DQ_DQS_WRITE+0x152>
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
                LOOPDELAY_10USEC(1); // wait 10us

                DQS_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10e8e:	50 af 81 08 	addi $r10,$sp,#0x108
                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
                reg78_value = (reg78_value & 0x0000000)+(DLSEL_WR_count<<24);
   10e92:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e94:	40 03 60 08 	slli $r0,$r6,#0x18
   10e98:	f0 81       	swi37.sp $r0,[+#0x4]
                *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   10e9a:	f0 01       	lwi37.sp $r0,[+#0x4]
   10e9c:	b6 0b       	swi450 $r0,[$r11]
   10e9e:	84 0f       	movi55 $r0,#0xf
                LOOPDELAY_10USEC(1); // wait 10us
   10ea0:	b4 27       	lwi450 $r1,[$r7]
   10ea2:	f1 89       	swi37.sp $r1,[+#0x24]
   10ea4:	f1 09       	lwi37.sp $r1,[+#0x24]
   10ea6:	8e 01       	subi45 $r0,#0x1
   10ea8:	b6 27       	swi450 $r1,[$r7]
   10eaa:	c8 fb       	bnez38 $r0,10ea0 <do_calibration_DQ_DQS_WRITE+0x190>

                DQS_WR_B3_table[DLSEL_WR_count] = Write_Read_compare(3, ddr_bus_bit);
   10eac:	84 03       	movi55 $r0,#0x3
   10eae:	fa 30       	movpi45 $r1,#0x20
   10eb0:	49 ff fc 63 	jal 10776 <Write_Read_compare>
   10eb4:	38 05 1a 0a 	sw $r0,[$r10+($r6<<#0x2)]

                DQS_WR_B2_table[DLSEL_WR_count] = Write_Read_compare(2, ddr_bus_bit);
            }

            // byte 3
            for (DLSEL_WR_count = 0; DLSEL_WR_count < 8; DLSEL_WR_count++) {
   10eb8:	8c c1       	addi45 $r6,#0x1
   10eba:	5a 68 08 ec 	bnec $r6,#0x8,10e92 <do_calibration_DQ_DQS_WRITE+0x182>
    unsigned int DQS_WR_B2_result;
    unsigned int DQS_WR_B3_result;


    //:step 3 write eye traning
    for (DQSDLSEL_count = 0; DQSDLSEL_count < 2; DQSDLSEL_count++) {
   10ebe:	5a 98 01 9d 	bnec $r9,#0x1,10df8 <do_calibration_DQ_DQS_WRITE+0xe8>
        }

    }

    // select middle value of passed write DQ/DQS value
    DQ_WR_B0_result = find_center(DQ_WR_B0_table, 8);
   10ec2:	80 26       	mov55 $r1,$r6
   10ec4:	b0 0a       	addri36.sp $r0,#0x28
   10ec6:	49 ff fc 2f 	jal 10724 <find_center>
   10eca:	81 80       	mov55 $r12,$r0
    DQ_WR_B1_result = find_center(DQ_WR_B1_table, 8);
   10ecc:	80 26       	mov55 $r1,$r6
   10ece:	b0 12       	addri36.sp $r0,#0x48
   10ed0:	49 ff fc 2a 	jal 10724 <find_center>
   10ed4:	81 60       	mov55 $r11,$r0
    DQ_WR_B2_result = find_center(DQ_WR_B2_table, 8);
   10ed6:	80 26       	mov55 $r1,$r6
   10ed8:	b0 1a       	addri36.sp $r0,#0x68
   10eda:	49 ff fc 25 	jal 10724 <find_center>
   10ede:	81 c0       	mov55 $r14,$r0
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);
   10ee0:	80 26       	mov55 $r1,$r6
   10ee2:	b0 22       	addri36.sp $r0,#0x88
   10ee4:	49 ff fc 20 	jal 10724 <find_center>
   10ee8:	81 a0       	mov55 $r13,$r0

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
   10eea:	80 26       	mov55 $r1,$r6
   10eec:	b0 2a       	addri36.sp $r0,#0xa8
   10eee:	49 ff fc 1b 	jal 10724 <find_center>
   10ef2:	81 40       	mov55 $r10,$r0
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
   10ef4:	80 26       	mov55 $r1,$r6
   10ef6:	b0 32       	addri36.sp $r0,#0xc8
   10ef8:	49 ff fc 16 	jal 10724 <find_center>
   10efc:	81 20       	mov55 $r9,$r0
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
   10efe:	80 26       	mov55 $r1,$r6
   10f00:	b0 3a       	addri36.sp $r0,#0xe8
   10f02:	49 ff fc 11 	jal 10724 <find_center>
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
   10f06:	40 e7 40 08 	slli $r14,$r14,#0x10
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);
   10f0a:	80 26       	mov55 $r1,$r6
    DQ_WR_B2_result = find_center(DQ_WR_B2_table, 8);
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
   10f0c:	80 e0       	mov55 $r7,$r0
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
   10f0e:	40 d7 37 04 	or_slli $r13,$r14,$r13,#0x18
    DQ_WR_B3_result = find_center(DQ_WR_B3_table, 8);

    DQS_WR_B0_result = find_center(DQS_WR_B0_table, 8);
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);
   10f12:	50 0f 81 08 	addi $r0,$sp,#0x108
   10f16:	49 ff fc 07 	jal 10724 <find_center>
   10f1a:	40 c6 b0 04 	or $r12,$r13,$r12

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQS_WR_B3_result << 24)
        | (DQS_WR_B2_result << 16) 
   10f1e:	40 73 c0 08 	slli $r7,$r7,#0x10
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
   10f22:	46 1f 05 00 	sethi $r1,#0xf0500
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
        | (DQ_WR_B1_result << 8)  
        | (DQ_WR_B0_result);
   10f26:	40 b6 2d 04 	or_slli $r11,$r12,$r11,#0x8

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQS_WR_B3_result << 24)
        | (DQS_WR_B2_result << 16) 
   10f2a:	40 03 83 04 	or_slli $r0,$r7,$r0,#0x18
    DQS_WR_B1_result = find_center(DQS_WR_B1_table, 8);
    DQS_WR_B2_result = find_center(DQS_WR_B2_table, 8);
    DQS_WR_B3_result = find_center(DQS_WR_B3_table, 8);


    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
   10f2e:	14 b0 80 1e 	swi $r11,[$r1+#0x78]
   10f32:	40 70 28 04 	or $r7,$r0,$r10
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
        | (DQ_WR_B1_result << 8)  
        | (DQ_WR_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10f36:	b4 5f       	lwi450 $r2,[$sp]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
        (DQS_WR_B3_result << 24)
        | (DQS_WR_B2_result << 16) 
        | (DQS_WR_B1_result << 8)  
        | (DQS_WR_B0_result);
   10f38:	40 93 a5 04 	or_slli $r9,$r7,$r9,#0x8
        (DQ_WR_B3_result << 24)
        | (DQ_WR_B2_result << 16) 
        | (DQ_WR_B1_result << 8)  
        | (DQ_WR_B0_result);

    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   10f3c:	14 20 80 1b 	swi $r2,[$r1+#0x6c]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = 
   10f40:	14 90 80 1e 	swi $r9,[$r1+#0x78]
        | (DQS_WR_B2_result << 16) 
        | (DQS_WR_B1_result << 8)  
        | (DQS_WR_B0_result);


}
   10f44:	ed 28       	addi10.sp #0x128
   10f46:	fc e0       	pop25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}

00010f48 <do_calibration_Leveling>:



#else
static void do_calibration_Leveling(int mode)  // write / read leveling
{
   10f48:	fc 60       	push25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}
   10f4a:	51 ff fd f0 	addi $sp,$sp,#-528
   10f4e:	46 1f 05 00 	sethi $r1,#0xf0500
    u32LevelCnt = 2;
#else
    u32LevelCnt = 4;
#endif

    if(mode == 0){
   10f52:	c8 62       	bnez38 $r0,11016 <do_calibration_Leveling+0xce>
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
   10f54:	04 10 80 1a 	lwi $r1,[$r1+#0x68]
   10f58:	f1 82       	swi37.sp $r1,[+#0x8]
		for(i=0;i<u32LevelCnt;i++){
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
			u8Reg[i] = 0;
   10f5a:	80 40       	mov55 $r2,$r0
    if(mode == 0){
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
		for(i=0;i<u32LevelCnt;i++){
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
   10f5c:	f1 02       	lwi37.sp $r1,[+#0x8]
   10f5e:	94 c3       	slli333 $r3,$r0,#0x3
   10f60:	40 10 8c 0d 	srl $r1,$r1,$r3
   10f64:	b0 c3       	addri36.sp $r3,#0xc
   10f66:	38 11 80 08 	sb $r1,[$r3+($r0<<#0x0)]
			u8Reg[i] = 0;
   10f6a:	b0 41       	addri36.sp $r1,#0x4
   10f6c:	38 20 80 08 	sb $r2,[$r1+($r0<<#0x0)]

    if(mode == 0){
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
		for(i=0;i<u32LevelCnt;i++){
   10f70:	8c 01       	addi45 $r0,#0x1
   10f72:	5a 08 04 f5 	bnec $r0,#0x4,10f5c <do_calibration_Leveling+0x14>
		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   10f76:	46 af 05 00 	sethi $r10,#0xf0500
   10f7a:	80 c1       	mov55 $r6,$r1

    if(mode == 0){
		// -------------- Write leveling --------------//
		u32LevelRange = 128;
		reg68_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x68);
		for(i=0;i<u32LevelCnt;i++){
   10f7c:	84 e0       	movi55 $r7,#0x0
		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   10f7e:	50 a5 00 68 	addi $r10,$r10,#0x68
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   10f82:	50 bf 80 10 	addi $r11,$sp,#0x10
			u8Reg[i] = 0;
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
   10f86:	84 00       	movi55 $r0,#0x0
   10f88:	18 03 00 01 	sbi.bi $r0,[$r6],#0x1
			for(j=0;j<u32LevelRange;j++){
   10f8c:	85 20       	movi55 $r9,#0x0
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
   10f8e:	00 1f 80 06 	lbi $r1,[$sp+#0x6]
   10f92:	00 2f 80 07 	lbi $r2,[$sp+#0x7]
   10f96:	40 10 c0 08 	slli $r1,$r1,#0x10
   10f9a:	40 10 8b 04 	or_slli $r1,$r1,$r2,#0x18
   10f9e:	00 2f 80 04 	lbi $r2,[$sp+#0x4]
   10fa2:	fe 57       	or33 $r1,$r2
   10fa4:	00 2f 80 05 	lbi $r2,[$sp+#0x5]
   10fa8:	40 10 89 04 	or_slli $r1,$r1,$r2,#0x8
   10fac:	f1 82       	swi37.sp $r1,[+#0x8]
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   10fae:	f0 02       	lwi37.sp $r0,[+#0x8]
   10fb0:	b6 0a       	swi450 $r0,[$r10]
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   10fb2:	fa 30       	movpi45 $r1,#0x20
   10fb4:	80 07       	mov55 $r0,$r7
   10fb6:	49 ff fb e0 	jal 10776 <Write_Read_compare>
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
   10fba:	00 13 7f ff 	lbi $r1,[$r6+#-1]
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   10fbe:	38 05 a6 0a 	sw $r0,[$r11+($r9<<#0x2)]
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
   10fc2:	8c 21       	addi45 $r1,#0x1
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   10fc4:	8d 21       	addi45 $r9,#0x1
				reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
   10fc6:	10 13 7f ff 	sbi $r1,[$r6+#-1]
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   10fca:	5a 98 80 e2 	bnec $r9,#0x80,10f8e <do_calibration_Leveling+0x46>
				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
				//dbg("Byte[%d] PDLSET value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x68))>>(i*8)) & 0xff, level_table[j] );
				u8Reg[i]++;
			}

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
   10fce:	80 0b       	mov55 $r0,$r11
   10fd0:	80 29       	mov55 $r1,$r9
   10fd2:	49 ff fb a9 	jal 10724 <find_center>
   10fd6:	5a 0f ff 05 	bnec $r0,#-1,10fe0 <do_calibration_Leveling+0x98>
				u8Reg[i] = u8RegDefault[i];	// set to default
   10fda:	b0 03       	addri36.sp $r0,#0xc
   10fdc:	38 00 1c 00 	lb $r0,[$r0+($r7<<#0x0)]
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
			u8Reg[i] = 0;
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   10fe0:	8c e1       	addi45 $r7,#0x1

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
				u8Reg[i] = u8RegDefault[i];	// set to default
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
   10fe2:	10 03 7f ff 	sbi $r0,[$r6+#-1]
			u8RegDefault[i] = ((reg68_value >> (i*8))&0xff);
			u8Reg[i] = 0;
		}

		//dbg("Write Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   10fe6:	5a 78 04 d0 	bnec $r7,#0x4,10f86 <do_calibration_Leveling+0x3e>
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
			//dbg("center: %d\n", s32Center);
		}
		reg68_value = ( (u8Reg[3]<<24) | (u8Reg[2]<<16) | (u8Reg[1]<<8) | (u8Reg[0]<<0) );
   10fea:	00 0f 80 06 	lbi $r0,[$sp+#0x6]
   10fee:	00 1f 80 07 	lbi $r1,[$sp+#0x7]
   10ff2:	40 00 40 08 	slli $r0,$r0,#0x10
   10ff6:	40 00 07 04 	or_slli $r0,$r0,$r1,#0x18
   10ffa:	00 1f 80 04 	lbi $r1,[$sp+#0x4]
   10ffe:	fe 0f       	or33 $r0,$r1
   11000:	00 1f 80 05 	lbi $r1,[$sp+#0x5]
   11004:	40 00 05 04 	or_slli $r0,$r0,$r1,#0x8
   11008:	f0 82       	swi37.sp $r0,[+#0x8]
		*(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   1100a:	f1 02       	lwi37.sp $r1,[+#0x8]
   1100c:	46 0f 05 00 	sethi $r0,#0xf0500
   11010:	14 10 00 1a 	swi $r1,[$r0+#0x68]
   11014:	d5 6e       	j8 110f0 <do_calibration_Leveling+0x1a8>
    }else{
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
   11016:	04 00 80 1d 	lwi $r0,[$r1+#0x74]
   1101a:	f0 83       	swi37.sp $r0,[+#0xc]
		for(i=0;i<u32LevelCnt;i++){
   1101c:	84 00       	movi55 $r0,#0x0
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
			u8Reg[i] = 0;
   1101e:	80 40       	mov55 $r2,$r0
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
		for(i=0;i<u32LevelCnt;i++){
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
   11020:	f1 03       	lwi37.sp $r1,[+#0xc]
   11022:	94 c2       	slli333 $r3,$r0,#0x2
   11024:	40 10 8c 0d 	srl $r1,$r1,$r3
   11028:	96 5f       	fexti33 $r1,#0x3
   1102a:	b0 c2       	addri36.sp $r3,#0x8
   1102c:	38 11 80 08 	sb $r1,[$r3+($r0<<#0x0)]
			u8Reg[i] = 0;
   11030:	b0 41       	addri36.sp $r1,#0x4
   11032:	38 20 80 08 	sb $r2,[$r1+($r0<<#0x0)]
    }else{
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
		for(i=0;i<u32LevelCnt;i++){
   11036:	8c 01       	addi45 $r0,#0x1
   11038:	5a 08 04 f4 	bnec $r0,#0x4,11020 <do_calibration_Leveling+0xd8>
		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   1103c:	46 bf 05 00 	sethi $r11,#0xf0500

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   11040:	46 af 00 00 	sethi $r10,#0xf0000
   11044:	80 c1       	mov55 $r6,$r1
    }else{
		// -------------- Read leveling --------------//

		u32LevelRange = 16;
		reg74_value = *(volatile unsigned int *) (DDR_REG_BASE + 0x74);
		for(i=0;i<u32LevelCnt;i++){
   11046:	84 e0       	movi55 $r7,#0x0
		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   11048:	50 b5 80 74 	addi $r11,$r11,#0x74

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   1104c:	50 a5 00 48 	addi $r10,$r10,#0x48
   11050:	44 80 3f df 	movi $r8,#0x3fdf
			u8Reg[i] = 0;
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
   11054:	84 00       	movi55 $r0,#0x0
   11056:	18 03 00 01 	sbi.bi $r0,[$r6],#0x1
			for(j=0;j<u32LevelRange;j++){
   1105a:	85 20       	movi55 $r9,#0x0
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   1105c:	44 d0 3f ff 	movi $r13,#0x3fff


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   11060:	50 cf 80 10 	addi $r12,$sp,#0x10

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
   11064:	00 1f 80 06 	lbi $r1,[$sp+#0x6]
   11068:	00 2f 80 07 	lbi $r2,[$sp+#0x7]
   1106c:	40 10 a0 08 	slli $r1,$r1,#0x8
   11070:	40 10 89 84 	or_slli $r1,$r1,$r2,#0xc
   11074:	00 2f 80 04 	lbi $r2,[$sp+#0x4]
   11078:	fe 57       	or33 $r1,$r2
   1107a:	00 2f 80 05 	lbi $r2,[$sp+#0x5]
   1107e:	40 10 88 84 	or_slli $r1,$r1,$r2,#0x4
   11082:	f1 83       	swi37.sp $r1,[+#0xc]
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   11084:	f0 03       	lwi37.sp $r0,[+#0xc]
   11086:	b6 0b       	swi450 $r0,[$r11]

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   11088:	fa 30       	movpi45 $r1,#0x20
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   1108a:	b7 0a       	swi450 $r8,[$r10]
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   1108c:	80 07       	mov55 $r0,$r7
			for(j=0;j<u32LevelRange;j++){
				reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
				*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   1108e:	14 d5 00 00 	swi $r13,[$r10+#0x0]


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   11092:	49 ff fb 72 	jal 10776 <Write_Read_compare>
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
   11096:	00 13 7f ff 	lbi $r1,[$r6+#-1]

			    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
			    *(volatile unsigned int *) 0xF0000048 = 0x00003fFf; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
   1109a:	38 06 26 0a 	sw $r0,[$r12+($r9<<#0x2)]
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
   1109e:	8c 21       	addi45 $r1,#0x1
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   110a0:	8d 21       	addi45 $r9,#0x1


				level_table[j] = Write_Read_compare(i, ddr_bus_bit);
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
   110a2:	10 13 7f ff 	sbi $r1,[$r6+#-1]
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
			u8Reg[i] = 0;
			for(j=0;j<u32LevelRange;j++){
   110a6:	5a 98 10 df 	bnec $r9,#0x10,11064 <do_calibration_Leveling+0x11c>
				//dbg("Byte[%d] Cmp Cnt[%d]: %d, reg: 0x%x\n", i, j, level_table[j], *(volatile unsigned int *) (DDR_REG_BASE + 0x74));
				//dbg("Byte[%d] MSDLY value: %d, Match Cnt: %d\n", i, ( (*(volatile unsigned int *) (DDR_REG_BASE + 0x74))>>(i*4)) & 0xff, level_table[j]);
				u8Reg[i]++;
			}

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
   110aa:	80 0c       	mov55 $r0,$r12
   110ac:	80 29       	mov55 $r1,$r9
   110ae:	49 ff fb 3b 	jal 10724 <find_center>
   110b2:	5a 0f ff 05 	bnec $r0,#-1,110bc <do_calibration_Leveling+0x174>
				u8Reg[i] = u8RegDefault[i];	// set to default
   110b6:	b0 02       	addri36.sp $r0,#0x8
   110b8:	38 00 1c 00 	lb $r0,[$r0+($r7<<#0x0)]
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
			u8Reg[i] = 0;
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   110bc:	8c e1       	addi45 $r7,#0x1

			if( (s32Center = find_center(level_table, u32LevelRange)) == -1){
				u8Reg[i] = u8RegDefault[i];	// set to default
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
   110be:	10 03 7f ff 	sbi $r0,[$r6+#-1]
			u8RegDefault[i] = ((reg74_value >> (i*4))&0xf);
			u8Reg[i] = 0;
		}

		//dbg("Read Leveling\n");
		for(i=0;i<u32LevelCnt;i++){
   110c2:	5a 78 04 c9 	bnec $r7,#0x4,11054 <do_calibration_Leveling+0x10c>
				//dbg("can't find window\n");
			}
			else u8Reg[i] = (unsigned char )s32Center;
			//dbg("center: %d\n", s32Center);
		}
		reg74_value = ( (u8Reg[3]<<12) | (u8Reg[2]<<8) | (u8Reg[1]<<4) | (u8Reg[0]<<0) );
   110c6:	00 0f 80 06 	lbi $r0,[$sp+#0x6]
   110ca:	00 1f 80 07 	lbi $r1,[$sp+#0x7]
   110ce:	40 00 20 08 	slli $r0,$r0,#0x8
   110d2:	40 00 05 84 	or_slli $r0,$r0,$r1,#0xc
   110d6:	00 1f 80 04 	lbi $r1,[$sp+#0x4]
   110da:	fe 0f       	or33 $r0,$r1
   110dc:	00 1f 80 05 	lbi $r1,[$sp+#0x5]
   110e0:	40 00 04 84 	or_slli $r0,$r0,$r1,#0x4
   110e4:	f0 83       	swi37.sp $r0,[+#0xc]
		*(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   110e6:	f1 03       	lwi37.sp $r1,[+#0xc]
   110e8:	46 0f 05 00 	sethi $r0,#0xf0500
   110ec:	14 10 00 1d 	swi $r1,[$r0+#0x74]
    }

}
   110f0:	51 ff 82 10 	addi $sp,$sp,#0x210
   110f4:	fc e0       	pop25 $r14,#0    ! {$r6~$r14, $fp, $gp, $lp}

000110f6 <ddr_calibration>:

}
#endif	//DDR_CALIB_TESET

int ddr_calibration(int opt)
{
   110f6:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}

    // memory initialize
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00000) = 0x0;
   110f8:	46 12 00 00 	sethi $r1,#0x20000

}
#endif	//DDR_CALIB_TESET

int ddr_calibration(int opt)
{
   110fc:	80 c0       	mov55 $r6,$r0

    // memory initialize
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00000) = 0x0;
   110fe:	84 00       	movi55 $r0,#0x0
   11100:	b6 01       	swi450 $r0,[$r1]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00004) = 0x0;
   11102:	a8 09       	swi333 $r0,[$r1+#0x4]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00008) = 0x0;
   11104:	a8 0a       	swi333 $r0,[$r1+#0x8]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x0000C) = 0x0;
   11106:	a8 0b       	swi333 $r0,[$r1+#0xc]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00010) = 0x0;
   11108:	a8 0c       	swi333 $r0,[$r1+#0x10]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00014) = 0x0;
   1110a:	a8 0d       	swi333 $r0,[$r1+#0x14]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x00018) = 0x0;
   1110c:	a8 0e       	swi333 $r0,[$r1+#0x18]
    *(volatile unsigned int *) (DDR_MEM_BASE+0x0001C) = 0x0;
   1110e:	a8 0f       	swi333 $r0,[$r1+#0x1c]


#if DDR_CALIB_TESET
    do_calib_test();
#else
    if(opt & DDR_CAL_WLEVEL)
   11110:	96 74       	xlsb33 $r1,$r6
   11112:	c1 03       	beqz38 $r1,11118 <ddr_calibration+0x22>
    	do_calibration_Leveling(0); // write leveling
   11114:	49 ff ff 1a 	jal 10f48 <do_calibration_Leveling>
    if(opt & DDR_CAL_RLEVEL)
   11118:	54 03 00 02 	andi $r0,$r6,#0x2
   1111c:	c0 04       	beqz38 $r0,11124 <ddr_calibration+0x2e>
    	do_calibration_Leveling(1); // read leveling
   1111e:	84 01       	movi55 $r0,#0x1
   11120:	49 ff ff 14 	jal 10f48 <do_calibration_Leveling>
    if(opt & DDR_CAL_GDS)
    	do_calibration_GDS(); // GDS
    if(opt & DDR_CAL_RDQDQS)
   11124:	97 9e       	bmski33 $r6,#0x3
   11126:	c6 05       	beqz38 $r6,11130 <ddr_calibration+0x3a>
    	do_calibration_DQ_DQS_READ(); // DQ/DQS
   11128:	49 ff fb 85 	jal 10832 <do_calibration_DQ_DQS_READ>
    if(opt & DDR_CAL_WDQDQS)
    	do_calibration_DQ_DQS_WRITE(); // DQ/DQS
   1112c:	49 ff fd f2 	jal 10d10 <do_calibration_DQ_DQS_WRITE>
#endif

    // finish condition
    finish();
    return 0;
}
   11130:	84 00       	movi55 $r0,#0x0
   11132:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

00011134 <asic_init>:
#include <stdio.h>
#include "system.h"

void asic_init(void)
{
   11134:	fc 01       	push25 $r6,#8    ! {$r6, $fp, $gp, $lp}
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc

#else	// #if defined(CPU_OVER_CLOCK)

#if defined(DDR_SPEED_500M)
        *(volatile unsigned int *) 0xf0000050 = 0x000002CA; // FPLL 999MHz
   11136:	46 0f 00 00 	sethi $r0,#0xf0000
   1113a:	44 10 02 ca 	movi $r1,#0x2ca
   1113e:	83 80       	mov55 $fp,$r0
   11140:	b9 94       	swi37 $r1,[$fp+#0x50]
        //*(volatile unsigned int *) 0xf0000050 = 0x000002B2; // FPLL 675MHz
        //*(volatile unsigned int *) 0xf0000050 = 0x000002AC; // FPLL 594MHz
#else
#error "unkonw ddr speed"
#endif
        *(volatile unsigned int *) 0xf0000054 = 0x2A1f3210; // MPLL0 297MHz
   11142:	46 12 a1 f3 	sethi $r1,#0x2a1f3
   11146:	50 10 82 10 	addi $r1,$r1,#0x210
   1114a:	b9 95       	swi37 $r1,[$fp+#0x54]
        *(volatile unsigned int *) 0xf0000058 = 0x298f3210; // MPLL1 216MHz
   1114c:	46 12 98 f3 	sethi $r1,#0x298f3
   11150:	50 10 82 10 	addi $r1,$r1,#0x210
   11154:	b9 96       	swi37 $r1,[$fp+#0x58]
   11156:	44 20 00 96 	movi $r2,#0x96
   1115a:	80 20       	mov55 $r1,$r0
        //*(volatile unsigned int *) 0xf0000058 = 0x2e5f3210; // MPLL1 249.75MHz
        //*(volatile unsigned int *) 0xf0000058 = 0x253f3210; // MPLL1 256.5MHz
        //*(volatile unsigned int *) 0xf0000058 = 0x29df3210; // MPLL1 261MHz
        //*(volatile unsigned int *) 0xf0000058 = 0x2e7f3210; // MPLL1 263.25MHz

        LOOPDELAY_10USEC(10);
   1115c:	b4 61       	lwi450 $r3,[$r1]
   1115e:	f3 81       	swi37.sp $r3,[+#0x4]
   11160:	f3 01       	lwi37.sp $r3,[+#0x4]
   11162:	8e 41       	subi45 $r2,#0x1
   11164:	46 0f 00 00 	sethi $r0,#0xf0000
   11168:	b6 61       	swi450 $r3,[$r1]
   1116a:	ca f9       	bnez38 $r2,1115c <asic_init+0x28>

        // IP-Block Clock Setting
#if defined(DDR_SPEED_500M)
	// APB : 62.4375M(FPLL/16), DDR_axi : 249.75M(FPLL/4), CPU_axi : 124.88M(FPLL/8), CPU : 249.75M(FPLL/4)
        *(volatile unsigned int *) 0xf0000000 = 0x0A08080A; // APB, DDR_axi, CPU_axi, CPU
   1116c:	46 10 a0 80 	sethi $r1,#0xa080
   11170:	50 10 88 0a 	addi $r1,$r1,#0x80a
   11174:	b6 20       	swi450 $r1,[$r0]
        //*(volatile unsigned int *) 0xf0000000 = 0x0A08080e; // APB, DDR_axi, CPU_axi, CPU --> MPLL1
	// UART : 27M(XIN), WDT : 6.75M(TIMER), TIMER : 6.75M(XIN/4), QSPI : 142.71M(FPLL/7)
	*(volatile unsigned int *) 0xf0000004 = 0x00000000 | 0x0008090B; // UART, WDT, Timer, QSPI
   11176:	46 10 00 80 	sethi $r1,#0x80
   1117a:	50 10 89 0b 	addi $r1,$r1,#0x90b
   1117e:	a8 41       	swi333 $r1,[$r0+#0x4]
	// SVM : 124.875M(FPLL/4), GADC : 49.95M(FPLL/20)
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc
   11180:	46 10 08 50 	sethi $r1,#0x850
#endif

#endif 	// #if defined(CPU_OVER_CLOCK)

	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
   11184:	46 28 08 08 	sethi $r2,#0x80808
        *(volatile unsigned int *) 0xf0000000 = 0x0A08080A; // APB, DDR_axi, CPU_axi, CPU
        //*(volatile unsigned int *) 0xf0000000 = 0x0A08080e; // APB, DDR_axi, CPU_axi, CPU --> MPLL1
	// UART : 27M(XIN), WDT : 6.75M(TIMER), TIMER : 6.75M(XIN/4), QSPI : 142.71M(FPLL/7)
	*(volatile unsigned int *) 0xf0000004 = 0x00000000 | 0x0008090B; // UART, WDT, Timer, QSPI
	// SVM : 124.875M(FPLL/4), GADC : 49.95M(FPLL/20)
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc
   11188:	50 10 80 81 	addi $r1,$r1,#0x81
	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
	// VADC : 148.5M(PVI RX)
        *(volatile unsigned int *) 0xf0000010 = 0x80808080 | 0x00000000; // Vadc3, Vadc2, Vadc1, Vadc0
	// ISP : 37.125M(mpll0/8)
        *(volatile unsigned int *) 0xf0000014 = 0x80808080 | 0x18081808; // ISP3, ISP2, ISP1, ISP0
   1118c:	46 39 88 89 	sethi $r3,#0x98889
        *(volatile unsigned int *) 0xf0000000 = 0x0A08080A; // APB, DDR_axi, CPU_axi, CPU
        //*(volatile unsigned int *) 0xf0000000 = 0x0A08080e; // APB, DDR_axi, CPU_axi, CPU --> MPLL1
	// UART : 27M(XIN), WDT : 6.75M(TIMER), TIMER : 6.75M(XIN/4), QSPI : 142.71M(FPLL/7)
	*(volatile unsigned int *) 0xf0000004 = 0x00000000 | 0x0008090B; // UART, WDT, Timer, QSPI
	// SVM : 124.875M(FPLL/4), GADC : 49.95M(FPLL/20)
        *(volatile unsigned int *) 0xf0000008 = 0x00800080 | 0x00050001; // Rev, SVM, Rev, Gadc
   11190:	a8 42       	swi333 $r1,[$r0+#0x8]
	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
	// VADC : 148.5M(PVI RX)
        *(volatile unsigned int *) 0xf0000010 = 0x80808080 | 0x00000000; // Vadc3, Vadc2, Vadc1, Vadc0
	// ISP : 37.125M(mpll0/8)
        *(volatile unsigned int *) 0xf0000014 = 0x80808080 | 0x18081808; // ISP3, ISP2, ISP1, ISP0
   11192:	50 31 88 88 	addi $r3,$r3,#0x888
#endif

#endif 	// #if defined(CPU_OVER_CLOCK)

	// PVI Rx : 148.5M(mpll0/2)
        *(volatile unsigned int *) 0xf000000C = 0x80808080 | 0x00000000; // PVI_Rx3, Rx2, Rx1, Rx0
   11196:	50 11 00 80 	addi $r1,$r2,#0x80
   1119a:	a8 43       	swi333 $r1,[$r0+#0xc]
	// VADC : 148.5M(PVI RX)
        *(volatile unsigned int *) 0xf0000010 = 0x80808080 | 0x00000000; // Vadc3, Vadc2, Vadc1, Vadc0
   1119c:	a8 44       	swi333 $r1,[$r0+#0x10]
	// ISP : 37.125M(mpll0/8)
        *(volatile unsigned int *) 0xf0000014 = 0x80808080 | 0x18081808; // ISP3, ISP2, ISP1, ISP0
   1119e:	a8 c5       	swi333 $r3,[$r0+#0x14]
	// PVI_TxRd : 148.5M(MPLL0/2), DU : 37.125M(mpll0/8), VPU : 37.125M(mpll0/8), VIN : 37.125M(mpll0/8) 
        *(volatile unsigned int *) 0xf0000018 = 0x80808080 | 0x00020404; // PVI_TxRd, DU, VPU, Vin
   111a0:	46 38 08 28 	sethi $r3,#0x80828
   111a4:	50 31 84 84 	addi $r3,$r3,#0x484
   111a8:	a8 c6       	swi333 $r3,[$r0+#0x18]
	// PVI_TxWr : 74.25M(MPLL0/4), RECfmt : 148.5M(mpll0/2), VDAC,PVI_TxFifo : 148.5M(PVI_TxRd)
        *(volatile unsigned int *) 0xf000001C = 0x80808080 | 0x02000000; // PVI_TxWr, Recfmt, Vdac, PVI_TxFifo
   111aa:	42 30 e4 08 	bset $r3,$r1,#0x19
   111ae:	a8 c7       	swi333 $r3,[$r0+#0x1c]

	// QUAD : 37.125M(mpll0/8), RECfmt_2x : 297M(mpll0)
        *(volatile unsigned int *) 0xf0000020 = 0x80808080 | 0x02000000; // Quad, Recfmt_2x_mph_1, 2x_mph_0, Recfmt_2x
   111b0:	83 80       	mov55 $fp,$r0
   111b2:	bb 88       	swi37 $r3,[$fp+#0x20]
	// DISfmt : 74.25M(mpll0/4), Quad_2x : 74.25M(mpll0/4)
        *(volatile unsigned int *) 0xf0000024 = 0x80808080 | 0x00000202; // Disfmt_2x_mph, Rev, Disfmt, Quad_2x
   111b4:	50 31 02 82 	addi $r3,$r2,#0x282
   111b8:	bb 89       	swi37 $r3,[$fp+#0x24]

	// MIPI pixel : 37.125M(mpll0/8), lane : Rxbyteclkhs/2, Rxbyteclkhs : from phy
        *(volatile unsigned int *) 0xf0000028 = 0x80808000 | 0x04000000; // MIPI_pixel, MIPI_lane, Rxbyteclkhs, Rev
   111ba:	46 38 48 08 	sethi $r3,#0x84808
   111be:	bb 8a       	swi37 $r3,[$fp+#0x28]
        *(volatile unsigned int *) 0xf000002C = 0x80808080 | 0x00000000; // DDR_postclk_2x, postclk, ctclk, mipi_cci
   111c0:	b9 8b       	swi37 $r1,[$fp+#0x2c]
        *(volatile unsigned int *) 0xf0000030 = 0x80808000 | 0x00000000; // Parallel Video input clk1, clk0, DMCLK, TCK
        *(volatile unsigned int *) 0xf0000034 = 0x00000000 | 0x000000CC; // clock poriarity isp3210,pvirx3210
   111c2:	44 10 00 cc 	movi $r1,#0xcc
        *(volatile unsigned int *) 0xf0000024 = 0x80808080 | 0x00000202; // Disfmt_2x_mph, Rev, Disfmt, Quad_2x

	// MIPI pixel : 37.125M(mpll0/8), lane : Rxbyteclkhs/2, Rxbyteclkhs : from phy
        *(volatile unsigned int *) 0xf0000028 = 0x80808000 | 0x04000000; // MIPI_pixel, MIPI_lane, Rxbyteclkhs, Rev
        *(volatile unsigned int *) 0xf000002C = 0x80808080 | 0x00000000; // DDR_postclk_2x, postclk, ctclk, mipi_cci
        *(volatile unsigned int *) 0xf0000030 = 0x80808000 | 0x00000000; // Parallel Video input clk1, clk0, DMCLK, TCK
   111c6:	ba 8c       	swi37 $r2,[$fp+#0x30]
        *(volatile unsigned int *) 0xf0000034 = 0x00000000 | 0x000000CC; // clock poriarity isp3210,pvirx3210
   111c8:	b9 8d       	swi37 $r1,[$fp+#0x34]
   111ca:	fc 81       	pop25 $r6,#8    ! {$r6, $fp, $gp, $lp}

000111cc <clock_powerdown>:
void clock_powerdown(const unsigned int u32PowerUpBit, const unsigned int u32PowerDownBit)
{

    /* power up bit */
    {/*{{{*/
        if(u32PowerUpBit & CLK_ENNUM_QSPI)
   111cc:	96 84       	xlsb33 $r2,$r0
   111ce:	c2 07       	beqz38 $r2,111dc <clock_powerdown+0x10>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x00000080;  //Qspi 0:en, 1:dis
   111d0:	46 3f 00 00 	sethi $r3,#0xf0000
   111d4:	a0 99       	lwi333 $r2,[$r3+#0x4]
   111d6:	66 21 00 80 	bitci $r2,$r2,#0x80
   111da:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_TIMERS)
   111dc:	54 20 00 02 	andi $r2,$r0,#0x2
   111e0:	c2 07       	beqz38 $r2,111ee <clock_powerdown+0x22>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x00008000;  //timers 0:en, 1:dis
   111e2:	46 3f 00 00 	sethi $r3,#0xf0000
   111e6:	a0 99       	lwi333 $r2,[$r3+#0x4]
   111e8:	42 21 3c 09 	bclr $r2,$r2,#0xf
   111ec:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_WDT)
   111ee:	54 20 00 04 	andi $r2,$r0,#0x4
   111f2:	c2 07       	beqz38 $r2,11200 <clock_powerdown+0x34>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x00800000;  //wdt 0:en, 1:dis
   111f4:	46 3f 00 00 	sethi $r3,#0xf0000
   111f8:	a0 99       	lwi333 $r2,[$r3+#0x4]
   111fa:	42 21 5c 09 	bclr $r2,$r2,#0x17
   111fe:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_UART)
   11200:	54 20 00 08 	andi $r2,$r0,#0x8
   11204:	c2 07       	beqz38 $r2,11212 <clock_powerdown+0x46>
        {
            *(volatile unsigned int *)0xf0000004 &= (unsigned int)~0x80000000;  //uart 0:en, 1:dis
   11206:	46 3f 00 00 	sethi $r3,#0xf0000
   1120a:	a0 99       	lwi333 $r2,[$r3+#0x4]
   1120c:	42 21 7c 09 	bclr $r2,$r2,#0x1f
   11210:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_GADC)
   11212:	54 20 00 10 	andi $r2,$r0,#0x10
   11216:	c2 07       	beqz38 $r2,11224 <clock_powerdown+0x58>
        {
            *(volatile unsigned int *)0xf0000008 &= (unsigned int)~0x00000080;  //gadc 0:en, 1:dis
   11218:	46 3f 00 00 	sethi $r3,#0xf0000
   1121c:	a0 9a       	lwi333 $r2,[$r3+#0x8]
   1121e:	66 21 00 80 	bitci $r2,$r2,#0x80
   11222:	a8 9a       	swi333 $r2,[$r3+#0x8]
        }
        if(u32PowerUpBit & CLK_ENNUM_SVM)
   11224:	54 20 00 20 	andi $r2,$r0,#0x20
   11228:	c2 07       	beqz38 $r2,11236 <clock_powerdown+0x6a>
        {
            *(volatile unsigned int *)0xf0000008 &= (unsigned int)~0x00800000;  //svm 0:en, 1:dis
   1122a:	46 3f 00 00 	sethi $r3,#0xf0000
   1122e:	a0 9a       	lwi333 $r2,[$r3+#0x8]
   11230:	42 21 5c 09 	bclr $r2,$r2,#0x17
   11234:	a8 9a       	swi333 $r2,[$r3+#0x8]
        }
        if(u32PowerUpBit & CLK_ENNUM_PVIRX)
   11236:	54 20 00 40 	andi $r2,$r0,#0x40
   1123a:	c2 0d       	beqz38 $r2,11254 <clock_powerdown+0x88>
        {
            *(volatile unsigned int *)0xf000000C &= (unsigned int)~0x80808080;  //pvirx 0:en, 1:dis
   1123c:	46 3f 00 00 	sethi $r3,#0xf0000
   11240:	a1 1b       	lwi333 $r4,[$r3+#0xc]
   11242:	46 27 f7 f7 	sethi $r2,#0x7f7f7
   11246:	50 21 0f 7f 	addi $r2,$r2,#0xf7f
   1124a:	ff 16       	and33 $r4,$r2
   1124c:	a9 1b       	swi333 $r4,[$r3+#0xc]
            *(volatile unsigned int *)0xf0000010 &= (unsigned int)~0x80808080;  //vadc 0:en, 1:dis
   1124e:	a1 1c       	lwi333 $r4,[$r3+#0x10]
   11250:	fe a6       	and33 $r2,$r4
   11252:	a8 9c       	swi333 $r2,[$r3+#0x10]
        }
        if(u32PowerUpBit & CLK_ENNUM_ISP)
   11254:	54 20 00 80 	andi $r2,$r0,#0x80
   11258:	c2 0a       	beqz38 $r2,1126c <clock_powerdown+0xa0>
        {
            *(volatile unsigned int *)0xf0000014 &= (unsigned int)~0x80808080;  //isp 0:en, 1:dis
   1125a:	46 3f 00 00 	sethi $r3,#0xf0000
   1125e:	a1 1d       	lwi333 $r4,[$r3+#0x14]
   11260:	46 27 f7 f7 	sethi $r2,#0x7f7f7
   11264:	50 21 0f 7f 	addi $r2,$r2,#0xf7f
   11268:	fe a6       	and33 $r2,$r4
   1126a:	a8 9d       	swi333 $r2,[$r3+#0x14]
        }
        if(u32PowerUpBit & CLK_ENNUM_VIN)
   1126c:	54 20 01 00 	andi $r2,$r0,#0x100
   11270:	c2 07       	beqz38 $r2,1127e <clock_powerdown+0xb2>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x00000080;  //vin 0:en, 1:dis
   11272:	46 3f 00 00 	sethi $r3,#0xf0000
   11276:	a0 9e       	lwi333 $r2,[$r3+#0x18]
   11278:	66 21 00 80 	bitci $r2,$r2,#0x80
   1127c:	a8 9e       	swi333 $r2,[$r3+#0x18]
        }
        if(u32PowerUpBit & CLK_ENNUM_VPU)
   1127e:	54 20 02 00 	andi $r2,$r0,#0x200
   11282:	c2 07       	beqz38 $r2,11290 <clock_powerdown+0xc4>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x00008000;  //vpu 0:en, 1:dis
   11284:	46 3f 00 00 	sethi $r3,#0xf0000
   11288:	a0 9e       	lwi333 $r2,[$r3+#0x18]
   1128a:	42 21 3c 09 	bclr $r2,$r2,#0xf
   1128e:	a8 9e       	swi333 $r2,[$r3+#0x18]
        }
        if(u32PowerUpBit & CLK_ENNUM_DU)
   11290:	54 20 04 00 	andi $r2,$r0,#0x400
   11294:	c2 07       	beqz38 $r2,112a2 <clock_powerdown+0xd6>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x00800000;  //du 0:en, 1:dis
   11296:	46 3f 00 00 	sethi $r3,#0xf0000
   1129a:	a0 9e       	lwi333 $r2,[$r3+#0x18]
   1129c:	42 21 5c 09 	bclr $r2,$r2,#0x17
   112a0:	a8 9e       	swi333 $r2,[$r3+#0x18]
        }
        if(u32PowerUpBit & CLK_ENNUM_PVITX)
   112a2:	54 20 08 00 	andi $r2,$r0,#0x800
   112a6:	c2 13       	beqz38 $r2,112cc <clock_powerdown+0x100>
        {
            *(volatile unsigned int *)0xf0000018 &= (unsigned int)~0x80000000;  //pvitx rd 0:en, 1:dis
   112a8:	46 2f 00 00 	sethi $r2,#0xf0000
   112ac:	a0 d6       	lwi333 $r3,[$r2+#0x18]
   112ae:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   112b2:	a8 d6       	swi333 $r3,[$r2+#0x18]
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x80000000;  //pvitx wr 0:en, 1:dis
   112b4:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112b6:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   112ba:	a8 d7       	swi333 $r3,[$r2+#0x1c]
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x00000080;  //pvitx fifo 0:en, 1:dis
   112bc:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112be:	66 31 80 80 	bitci $r3,$r3,#0x80
   112c2:	a8 d7       	swi333 $r3,[$r2+#0x1c]
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x00008000;  //pvitx vdac 0:en, 1:dis
   112c4:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112c6:	42 31 bc 09 	bclr $r3,$r3,#0xf
   112ca:	a8 d7       	swi333 $r3,[$r2+#0x1c]
        }
        if(u32PowerUpBit & CLK_ENNUM_RO)
   112cc:	54 20 10 00 	andi $r2,$r0,#0x1000
   112d0:	c2 15       	beqz38 $r2,112fa <clock_powerdown+0x12e>
        {
            *(volatile unsigned int *)0xf000001C &= (unsigned int)~0x00800000;  //recfmt 0:en, 1:dis
   112d2:	46 2f 00 00 	sethi $r2,#0xf0000
   112d6:	a0 d7       	lwi333 $r3,[$r2+#0x1c]
   112d8:	42 31 dc 09 	bclr $r3,$r3,#0x17
   112dc:	a8 d7       	swi333 $r3,[$r2+#0x1c]
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x00000080;  //recfmt_2x_clock 0:en, 1:dis
   112de:	50 41 00 20 	addi $r4,$r2,#0x20
   112e2:	b4 64       	lwi450 $r3,[$r4]
   112e4:	66 31 80 80 	bitci $r3,$r3,#0x80
   112e8:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x00008000;  //recfmt_2x_mph0 0:en, 1:dis
   112ea:	b4 64       	lwi450 $r3,[$r4]
   112ec:	42 31 bc 09 	bclr $r3,$r3,#0xf
   112f0:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x00800000;  //recfmt_2x_mph1 0:en, 1:dis
   112f2:	b4 64       	lwi450 $r3,[$r4]
   112f4:	42 31 dc 09 	bclr $r3,$r3,#0x17
   112f8:	b6 64       	swi450 $r3,[$r4]
        }
        if(u32PowerUpBit & CLK_ENNUM_QUAD)
   112fa:	54 20 20 00 	andi $r2,$r0,#0x2000
   112fe:	c2 0d       	beqz38 $r2,11318 <clock_powerdown+0x14c>
        {
            *(volatile unsigned int *)0xf0000020 &= (unsigned int)~0x80000000;  //quad 0:en, 1:dis
   11300:	46 2f 00 00 	sethi $r2,#0xf0000
   11304:	50 41 00 20 	addi $r4,$r2,#0x20
   11308:	b4 64       	lwi450 $r3,[$r4]
   1130a:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   1130e:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000024 &= (unsigned int)~0x00000080;  //quad_2x 0:en, 1:dis
   11310:	a0 e1       	lwi333 $r3,[$r4+#0x4]
   11312:	66 31 80 80 	bitci $r3,$r3,#0x80
   11316:	a8 e1       	swi333 $r3,[$r4+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_DOUT)
   11318:	54 20 40 00 	andi $r2,$r0,#0x4000
   1131c:	c2 0d       	beqz38 $r2,11336 <clock_powerdown+0x16a>
        {
            *(volatile unsigned int *)0xf0000024 &= (unsigned int)~0x00008000;  //disfmt 0:en, 1:dis
   1131e:	46 2f 00 00 	sethi $r2,#0xf0000
   11322:	50 41 00 24 	addi $r4,$r2,#0x24
   11326:	b4 64       	lwi450 $r3,[$r4]
   11328:	42 31 bc 09 	bclr $r3,$r3,#0xf
   1132c:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000024 &= (unsigned int)~0x80000000;  //disfmt_2x 0:en, 1:dis
   1132e:	b4 64       	lwi450 $r3,[$r4]
   11330:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   11334:	b6 64       	swi450 $r3,[$r4]
        }
        if(u32PowerUpBit & CLK_ENNUM_MIPI)
   11336:	42 20 3c 0b 	btst $r2,$r0,#0xf
   1133a:	c2 15       	beqz38 $r2,11364 <clock_powerdown+0x198>
        {
            *(volatile unsigned int *)0xf0000028 &= (unsigned int)~0x00008000;  //rxbyteclkhs 0:en, 1:dis
   1133c:	46 2f 00 00 	sethi $r2,#0xf0000
   11340:	50 41 00 28 	addi $r4,$r2,#0x28
   11344:	b4 64       	lwi450 $r3,[$r4]
   11346:	42 31 bc 09 	bclr $r3,$r3,#0xf
   1134a:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000028 &= (unsigned int)~0x00800000;  //mipi_lane 0:en, 1:dis
   1134c:	b4 64       	lwi450 $r3,[$r4]
   1134e:	42 31 dc 09 	bclr $r3,$r3,#0x17
   11352:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf0000028 &= (unsigned int)~0x80000000;  //mipi_pixel 0:en, 1:dis
   11354:	b4 64       	lwi450 $r3,[$r4]
   11356:	42 31 fc 09 	bclr $r3,$r3,#0x1f
   1135a:	b6 64       	swi450 $r3,[$r4]
            *(volatile unsigned int *)0xf000002C &= (unsigned int)~0x00000080;  //mipi cci 0:en, 1:dis
   1135c:	a0 e1       	lwi333 $r3,[$r4+#0x4]
   1135e:	66 31 80 80 	bitci $r3,$r3,#0x80
   11362:	a8 e1       	swi333 $r3,[$r4+#0x4]
        }
        if(u32PowerUpBit & CLK_ENNUM_DDR)
   11364:	42 20 40 0b 	btst $r2,$r0,#0x10
   11368:	c2 0c       	beqz38 $r2,11380 <clock_powerdown+0x1b4>
        {
            *(volatile unsigned int *)0xf000002C &= (unsigned int)~0x80808000;  //ddr 0:en, 1:dis
   1136a:	46 3f 00 00 	sethi $r3,#0xf0000
   1136e:	04 41 80 0b 	lwi $r4,[$r3+#0x2c]
   11372:	46 27 f7 f7 	sethi $r2,#0x7f7f7
   11376:	50 21 0f ff 	addi $r2,$r2,#0xfff
   1137a:	fe a6       	and33 $r2,$r4
   1137c:	14 21 80 0b 	swi $r2,[$r3+#0x2c]
        }
        if(u32PowerUpBit & CLK_ENNUM_JTAG)
   11380:	42 20 44 0b 	btst $r2,$r0,#0x11
   11384:	c2 09       	beqz38 $r2,11396 <clock_powerdown+0x1ca>
        {
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x00000080;  //jtag 0:en, 1:dis
   11386:	46 3f 00 00 	sethi $r3,#0xf0000
   1138a:	04 21 80 0c 	lwi $r2,[$r3+#0x30]
   1138e:	66 21 00 80 	bitci $r2,$r2,#0x80
   11392:	14 21 80 0c 	swi $r2,[$r3+#0x30]
        }
        if(u32PowerUpBit & CLK_ENNUM_I2S)
   11396:	42 20 48 0b 	btst $r2,$r0,#0x12
   1139a:	c2 09       	beqz38 $r2,113ac <clock_powerdown+0x1e0>
        {
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x00008000;  //i2S 0:en, 1:dis
   1139c:	46 3f 00 00 	sethi $r3,#0xf0000
   113a0:	04 21 80 0c 	lwi $r2,[$r3+#0x30]
   113a4:	42 21 3c 09 	bclr $r2,$r2,#0xf
   113a8:	14 21 80 0c 	swi $r2,[$r3+#0x30]
        }
        if(u32PowerUpBit & CLK_ENNUM_PARAVIN)
   113ac:	42 00 4c 0b 	btst $r0,$r0,#0x13
   113b0:	c0 0d       	beqz38 $r0,113ca <clock_powerdown+0x1fe>
        {
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x00800000;  //par0 0:en, 1:dis
   113b2:	46 0f 00 00 	sethi $r0,#0xf0000
   113b6:	50 30 00 30 	addi $r3,$r0,#0x30
   113ba:	b4 43       	lwi450 $r2,[$r3]
   113bc:	42 21 5c 09 	bclr $r2,$r2,#0x17
   113c0:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000030 &= (unsigned int)~0x80000000;  //par1 0:en, 1:dis
   113c2:	b4 43       	lwi450 $r2,[$r3]
   113c4:	42 21 7c 09 	bclr $r2,$r2,#0x1f
   113c8:	b6 43       	swi450 $r2,[$r3]
        }
    }/*}}}*/
    /* power down bit */
    {/*{{{*/
        if(u32PowerDownBit & CLK_ENNUM_QSPI)
   113ca:	96 0c       	xlsb33 $r0,$r1
   113cc:	c0 07       	beqz38 $r0,113da <clock_powerdown+0x20e>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x00000080;  //Qspi 0:en, 1:dis
   113ce:	46 2f 00 00 	sethi $r2,#0xf0000
   113d2:	a0 11       	lwi333 $r0,[$r2+#0x4]
   113d4:	58 00 00 80 	ori $r0,$r0,#0x80
   113d8:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_TIMERS)
   113da:	54 00 80 02 	andi $r0,$r1,#0x2
   113de:	c0 07       	beqz38 $r0,113ec <clock_powerdown+0x220>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x00008000;  //timers 0:en, 1:dis
   113e0:	46 2f 00 00 	sethi $r2,#0xf0000
   113e4:	a0 11       	lwi333 $r0,[$r2+#0x4]
   113e6:	42 00 3c 08 	bset $r0,$r0,#0xf
   113ea:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_WDT)
   113ec:	54 00 80 04 	andi $r0,$r1,#0x4
   113f0:	c0 07       	beqz38 $r0,113fe <clock_powerdown+0x232>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x00800000;  //wdt 0:en, 1:dis
   113f2:	46 2f 00 00 	sethi $r2,#0xf0000
   113f6:	a0 11       	lwi333 $r0,[$r2+#0x4]
   113f8:	42 00 5c 08 	bset $r0,$r0,#0x17
   113fc:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_UART)
   113fe:	54 00 80 08 	andi $r0,$r1,#0x8
   11402:	c0 07       	beqz38 $r0,11410 <clock_powerdown+0x244>
        {
            *(volatile unsigned int *)0xf0000004 |= (unsigned int)0x80000000;  //uart 0:en, 1:dis
   11404:	46 2f 00 00 	sethi $r2,#0xf0000
   11408:	a0 11       	lwi333 $r0,[$r2+#0x4]
   1140a:	42 00 7c 08 	bset $r0,$r0,#0x1f
   1140e:	a8 11       	swi333 $r0,[$r2+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_GADC)
   11410:	54 00 80 10 	andi $r0,$r1,#0x10
   11414:	c0 07       	beqz38 $r0,11422 <clock_powerdown+0x256>
        {
            *(volatile unsigned int *)0xf0000008 |= (unsigned int)0x00000080;  //gadc 0:en, 1:dis
   11416:	46 2f 00 00 	sethi $r2,#0xf0000
   1141a:	a0 12       	lwi333 $r0,[$r2+#0x8]
   1141c:	58 00 00 80 	ori $r0,$r0,#0x80
   11420:	a8 12       	swi333 $r0,[$r2+#0x8]
        }
        if(u32PowerDownBit & CLK_ENNUM_SVM)
   11422:	54 00 80 20 	andi $r0,$r1,#0x20
   11426:	c0 07       	beqz38 $r0,11434 <clock_powerdown+0x268>
        {
            *(volatile unsigned int *)0xf0000008 |= (unsigned int)0x00800000;  //svm 0:en, 1:dis
   11428:	46 2f 00 00 	sethi $r2,#0xf0000
   1142c:	a0 12       	lwi333 $r0,[$r2+#0x8]
   1142e:	42 00 5c 08 	bset $r0,$r0,#0x17
   11432:	a8 12       	swi333 $r0,[$r2+#0x8]
        }
        if(u32PowerDownBit & CLK_ENNUM_PVIRX)
   11434:	54 00 80 40 	andi $r0,$r1,#0x40
   11438:	c0 0d       	beqz38 $r0,11452 <clock_powerdown+0x286>
        {
            *(volatile unsigned int *)0xf000000C |= (unsigned int)0x80808080;  //pvirx 0:en, 1:dis
   1143a:	46 2f 00 00 	sethi $r2,#0xf0000
   1143e:	a0 d3       	lwi333 $r3,[$r2+#0xc]
   11440:	46 08 08 08 	sethi $r0,#0x80808
   11444:	58 00 00 80 	ori $r0,$r0,#0x80
   11448:	fe c7       	or33 $r3,$r0
   1144a:	a8 d3       	swi333 $r3,[$r2+#0xc]
            *(volatile unsigned int *)0xf0000010 |= (unsigned int)0x80808080;  //vadc 0:en, 1:dis
   1144c:	a0 d4       	lwi333 $r3,[$r2+#0x10]
   1144e:	fe 1f       	or33 $r0,$r3
   11450:	a8 14       	swi333 $r0,[$r2+#0x10]
        }
        if(u32PowerDownBit & CLK_ENNUM_ISP)
   11452:	54 00 80 80 	andi $r0,$r1,#0x80
   11456:	c0 0a       	beqz38 $r0,1146a <clock_powerdown+0x29e>
        {
            *(volatile unsigned int *)0xf0000014 |= (unsigned int)0x80808080;  //isp 0:en, 1:dis
   11458:	46 2f 00 00 	sethi $r2,#0xf0000
   1145c:	a0 d5       	lwi333 $r3,[$r2+#0x14]
   1145e:	46 08 08 08 	sethi $r0,#0x80808
   11462:	58 00 00 80 	ori $r0,$r0,#0x80
   11466:	fe 1f       	or33 $r0,$r3
   11468:	a8 15       	swi333 $r0,[$r2+#0x14]
        }
        if(u32PowerDownBit & CLK_ENNUM_VIN)
   1146a:	54 00 81 00 	andi $r0,$r1,#0x100
   1146e:	c0 07       	beqz38 $r0,1147c <clock_powerdown+0x2b0>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x00000080;  //vin 0:en, 1:dis
   11470:	46 2f 00 00 	sethi $r2,#0xf0000
   11474:	a0 16       	lwi333 $r0,[$r2+#0x18]
   11476:	58 00 00 80 	ori $r0,$r0,#0x80
   1147a:	a8 16       	swi333 $r0,[$r2+#0x18]
        }
        if(u32PowerDownBit & CLK_ENNUM_VPU)
   1147c:	54 00 82 00 	andi $r0,$r1,#0x200
   11480:	c0 07       	beqz38 $r0,1148e <clock_powerdown+0x2c2>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x00008000;  //vpu 0:en, 1:dis
   11482:	46 2f 00 00 	sethi $r2,#0xf0000
   11486:	a0 16       	lwi333 $r0,[$r2+#0x18]
   11488:	42 00 3c 08 	bset $r0,$r0,#0xf
   1148c:	a8 16       	swi333 $r0,[$r2+#0x18]
        }
        if(u32PowerDownBit & CLK_ENNUM_DU)
   1148e:	54 00 84 00 	andi $r0,$r1,#0x400
   11492:	c0 07       	beqz38 $r0,114a0 <clock_powerdown+0x2d4>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x00800000;  //du 0:en, 1:dis
   11494:	46 2f 00 00 	sethi $r2,#0xf0000
   11498:	a0 16       	lwi333 $r0,[$r2+#0x18]
   1149a:	42 00 5c 08 	bset $r0,$r0,#0x17
   1149e:	a8 16       	swi333 $r0,[$r2+#0x18]
        }
        if(u32PowerDownBit & CLK_ENNUM_PVITX)
   114a0:	54 00 88 00 	andi $r0,$r1,#0x800
   114a4:	c0 13       	beqz38 $r0,114ca <clock_powerdown+0x2fe>
        {
            *(volatile unsigned int *)0xf0000018 |= (unsigned int)0x80000000;  //pvitx rd 0:en, 1:dis
   114a6:	46 0f 00 00 	sethi $r0,#0xf0000
   114aa:	a0 86       	lwi333 $r2,[$r0+#0x18]
   114ac:	42 21 7c 08 	bset $r2,$r2,#0x1f
   114b0:	a8 86       	swi333 $r2,[$r0+#0x18]
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x80000000;  //pvitx wr 0:en, 1:dis
   114b2:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114b4:	42 21 7c 08 	bset $r2,$r2,#0x1f
   114b8:	a8 87       	swi333 $r2,[$r0+#0x1c]
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x00000080;  //pvitx fifo 0:en, 1:dis
   114ba:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114bc:	58 21 00 80 	ori $r2,$r2,#0x80
   114c0:	a8 87       	swi333 $r2,[$r0+#0x1c]
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x00008000;  //pvitx vdac 0:en, 1:dis
   114c2:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114c4:	42 21 3c 08 	bset $r2,$r2,#0xf
   114c8:	a8 87       	swi333 $r2,[$r0+#0x1c]
        }
        if(u32PowerDownBit & CLK_ENNUM_RO)
   114ca:	54 00 90 00 	andi $r0,$r1,#0x1000
   114ce:	c0 15       	beqz38 $r0,114f8 <clock_powerdown+0x32c>
        {
            *(volatile unsigned int *)0xf000001C |= (unsigned int)0x00800000;  //recfmt 0:en, 1:dis
   114d0:	46 0f 00 00 	sethi $r0,#0xf0000
   114d4:	a0 87       	lwi333 $r2,[$r0+#0x1c]
   114d6:	42 21 5c 08 	bset $r2,$r2,#0x17
   114da:	a8 87       	swi333 $r2,[$r0+#0x1c]
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x00000080;  //recfmt_2x_clock 0:en, 1:dis
   114dc:	50 30 00 20 	addi $r3,$r0,#0x20
   114e0:	b4 43       	lwi450 $r2,[$r3]
   114e2:	58 21 00 80 	ori $r2,$r2,#0x80
   114e6:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x00008000;  //recfmt_2x_mph0 0:en, 1:dis
   114e8:	b4 43       	lwi450 $r2,[$r3]
   114ea:	42 21 3c 08 	bset $r2,$r2,#0xf
   114ee:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x00800000;  //recfmt_2x_mph1 0:en, 1:dis
   114f0:	b4 43       	lwi450 $r2,[$r3]
   114f2:	42 21 5c 08 	bset $r2,$r2,#0x17
   114f6:	b6 43       	swi450 $r2,[$r3]
        }
        if(u32PowerDownBit & CLK_ENNUM_QUAD)
   114f8:	54 00 a0 00 	andi $r0,$r1,#0x2000
   114fc:	c0 0d       	beqz38 $r0,11516 <clock_powerdown+0x34a>
        {
            *(volatile unsigned int *)0xf0000020 |= (unsigned int)0x80000000;  //quad 0:en, 1:dis
   114fe:	46 0f 00 00 	sethi $r0,#0xf0000
   11502:	50 30 00 20 	addi $r3,$r0,#0x20
   11506:	b4 43       	lwi450 $r2,[$r3]
   11508:	42 21 7c 08 	bset $r2,$r2,#0x1f
   1150c:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000024 |= (unsigned int)0x00000080;  //quad_2x 0:en, 1:dis
   1150e:	a0 99       	lwi333 $r2,[$r3+#0x4]
   11510:	58 21 00 80 	ori $r2,$r2,#0x80
   11514:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_DOUT)
   11516:	54 00 c0 00 	andi $r0,$r1,#0x4000
   1151a:	c0 0d       	beqz38 $r0,11534 <clock_powerdown+0x368>
        {
            *(volatile unsigned int *)0xf0000024 |= (unsigned int)0x00008000;  //disfmt 0:en, 1:dis
   1151c:	46 0f 00 00 	sethi $r0,#0xf0000
   11520:	50 30 00 24 	addi $r3,$r0,#0x24
   11524:	b4 43       	lwi450 $r2,[$r3]
   11526:	42 21 3c 08 	bset $r2,$r2,#0xf
   1152a:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000024 |= (unsigned int)0x80000000;  //disfmt_2x 0:en, 1:dis
   1152c:	b4 43       	lwi450 $r2,[$r3]
   1152e:	42 21 7c 08 	bset $r2,$r2,#0x1f
   11532:	b6 43       	swi450 $r2,[$r3]
        }
        if(u32PowerDownBit & CLK_ENNUM_MIPI)
   11534:	42 00 bc 0b 	btst $r0,$r1,#0xf
   11538:	c0 15       	beqz38 $r0,11562 <clock_powerdown+0x396>
        {
            *(volatile unsigned int *)0xf0000028 |= (unsigned int)0x00008000;  //rxbyteclkhs 0:en, 1:dis
   1153a:	46 0f 00 00 	sethi $r0,#0xf0000
   1153e:	50 30 00 28 	addi $r3,$r0,#0x28
   11542:	b4 43       	lwi450 $r2,[$r3]
   11544:	42 21 3c 08 	bset $r2,$r2,#0xf
   11548:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000028 |= (unsigned int)0x00800000;  //mipi_lane 0:en, 1:dis
   1154a:	b4 43       	lwi450 $r2,[$r3]
   1154c:	42 21 5c 08 	bset $r2,$r2,#0x17
   11550:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf0000028 |= (unsigned int)0x80000000;  //mipi_pixel 0:en, 1:dis
   11552:	b4 43       	lwi450 $r2,[$r3]
   11554:	42 21 7c 08 	bset $r2,$r2,#0x1f
   11558:	b6 43       	swi450 $r2,[$r3]
            *(volatile unsigned int *)0xf000002C |= (unsigned int)0x00000080;  //mipi cci 0:en, 1:dis
   1155a:	a0 99       	lwi333 $r2,[$r3+#0x4]
   1155c:	58 21 00 80 	ori $r2,$r2,#0x80
   11560:	a8 99       	swi333 $r2,[$r3+#0x4]
        }
        if(u32PowerDownBit & CLK_ENNUM_DDR)
   11562:	42 00 c0 0b 	btst $r0,$r1,#0x10
   11566:	c0 0a       	beqz38 $r0,1157a <clock_powerdown+0x3ae>
        {
            *(volatile unsigned int *)0xf000002C |= (unsigned int)0x80808000;  //ddr 0:en, 1:dis
   11568:	46 2f 00 00 	sethi $r2,#0xf0000
   1156c:	04 31 00 0b 	lwi $r3,[$r2+#0x2c]
   11570:	46 08 08 08 	sethi $r0,#0x80808
   11574:	fe 1f       	or33 $r0,$r3
   11576:	14 01 00 0b 	swi $r0,[$r2+#0x2c]
        }
        if(u32PowerDownBit & CLK_ENNUM_JTAG)
   1157a:	42 00 c4 0b 	btst $r0,$r1,#0x11
   1157e:	c0 09       	beqz38 $r0,11590 <clock_powerdown+0x3c4>
        {
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x00000080;  //jtag 0:en, 1:dis
   11580:	46 2f 00 00 	sethi $r2,#0xf0000
   11584:	04 01 00 0c 	lwi $r0,[$r2+#0x30]
   11588:	58 00 00 80 	ori $r0,$r0,#0x80
   1158c:	14 01 00 0c 	swi $r0,[$r2+#0x30]
        }
        if(u32PowerDownBit & CLK_ENNUM_I2S)
   11590:	42 00 c8 0b 	btst $r0,$r1,#0x12
   11594:	c0 09       	beqz38 $r0,115a6 <clock_powerdown+0x3da>
        {
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x00008000;  //i2S 0:en, 1:dis
   11596:	46 2f 00 00 	sethi $r2,#0xf0000
   1159a:	04 01 00 0c 	lwi $r0,[$r2+#0x30]
   1159e:	42 00 3c 08 	bset $r0,$r0,#0xf
   115a2:	14 01 00 0c 	swi $r0,[$r2+#0x30]
        }
        if(u32PowerDownBit & CLK_ENNUM_PARAVIN)
   115a6:	42 10 cc 0b 	btst $r1,$r1,#0x13
   115aa:	c1 0d       	beqz38 $r1,115c4 <clock_powerdown+0x3f8>
        {
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x00800000;  //par0 0:en, 1:dis
   115ac:	46 0f 00 00 	sethi $r0,#0xf0000
   115b0:	50 20 00 30 	addi $r2,$r0,#0x30
   115b4:	b4 22       	lwi450 $r1,[$r2]
   115b6:	42 10 dc 08 	bset $r1,$r1,#0x17
   115ba:	b6 22       	swi450 $r1,[$r2]
            *(volatile unsigned int *)0xf0000030 |= (unsigned int)0x80000000;  //par1 0:en, 1:dis
   115bc:	b4 22       	lwi450 $r1,[$r2]
   115be:	42 10 fc 08 	bset $r1,$r1,#0x1f
   115c2:	b6 22       	swi450 $r1,[$r2]
   115c4:	dd 9e       	ret5 $lp

000115c6 <SetClockPD>:

    return;
}

void SetClockPD(void)
{
   115c6:	fc 00       	push25 $r6,#0    ! {$r6, $fp, $gp, $lp}
        //CLK_ENNUM_PARAVIN       |
        0;

    u32PowerDownBit = u32PowerAllBit & (unsigned int)~u32PowerUpBit;

    clock_powerdown(u32PowerUpBit, u32PowerDownBit);
   115c8:	46 10 00 cf 	sethi $r1,#0xcf
   115cc:	44 03 00 0f 	movi $r0,#0x3000f
   115d0:	50 10 8f f0 	addi $r1,$r1,#0xff0
   115d4:	49 ff fd fc 	jal 111cc <clock_powerdown>
   115d8:	fc 80       	pop25 $r6,#0    ! {$r6, $fp, $gp, $lp}

000115da <fail>:
#include <stdio.h>
#include "system.h"

void fail()
{
   115da:	dd 9e       	ret5 $lp

000115dc <ddr3_set>:
    //while(1);

}

void ddr3_set(void)
{
   115dc:	fc 12       	push25 $r6,#144    ! {$r6, $fp, $gp, $lp}

    DDR_MODE = DDR3_MODE; // DDR3


    // ddr postclk, postclk 2x reset release
    *(volatile unsigned int *) 0xF0000048 = 0x00003f9f; // sw rst (ddr_postclk, postclk_2x)
   115de:	44 00 3f 9f 	movi $r0,#0x3f9f
   115e2:	46 1f 00 00 	sethi $r1,#0xf0000
   115e6:	14 00 80 12 	swi $r0,[$r1+#0x48]

    // ddr mode set (ddr3)
    // DSRONB, DLL FRANGE setting (1000~1200)
    // phy pll pdn release
    *(volatile unsigned int *) 0xf0100088 = 0x00000000 | DDR_MODE; // DDR mode set
   115ea:	46 2f 01 00 	sethi $r2,#0xf0100
   115ee:	84 00       	movi55 $r0,#0x0
   115f0:	83 82       	mov55 $fp,$r2
   115f2:	b8 a2       	swi37 $r0,[$fp+#0x88]
    *(volatile unsigned int *) 0xf0100088 = 0x00080000 | DDR_MODE | DLLFRANGE; // DSRONB, DLLFRANGE SET
   115f4:	46 00 00 80 	sethi $r0,#0x80
   115f8:	50 00 05 00 	addi $r0,$r0,#0x500
   115fc:	b8 a2       	swi37 $r0,[$fp+#0x88]
    *(volatile unsigned int *) 0xf0100088 = 0x00084000 | DDR_MODE | DLLFRANGE; // phy_pll_pdn enable
   115fe:	58 00 40 00 	ori $r0,$r0,#0x4000
   11602:	b8 a2       	swi37 $r0,[$fp+#0x88]
   11604:	44 20 00 96 	movi $r2,#0x96

    // ddr reset low. las, cas, wen low, clock enable ######################################
    LOOPDELAY_10USEC(10); // wait 100us
   11608:	b4 61       	lwi450 $r3,[$r1]
   1160a:	b6 7f       	swi450 $r3,[$sp]
   1160c:	b4 7f       	lwi450 $r3,[$sp]
   1160e:	8e 41       	subi45 $r2,#0x1
   11610:	46 0f 00 00 	sethi $r0,#0xf0000
   11614:	b6 61       	swi450 $r3,[$r1]
   11616:	ca f9       	bnez38 $r2,11608 <ddr3_set+0x2c>

    // ddr phy pll reset release
    *(volatile unsigned int *) 0xF0000048 = 0x00003fDf; // sw rst (ddr_postclk, phy_pll, postclk_2x)
   11618:	44 10 3f df 	movi $r1,#0x3fdf
   1161c:	14 10 00 12 	swi $r1,[$r0+#0x48]
   11620:	84 2f       	movi55 $r1,#0xf
    // wait 10 * MCLK
    LOOPDELAY_10USEC(1); // wait 10us
   11622:	b4 40       	lwi450 $r2,[$r0]
   11624:	f2 81       	swi37.sp $r2,[+#0x4]
   11626:	f2 01       	lwi37.sp $r2,[+#0x4]
   11628:	8e 21       	subi45 $r1,#0x1
   1162a:	b6 40       	swi450 $r2,[$r0]
   1162c:	c9 fb       	bnez38 $r1,11622 <ddr3_set+0x46>

    // ddr phy dll pdn release
    *(volatile unsigned int *) 0xf0100088 = 0x00087000 | DDR_MODE | DLLFRANGE; // phy_dll_pdn enable
   1162e:	46 00 00 87 	sethi $r0,#0x87
   11632:	50 00 05 00 	addi $r0,$r0,#0x500
   11636:	46 1f 01 00 	sethi $r1,#0xf0100
   1163a:	14 00 80 22 	swi $r0,[$r1+#0x88]
   1163e:	44 00 00 96 	movi $r0,#0x96

    LOOPDELAY_10USEC(10); // wait 100us
   11642:	46 1f 00 00 	sethi $r1,#0xf0000
   11646:	b4 41       	lwi450 $r2,[$r1]
   11648:	f2 82       	swi37.sp $r2,[+#0x8]
   1164a:	f2 02       	lwi37.sp $r2,[+#0x8]
   1164c:	8e 01       	subi45 $r0,#0x1
   1164e:	b6 41       	swi450 $r2,[$r1]
   11650:	c8 fb       	bnez38 $r0,11646 <ddr3_set+0x6a>

    // ddr phy reset release
    *(volatile unsigned int *) 0xF0000048 = 0x00003fff; // sw rst (ddr_postclk, phy_pll, phy, postclk_2x)
   11652:	44 20 3f ff 	movi $r2,#0x3fff
   11656:	46 1f 00 00 	sethi $r1,#0xf0000
   1165a:	14 20 80 12 	swi $r2,[$r1+#0x48]
#else
#error "unkonwn ddr3 speed dllframe"
#endif


    reg00_value = 
   1165e:	46 10 86 09 	sethi $r1,#0x8609
   11662:	50 10 8e 13 	addi $r1,$r1,#0xe13
   11666:	f1 83       	swi37.sp $r1,[+#0xc]
    const unsigned int ZQCS		    = 0x0;
    const unsigned int MRS_mode        = 0x0;
    const unsigned int MemCmd_exit_srf = 0x0; 
    const unsigned int MemCmd_srf      = 0x0; 
    const unsigned int MemCmd_mrs      = 0x0;
    volatile unsigned int MemCmd_initial  = 0x0;
   11668:	f0 a3       	swi37.sp $r0,[+#0x8c]
        | (ZQCS	           << 6)
        | (MRS_mode        << 4)
        | (MemCmd_exit_srf << 3)
        | (MemCmd_srf      << 2)
        | (MemCmd_mrs      << 1)
        | (MemCmd_initial); 
   1166a:	f1 23       	lwi37.sp $r1,[+#0x8c]
    const unsigned int MemCmd_srf      = 0x0; 
    const unsigned int MemCmd_mrs      = 0x0;
    volatile unsigned int MemCmd_initial  = 0x0;


    reg04_value =
   1166c:	f1 84       	swi37.sp $r1,[+#0x10]
    //                    4'b1100 = 10, 4'b1110 = 11, 4'b0001 = 12, 4'b0011 = 13, 4'b0101 = 14

    const unsigned int Burst_Type = 0x0;   //MR0[3] Burst_Type, 1'b0 = Sequential, 1'b1 = Interleaved  
    const unsigned int BL_DDR3    = 0x0;    //MR0[1:0] Burst_Length, 2'b00 = BL8, 2'b01= BC4 or 8 (on the fly), 2'b10 = BC4

    reg08_value =
   1166e:	46 10 02 40 	sethi $r1,#0x240
   11672:	50 10 8a 30 	addi $r1,$r1,#0xa30
   11676:	f1 85       	swi37.sp $r1,[+#0x14]
    const unsigned int ASR    = 0x1;    //MR2[6], 1'b0=manual, 1'b1=automatic
    const unsigned int CWL    = 0x1;    //MR2[5:3], 3'b000 = 5, 3'b001 = 6, 3'b010 =7, 3'b011 = 8, 3'b100 =9, 
    // 3'b101 = 10, 3'b110 = 11, 3'b111 =12
    const unsigned int PASR   = 0x0;   //MR2[2:0] PASR Partial Array Self Refresh  

    reg0C_value =
   11678:	44 10 00 48 	movi $r1,#0x48
   1167c:	f1 86       	swi37.sp $r1,[+#0x18]
#endif




    reg10_value =
   1167e:	46 12 00 00 	sethi $r1,#0x20000
   11682:	50 10 80 55 	addi $r1,$r1,#0x55
   11686:	f1 87       	swi37.sp $r1,[+#0x1c]
    const unsigned int TRFC = 0x24;  
    const unsigned int TFAW = 0xe;  
    const unsigned int TRC  = 0x10;  
    const unsigned int TRAS = 0xb;    

    reg14_value = 
   11688:	46 12 40 e1 	sethi $r1,#0x240e1
   1168c:	8c 2b       	addi45 $r1,#0xb
   1168e:	f1 88       	swi37.sp $r1,[+#0x20]
    const unsigned int TMRD = 0x1;      
    const unsigned int TRP  = 0x4;   
    const unsigned int TRRD = 0x3;          
    const unsigned int TRCD = 0x4;    

    reg18_value = 
   11690:	46 14 29 51 	sethi $r1,#0x42951
   11694:	50 10 84 34 	addi $r1,$r1,#0x434
   11698:	f1 89       	swi37.sp $r1,[+#0x24]
    // Refresh interval = TREFI(32 x 0x0f) x MCLK cycle(500MHz->2ns) x Post Refresh Cnt(4) = 3840ns
    // Requirement. Commercial: 7800ns, Industrial: 3900ns
    const unsigned int TREFI      = 0x0f;
    //const unsigned int TREFI      = 0x03;

    reg1C_value =
   1169a:	44 10 20 0f 	movi $r1,#0x200f
   1169e:	f1 8a       	swi37.sp $r1,[+#0x28]
    const unsigned int AUTO_IO_CTRL_PDN = 0x0;
    const unsigned int ODTMD_DQS            = 0x1;
    const unsigned int SIO              = 0x0;       
    const unsigned int ODTMD_DQ            = 0x1;

    reg20_value =   
   116a0:	44 10 1f 11 	movi $r1,#0x1f11
   116a4:	f1 8b       	swi37.sp $r1,[+#0x2c]
    const unsigned int DLLSEL_B3 = 0x7;
    const unsigned int DLLSEL_B2 = 0x7;
    const unsigned int DLLSEL_B1 = 0x7;
    const unsigned int DLLSEL_B0 = 0x7;
#endif
    reg24_value =
   116a6:	46 17 77 77 	sethi $r1,#0x77777
   116aa:	50 10 87 77 	addi $r1,$r1,#0x777
   116ae:	f1 8c       	swi37.sp $r1,[+#0x30]
    //const unsigned int Burst_orient_ch_true = 0xd5;  // 1101 0101
    const unsigned int Burst_orient_ch_true = 0xff;  // 1101 0101
    const unsigned int Ch_hi_prior = 0x00;  //High priority: 0, 2, 5, 6, 7
    const unsigned int Reorder_burst_en = 0x00;

    reg30_value =
   116b0:	46 11 60 0f 	sethi $r1,#0x1600f
   116b4:	50 10 8f 00 	addi $r1,$r1,#0xf00
   116b8:	f1 8d       	swi37.sp $r1,[+#0x34]
    const unsigned int GrantCnt0 = 0x6;
    const unsigned int GrantCnt1 = 0x5;
    const unsigned int GrantCnt2 = 0x5;
    const unsigned int GrantCnt3 = 0xf;

    reg34_value =
   116ba:	46 10 f0 50 	sethi $r1,#0xf050
   116be:	50 10 85 06 	addi $r1,$r1,#0x506
   116c2:	f1 8e       	swi37.sp $r1,[+#0x38]
    const unsigned int GrantCnt4 = 0x5;
    const unsigned int GrantCnt5 = 0x3;
    const unsigned int GrantCnt6 = 0x8;
    const unsigned int GrantCnt7 = 0x5;

    reg38_value =
   116c4:	46 10 50 80 	sethi $r1,#0x5080
   116c8:	50 10 83 05 	addi $r1,$r1,#0x305
   116cc:	f1 8f       	swi37.sp $r1,[+#0x3c]
    const unsigned int cf_tphy_wrlat  = 0x2;
    const unsigned int cf_tphy_wrdata = 0x1;
    const unsigned int cf_trddata_en  = 0x2; 
    const unsigned int cf_tphy_rdlat  = 0x0;

    reg3C_value =   
   116ce:	44 12 00 12 	movi $r1,#0x20012
   116d2:	f1 90       	swi37.sp $r1,[+#0x40]
    //--------------------   
    const unsigned int debug_int_en = 0x0;
    const unsigned int flush_int_en = 0xaa;
    const unsigned int flush_en = 0x0;

    reg40_value =
   116d4:	44 10 aa 00 	movi $r1,#0xaa00
   116d8:	f1 91       	swi37.sp $r1,[+#0x44]
    const unsigned int CH4_hprot_sel     = 0x01;  
    const unsigned int CH5_hprot_sel     = 0x01;  
    const unsigned int CH6_hprot_sel     = 0x01;  
    const unsigned int CH7_hprot_sel     = 0x01;

    reg48_value =
   116da:	46 10 05 55 	sethi $r1,#0x555
   116de:	50 10 85 00 	addi $r1,$r1,#0x500
   116e2:	f1 92       	swi37.sp $r1,[+#0x48]
    const unsigned int wlevel_byte1_hw_disable = 0x1;
    const unsigned int wlevel_byte0_hw_disable = 0x1;
#endif
    const unsigned int tWLO = 0x6;   

    reg60_value =
   116e4:	46 10 0f f0 	sethi $r1,#0xff0
   116e8:	8c 26       	addi45 $r1,#0x6

    const unsigned int ZQ_update = 0x0; 
    const unsigned int tWEVEL_UP = 0x0; 
    const unsigned int tDLL_UP   = 0x0;

    reg4C_value =
   116ea:	f0 93       	swi37.sp $r0,[+#0x4c]
    const unsigned int wlevel_byte1_hw_disable = 0x1;
    const unsigned int wlevel_byte0_hw_disable = 0x1;
#endif
    const unsigned int tWLO = 0x6;   

    reg60_value =
   116ec:	f1 94       	swi37.sp $r1,[+#0x50]
    const unsigned int rlevel_byte2_hw_disable = 0x1;
    const unsigned int rlevel_byte1_hw_disable = 0x1;
    const unsigned int rlevel_byte0_hw_disable = 0x1;
#endif
	
    reg70_value =
   116ee:	44 10 00 ff 	movi $r1,#0xff
    const unsigned int PDL_set_B7 = 0x0;  //bit[30:24]
    const unsigned int PDL_set_B6 = 0x0;  //bit[22:16]
    const unsigned int PDL_set_B5 = 0x0;  //bit[14:8]
    const unsigned int PDL_set_B4 = 0x0;  //bit[6:0]

    reg64_value =
   116f2:	f0 95       	swi37.sp $r0,[+#0x54]
    const unsigned int PDL_set_B3 = 0x0;  //bit[30:24]
    const unsigned int PDL_set_B2 = 0x0;  //bit[22:16]
    const unsigned int PDL_set_B1 = 0x0;  //bit[14:8]
    const unsigned int PDL_set_B0 = 0x0;  //bit[6:0]

    reg68_value =
   116f4:	f0 96       	swi37.sp $r0,[+#0x58]
    const unsigned int dqs_sel_wr_byte1 = 0x0; //bit[5]
    const unsigned int dqs_sel_byte1    = 0x0; //bit[4]
    const unsigned int dqs_sel_wr_byte0 = 0x0; //bit[1]
    const unsigned int dqs_sel_byte0    = 0x0; //bit[0]

    reg6C_value =
   116f6:	f0 97       	swi37.sp $r0,[+#0x5c]
    const unsigned int rlevel_byte2_hw_disable = 0x1;
    const unsigned int rlevel_byte1_hw_disable = 0x1;
    const unsigned int rlevel_byte0_hw_disable = 0x1;
#endif
	
    reg70_value =
   116f8:	f1 98       	swi37.sp $r1,[+#0x60]
    const unsigned int msdly_byte3 = 0x1; 
    const unsigned int msdly_byte2 = 0x1; 
    const unsigned int msdly_byte1 = 0x1; 
    const unsigned int msdly_byte0 = 0x1; 

    reg74_value =
   116fa:	46 11 11 11 	sethi $r1,#0x11111
   116fe:	50 10 81 11 	addi $r1,$r1,#0x111
   11702:	f1 99       	swi37.sp $r1,[+#0x64]
    const unsigned int wrdll_sel_byte3 = 0x0; 
    const unsigned int wrdll_sel_byte2 = 0x0; 
    const unsigned int wrdll_sel_byte1 = 0x0; 
    const unsigned int wrdll_sel_byte0 = 0x0; 

    reg78_value =
   11704:	f0 9a       	swi37.sp $r0,[+#0x68]
    // --- Offset 0x7C ---
    //--------------------   

    const unsigned int TM_cycle_reg = 0x0; 

    reg7C_value = TM_cycle_reg;
   11706:	f0 9b       	swi37.sp $r0,[+#0x6c]
    const unsigned int CH2_pref_value   = 0x1;
    const unsigned int CH2_limited_pref = 0x1;  
    const unsigned int CH3_pref_value   = 0x1;
    const unsigned int CH3_limited_pref = 0x1;  

    regA0_value =
   11708:	46 08 18 18 	sethi $r0,#0x81818
   1170c:	50 00 01 81 	addi $r0,$r0,#0x181
   11710:	f0 9c       	swi37.sp $r0,[+#0x70]
    const unsigned int CH6_pref_value   = 0x1;
    const unsigned int CH6_limited_pref = 0x1;  
    const unsigned int CH7_pref_value   = 0x1;
    const unsigned int CH7_limited_pref = 0x1;  

    regA4_value =
   11712:	f0 9d       	swi37.sp $r0,[+#0x74]
    //--------------------

    //wait_cycle_200us = 20'h1a0ab;
    const unsigned int wait_cycle_200us = 0x00200;

    regA8_value = wait_cycle_200us;
   11714:	44 00 02 00 	movi $r0,#0x200
   11718:	f0 9e       	swi37.sp $r0,[+#0x78]
    //--------------------

    //wait_cycle_500us = 20'h61a80;
    const unsigned int wait_cycle_500us = 0x1f000;

    regAC_value = wait_cycle_500us;
   1171a:	44 01 f0 00 	movi $r0,#0x1f000
   1171e:	f0 9f       	swi37.sp $r0,[+#0x7c]
    const unsigned int QoS_Period = 0x1; //0: 512 cycles
    //1: 1024 cycles
    //2: 2048 cycles
    //3: 4096 cycles  

    regB0_value=
   11720:	84 02       	movi55 $r0,#0x2
   11722:	f0 a0       	swi37.sp $r0,[+#0x80]
    const unsigned int ch2_QoS_CmdCnt = 0x3;
    const unsigned int ch1_QoS_CmdCnt = 0x4;
    const unsigned int ch0_QoS_CmdCnt = 0x4;


    regB4_value=
   11724:	46 00 30 30 	sethi $r0,#0x3030
   11728:	50 00 04 04 	addi $r0,$r0,#0x404
   1172c:	f0 a1       	swi37.sp $r0,[+#0x84]
    const unsigned int ch6_QoS_CmdCnt = 0x1;
    const unsigned int ch5_QoS_CmdCnt = 0x2;
    const unsigned int ch4_QoS_CmdCnt = 0x2;


    regB8_value=
   1172e:	46 00 10 10 	sethi $r0,#0x1010
   11732:	50 00 02 02 	addi $r0,$r0,#0x202
   11736:	f0 a2       	swi37.sp $r0,[+#0x88]
    | (ch4_QoS_CmdCnt);




    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;
   11738:	f1 03       	lwi37.sp $r1,[+#0xc]
   1173a:	46 0f 05 00 	sethi $r0,#0xf0500
   1173e:	b6 20       	swi450 $r1,[$r0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x04) = reg04_value;
   11740:	f1 04       	lwi37.sp $r1,[+#0x10]
   11742:	a8 41       	swi333 $r1,[$r0+#0x4]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x08) = reg08_value;
   11744:	f1 05       	lwi37.sp $r1,[+#0x14]
   11746:	a8 42       	swi333 $r1,[$r0+#0x8]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x0C) = reg0C_value;  
   11748:	f1 06       	lwi37.sp $r1,[+#0x18]
   1174a:	a8 43       	swi333 $r1,[$r0+#0xc]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x10) = reg10_value;
   1174c:	f1 07       	lwi37.sp $r1,[+#0x1c]
   1174e:	a8 44       	swi333 $r1,[$r0+#0x10]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x14) = reg14_value;
   11750:	f1 08       	lwi37.sp $r1,[+#0x20]
   11752:	a8 45       	swi333 $r1,[$r0+#0x14]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x18) = reg18_value;
   11754:	f1 09       	lwi37.sp $r1,[+#0x24]
   11756:	a8 46       	swi333 $r1,[$r0+#0x18]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x1c) = reg1C_value;
   11758:	f1 0a       	lwi37.sp $r1,[+#0x28]
   1175a:	a8 47       	swi333 $r1,[$r0+#0x1c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x20) = reg20_value;
   1175c:	f1 0b       	lwi37.sp $r1,[+#0x2c]
   1175e:	83 80       	mov55 $fp,$r0
   11760:	b9 88       	swi37 $r1,[$fp+#0x20]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x24) = reg24_value;
   11762:	f1 0c       	lwi37.sp $r1,[+#0x30]
   11764:	b9 89       	swi37 $r1,[$fp+#0x24]
    //*(volatile unsigned int *) (DDR_REG_BASE + 0x28) = reg28_value;
    //*(volatile unsigned int *) (DDR_REG_BASE + 0x2C) = reg2C_value;
    *(volatile unsigned int *) (DDR_REG_BASE + 0x30) = reg30_value;
   11766:	f1 0d       	lwi37.sp $r1,[+#0x34]
   11768:	b9 8c       	swi37 $r1,[$fp+#0x30]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x34) = reg34_value;
   1176a:	f1 0e       	lwi37.sp $r1,[+#0x38]
   1176c:	b9 8d       	swi37 $r1,[$fp+#0x34]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x38) = reg38_value;
   1176e:	f1 0f       	lwi37.sp $r1,[+#0x3c]
   11770:	b9 8e       	swi37 $r1,[$fp+#0x38]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x3C) = reg3C_value;
   11772:	f1 10       	lwi37.sp $r1,[+#0x40]
   11774:	b9 8f       	swi37 $r1,[$fp+#0x3c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x40) = reg40_value;
   11776:	f1 11       	lwi37.sp $r1,[+#0x44]
   11778:	b9 90       	swi37 $r1,[$fp+#0x40]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x48) = reg48_value;
   1177a:	f1 12       	lwi37.sp $r1,[+#0x48]
   1177c:	b9 92       	swi37 $r1,[$fp+#0x48]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x4C) = reg4C_value;
   1177e:	f1 13       	lwi37.sp $r1,[+#0x4c]
   11780:	b9 93       	swi37 $r1,[$fp+#0x4c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x60) = reg60_value;
   11782:	f1 14       	lwi37.sp $r1,[+#0x50]
   11784:	b9 98       	swi37 $r1,[$fp+#0x60]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x64) = reg64_value;
   11786:	f1 15       	lwi37.sp $r1,[+#0x54]
   11788:	b9 99       	swi37 $r1,[$fp+#0x64]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x68) = reg68_value;
   1178a:	f1 16       	lwi37.sp $r1,[+#0x58]
   1178c:	b9 9a       	swi37 $r1,[$fp+#0x68]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x6C) = reg6C_value;
   1178e:	f1 17       	lwi37.sp $r1,[+#0x5c]
   11790:	b9 9b       	swi37 $r1,[$fp+#0x6c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x70) = reg70_value;
   11792:	f1 18       	lwi37.sp $r1,[+#0x60]
   11794:	b9 9c       	swi37 $r1,[$fp+#0x70]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x74) = reg74_value;
   11796:	f1 19       	lwi37.sp $r1,[+#0x64]
   11798:	b9 9d       	swi37 $r1,[$fp+#0x74]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x78) = reg78_value;
   1179a:	f1 1a       	lwi37.sp $r1,[+#0x68]
   1179c:	b9 9e       	swi37 $r1,[$fp+#0x78]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x7C) = reg7C_value;
   1179e:	f1 1b       	lwi37.sp $r1,[+#0x6c]
   117a0:	b9 9f       	swi37 $r1,[$fp+#0x7c]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xa0) = regA0_value;
   117a2:	f1 1c       	lwi37.sp $r1,[+#0x70]
   117a4:	b9 a8       	swi37 $r1,[$fp+#0xa0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xa4) = regA4_value;
   117a6:	f1 1d       	lwi37.sp $r1,[+#0x74]
   117a8:	b9 a9       	swi37 $r1,[$fp+#0xa4]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xa8) = regA8_value;
   117aa:	f1 1e       	lwi37.sp $r1,[+#0x78]
   117ac:	b9 aa       	swi37 $r1,[$fp+#0xa8]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xaC) = regAC_value;
   117ae:	f1 1f       	lwi37.sp $r1,[+#0x7c]
   117b0:	b9 ab       	swi37 $r1,[$fp+#0xac]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xb0) = regB0_value;
   117b2:	f1 20       	lwi37.sp $r1,[+#0x80]
   117b4:	b9 ac       	swi37 $r1,[$fp+#0xb0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xb4) = regB4_value;
   117b6:	f1 21       	lwi37.sp $r1,[+#0x84]
   117b8:	b9 ad       	swi37 $r1,[$fp+#0xb4]
    *(volatile unsigned int *) (DDR_REG_BASE + 0xb8) = regB8_value;
   117ba:	f1 22       	lwi37.sp $r1,[+#0x88]
   117bc:	b9 ae       	swi37 $r1,[$fp+#0xb8]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x138) = 0x5;
   117be:	84 25       	movi55 $r1,#0x5
   117c0:	b9 ce       	swi37 $r1,[$fp+#0x138]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x134) = 0x00304444;
   117c2:	46 10 03 04 	sethi $r1,#0x304
   117c6:	50 10 84 44 	addi $r1,$r1,#0x444
   117ca:	b9 cd       	swi37 $r1,[$fp+#0x134]
   117cc:	44 20 00 32 	movi $r2,#0x32

    //wait 500us
    for(i=0;i<50;i++)
    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;
   117d0:	f3 03       	lwi37.sp $r3,[+#0xc]
   117d2:	8e 41       	subi45 $r2,#0x1
   117d4:	46 1f 05 00 	sethi $r1,#0xf0500
   117d8:	b6 60       	swi450 $r3,[$r0]
    *(volatile unsigned int *) (DDR_REG_BASE + 0x138) = 0x5;

    *(volatile unsigned int *) (DDR_REG_BASE + 0x134) = 0x00304444;

    //wait 500us
    for(i=0;i<50;i++)
   117da:	ca fb       	bnez38 $r2,117d0 <ddr3_set+0x1f4>
    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;

    MemCmd_initial = 0x1;
   117dc:	84 01       	movi55 $r0,#0x1
   117de:	f0 a3       	swi37.sp $r0,[+#0x8c]
    reg04_value =
    (MRS_mode        << 4)
    | (MemCmd_exit_srf << 3)
    | (MemCmd_srf      << 2)
| (MemCmd_mrs      << 1)
    | (MemCmd_initial); 
   117e0:	f0 23       	lwi37.sp $r0,[+#0x8c]
    for(i=0;i<50;i++)
    *(volatile unsigned int *) (DDR_REG_BASE + 0x00) = reg00_value;

    MemCmd_initial = 0x1;

    reg04_value =
   117e2:	f0 84       	swi37.sp $r0,[+#0x10]
    | (MemCmd_exit_srf << 3)
    | (MemCmd_srf      << 2)
| (MemCmd_mrs      << 1)
    | (MemCmd_initial); 

    *(volatile unsigned int *) (DDR_REG_BASE + 0x04) = reg04_value;
   117e4:	f0 04       	lwi37.sp $r0,[+#0x10]
   117e6:	a8 09       	swi333 $r0,[$r1+#0x4]

    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);

while ( (data & 0x100) != 0x100) 
    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);
   117e8:	a0 09       	lwi333 $r0,[$r1+#0x4]

    *(volatile unsigned int *) (DDR_REG_BASE + 0x04) = reg04_value;

    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);

while ( (data & 0x100) != 0x100) 
   117ea:	54 00 01 00 	andi $r0,$r0,#0x100
   117ee:	c0 fd       	beqz38 $r0,117e8 <ddr3_set+0x20c>
    data = *(volatile unsigned int *) (DDR_REG_BASE + 0x04);

    //DDR test write & verify
    *(volatile unsigned int *) (DDR_MEM_BASE) = 0x01020304; data = *(volatile unsigned int *) (DDR_MEM_BASE);
   117f0:	46 00 10 20 	sethi $r0,#0x1020
   117f4:	46 12 00 00 	sethi $r1,#0x20000
   117f8:	50 00 03 04 	addi $r0,$r0,#0x304
   117fc:	b6 01       	swi450 $r0,[$r1]
   117fe:	b4 a1       	lwi450 $r5,[$r1]
if (data == 0x01020304)
   11800:	d8 06       	bnes38 $r0,1180c <ddr3_set+0x230>
{
    *(volatile unsigned int *) (DDR_MEM_BASE) = 0x89abcdef;
   11802:	46 08 9a bc 	sethi $r0,#0x89abc
   11806:	50 00 0d ef 	addi $r0,$r0,#0xdef
   1180a:	b6 01       	swi450 $r0,[$r1]
   1180c:	fc 92       	pop25 $r6,#144    ! {$r6, $fp, $gp, $lp}
	...

00011810 <memcpy>:
   11810:	80 60       	mov55 $r3,$r0
   11812:	40 51 08 09 	srli $r5,$r2,#0x2
   11816:	4e 52 00 0a 	beqz $r5,1182a <memcpy+0x1a>
   1181a:	95 6a       	slli333 $r5,$r5,#0x2
   1181c:	99 69       	add333 $r5,$r5,$r1
   1181e:	96 8f       	fexti33 $r2,#0x1
   11820:	3a 40 90 04 	lmw.bim $r4,[$r1],$r4,#0x0    ! {$r4}
   11824:	3a 41 90 24 	smw.bim $r4,[$r3],$r4,#0x0    ! {$r4}
   11828:	d9 fc       	bnes38 $r1,11820 <memcpy+0x10>
   1182a:	c2 08       	beqz38 $r2,1183a <memcpy+0x2a>
   1182c:	40 50 88 00 	add $r5,$r1,$r2
   11830:	08 40 80 01 	lbi.bi $r4,[$r1],#0x1
   11834:	18 41 80 01 	sbi.bi $r4,[$r3],#0x1
   11838:	d9 fc       	bnes38 $r1,11830 <memcpy+0x20>
   1183a:	dd 9e       	ret5 $lp

0001183c <memset>:
   1183c:	80 60       	mov55 $r3,$r0
   1183e:	40 51 08 09 	srli $r5,$r2,#0x2
   11842:	96 8f       	fexti33 $r2,#0x1
   11844:	c5 0d       	beqz38 $r5,1185e <memset+0x22>
   11846:	95 6a       	slli333 $r5,$r5,#0x2
   11848:	99 5d       	add333 $r5,$r3,$r5
   1184a:	96 48       	zeb33 $r1,$r1
   1184c:	40 40 a0 08 	slli $r4,$r1,#0x8
   11850:	fe 67       	or33 $r1,$r4
   11852:	40 40 c0 08 	slli $r4,$r1,#0x10
   11856:	fe 67       	or33 $r1,$r4
   11858:	3a 11 84 24 	smw.bim $r1,[$r3],$r1,#0x0    ! {$r1}
   1185c:	db fe       	bnes38 $r3,11858 <memset+0x1c>
   1185e:	99 5a       	add333 $r5,$r3,$r2
   11860:	d3 04       	beqs38 $r3,11868 <memset+0x2c>
   11862:	18 11 80 01 	sbi.bi $r1,[$r3],#0x1
   11866:	d5 fd       	j8 11860 <memset+0x24>
   11868:	dd 9e       	ret5 $lp
   1186a:	92 00       	nop16
